{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Albert Python SDK","text":"<p>The Albert Python SDK provides a comprehensive and easy-to-use interface for interacting with the Albert API. The SDK is designed to simplify the process of working with various resources such as inventories, projects, companies, and tags by providing Resource Collections and Resource Models.</p> <p>[!WARNING] The Albert SDK is still in the early phases of development. As such, patterns may change, and methods may not work as expected. Do not use this package unless you are comfortable with these limitations.</p>"},{"location":"#installation","title":"Installation","text":"<p>TODO: Add installation instructions from PyPI once published</p> <p>For developers, please see the CONTRIBUTING.MD for local installation instructions.</p>"},{"location":"#overview","title":"Overview","text":"<p>The SDK is built around two main concepts:</p> <ol> <li> <p>Resource Models: Represent individual entities like InventoryItem, Project, Company, and Tag. These are all controlled using Pydantic.</p> </li> <li> <p>Resource Collections: Provide methods to interact with the API endpoints related to a specific resource, such as listing, creating, updating, and deleting resources.</p> </li> </ol>"},{"location":"#resource-models","title":"Resource Models","text":"<p>Resource Models represent the data structure of individual resources. They encapsulate the attributes and behaviors of a single resource. For example, an <code>InventoryItem</code> has attributes like <code>name</code>, <code>description</code>, <code>category</code>, and <code>tags</code>.  page\"</p>"},{"location":"#resource-collections","title":"Resource Collections","text":"<p>Resource Collections act as managers for Resource Models. They provide methods for performing CRUD operations (Create, Read, Update, Delete) on the resources. For example, the <code>InventoryCollection</code> class has methods like create, <code>get_by_id()</code>, <code>list()</code>, <code>update()</code>, and <code>delete()</code>. <code>list()</code> methods generally accept parameters to narrow the query to use it like a search.</p>"},{"location":"albert/","title":"Albert Client","text":""},{"location":"albert/#albert.albert.Albert","title":"Albert","text":"<pre><code>Albert(\n    *,\n    base_url: str | None = None,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>Albert is the main client class for interacting with the Albert API.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL of the Albert API (default is \"https://app.albertinvent.com\").</p> <code>None</code> <code>token</code> <code>str</code> <p>The token for authentication (default is read from environment variable \"ALBERT_TOKEN\").</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Client credentials can be read from the environment by <code>ClientCredentials.from_env()</code>.</p> <code>None</code> <code>retries</code> <code>int</code> <p>The maximum number of retries for failed requests (default is None).</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>session</code> <code>AlbertSession</code> <p>The session for API requests, with a base URL set.</p> <code>projects</code> <code>ProjectCollection</code> <p>The project collection instance.</p> <code>tags</code> <code>TagCollection</code> <p>The tag collection instance.</p> <code>inventory</code> <code>InventoryCollection</code> <p>The inventory collection instance.</p> <code>companies</code> <code>CompanyCollection</code> <p>The company collection instance.</p> <p>Methods:</p> Name Description <code>btmodels</code> Source code in <code>src/albert/albert.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str | None = None,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    self.session = AlbertSession(\n        base_url=base_url or os.getenv(\"ALBERT_BASE_URL\") or \"https://app.albertinvent.com\",\n        token=token or os.getenv(\"ALBERT_TOKEN\"),\n        client_credentials=client_credentials,\n        retries=retries,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.Albert.attachments","title":"attachments  <code>property</code>","text":"<pre><code>attachments: AttachmentCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.batch_data","title":"batch_data  <code>property</code>","text":"<pre><code>batch_data: BatchDataCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.btdatasets","title":"btdatasets  <code>property</code>","text":"<pre><code>btdatasets: BTDatasetCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.btinsights","title":"btinsights  <code>property</code>","text":"<pre><code>btinsights: BTInsightCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.btmodelsessions","title":"btmodelsessions  <code>property</code>","text":"<pre><code>btmodelsessions: BTModelSessionCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.cas_numbers","title":"cas_numbers  <code>property</code>","text":"<pre><code>cas_numbers: CasCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.companies","title":"companies  <code>property</code>","text":"<pre><code>companies: CompanyCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.custom_fields","title":"custom_fields  <code>property</code>","text":"<pre><code>custom_fields: CustomFieldCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.data_columns","title":"data_columns  <code>property</code>","text":"<pre><code>data_columns: DataColumnCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.data_templates","title":"data_templates  <code>property</code>","text":"<pre><code>data_templates: DataTemplateCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.files","title":"files  <code>property</code>","text":"<pre><code>files: FileCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.inventory","title":"inventory  <code>property</code>","text":"<pre><code>inventory: InventoryCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.links","title":"links  <code>property</code>","text":"<pre><code>links: LinksCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.lists","title":"lists  <code>property</code>","text":"<pre><code>lists: ListsCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.locations","title":"locations  <code>property</code>","text":"<pre><code>locations: LocationCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.lots","title":"lots  <code>property</code>","text":"<pre><code>lots: LotCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.notebooks","title":"notebooks  <code>property</code>","text":"<pre><code>notebooks: NotebookCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.notes","title":"notes  <code>property</code>","text":"<pre><code>notes: NotesCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.parameter_groups","title":"parameter_groups  <code>property</code>","text":"<pre><code>parameter_groups: ParameterGroupCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.parameters","title":"parameters  <code>property</code>","text":"<pre><code>parameters: ParameterCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.pricings","title":"pricings  <code>property</code>","text":"<pre><code>pricings: PricingCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.product_design","title":"product_design  <code>property</code>","text":"<pre><code>product_design: ProductDesignCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.projects","title":"projects  <code>property</code>","text":"<pre><code>projects: ProjectCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.property_data","title":"property_data  <code>property</code>","text":"<pre><code>property_data: PropertyDataCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.reports","title":"reports  <code>property</code>","text":"<pre><code>reports: ReportCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.roles","title":"roles  <code>property</code>","text":"<pre><code>roles: RoleCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = AlbertSession(\n    base_url=base_url\n    or getenv(\"ALBERT_BASE_URL\")\n    or \"https://app.albertinvent.com\",\n    token=token or getenv(\"ALBERT_TOKEN\"),\n    client_credentials=client_credentials,\n    retries=retries,\n)\n</code></pre>"},{"location":"albert/#albert.albert.Albert.storage_locations","title":"storage_locations  <code>property</code>","text":"<pre><code>storage_locations: StorageLocationsCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.substances","title":"substances  <code>property</code>","text":"<pre><code>substances: SubstanceCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.tags","title":"tags  <code>property</code>","text":"<pre><code>tags: TagCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: TaskCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.templates","title":"templates  <code>property</code>","text":"<pre><code>templates: CustomTemplatesCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.un_numbers","title":"un_numbers  <code>property</code>","text":"<pre><code>un_numbers: UnNumberCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.units","title":"units  <code>property</code>","text":"<pre><code>units: UnitCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.users","title":"users  <code>property</code>","text":"<pre><code>users: UserCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.workflows","title":"workflows  <code>property</code>","text":"<pre><code>workflows: WorkflowCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.worksheets","title":"worksheets  <code>property</code>","text":"<pre><code>worksheets: WorksheetCollection\n</code></pre>"},{"location":"albert/#albert.albert.Albert.btmodels","title":"btmodels","text":"<pre><code>btmodels(*, parent_id: str) -&gt; BTModelCollection\n</code></pre> Source code in <code>src/albert/albert.py</code> <pre><code>def btmodels(self, *, parent_id: str) -&gt; BTModelCollection:\n    return BTModelCollection(session=self.session, parent_id=parent_id)\n</code></pre>"},{"location":"albert/#albert.albert.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"albert/#albert.albert.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"albert/#albert.albert.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"albert/#albert.albert.AttachmentCollection","title":"AttachmentCollection","text":"<pre><code>AttachmentCollection(*, session)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>AttachmentCollection is a collection class for managing Attachment entities in the Albert platform.</p> <p>Methods:</p> Name Description <code>attach_file_to_note</code> <p>Attaches an already uploaded file to a note.</p> <code>delete</code> <p>Deletes an attachment by ID.</p> <code>upload_and_attach_file_as_note</code> <p>Uploads a file and attaches it to a new note. A user can be tagged in the note_text string by using f-string and the User.to_note_mention() method.</p> Source code in <code>src/albert/collections/attachments.py</code> <pre><code>def __init__(self, *, session):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{AttachmentCollection._api_version}/attachments\"\n</code></pre>"},{"location":"albert/#albert.albert.AttachmentCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/attachments'\n</code></pre>"},{"location":"albert/#albert.albert.AttachmentCollection.attach_file_to_note","title":"attach_file_to_note","text":"<pre><code>attach_file_to_note(\n    *,\n    note_id: str,\n    file_name: str,\n    file_key: str,\n    category: FileCategory = OTHER,\n) -&gt; Attachment\n</code></pre> <p>Attaches an already uploaded file to a note.</p> <p>Parameters:</p> Name Type Description Default <code>note_id</code> <code>str</code> <p>The ID of the note to attach the file to.</p> required <code>file_name</code> <code>str</code> <p>The name of the file to attach.</p> required <code>file_key</code> <code>str</code> <p>The unique key of the file to attach (the returned upload name).</p> required <code>category</code> <code>FileCategory</code> <p>The type of file, by default FileCategory.OTHER</p> <code>OTHER</code> <p>Returns:</p> Type Description <code>Attachment</code> <p>The related attachment object.</p> Source code in <code>src/albert/collections/attachments.py</code> <pre><code>def attach_file_to_note(\n    self,\n    *,\n    note_id: str,\n    file_name: str,\n    file_key: str,\n    category: FileCategory = FileCategory.OTHER,\n) -&gt; Attachment:\n    \"\"\"Attaches an already uploaded file to a note.\n\n    Parameters\n    ----------\n    note_id : str\n        The ID of the note to attach the file to.\n    file_name : str\n        The name of the file to attach.\n    file_key : str\n        The unique key of the file to attach (the returned upload name).\n    category : FileCategory, optional\n        The type of file, by default FileCategory.OTHER\n\n    Returns\n    -------\n    Attachment\n        The related attachment object.\n    \"\"\"\n    attachment = Attachment(\n        parent_id=note_id, name=file_name, key=file_key, namespace=\"result\", category=category\n    )\n    response = self.session.post(\n        url=self.base_path,\n        json=attachment.model_dump(by_alias=True, mode=\"json\", exclude_unset=True),\n    )\n    return Attachment(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.AttachmentCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes an attachment by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the attachment to delete.</p> required Source code in <code>src/albert/collections/attachments.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Deletes an attachment by ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the attachment to delete.\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"albert/#albert.albert.AttachmentCollection.upload_and_attach_file_as_note","title":"upload_and_attach_file_as_note","text":"<pre><code>upload_and_attach_file_as_note(\n    parent_id: str,\n    file_data: IO,\n    note_text: str = \"\",\n    file_name: str = \"\",\n) -&gt; Note\n</code></pre> <p>Uploads a file and attaches it to a new note. A user can be tagged in the note_text string by using f-string and the User.to_note_mention() method. This allows for easy tagging and referencing of users within notes. example: f\"Hello {tagged_user.to_note_mention()}!\"</p> <pre><code>Parameters\n</code></pre> <pre><code>parent_id : str\n    The ID of the parent entity onto which the note will be attached.\nfile_data : IO\n    The file data to upload.\nnote_text : str, optional\n    Any additional text to add to the note, by default \"\"\nfile_name : str, optional\n    The name of the file, by default \"\"\n</code></pre> <pre><code>Returns\n</code></pre> <pre><code>Note\n    The created note.\n</code></pre> Source code in <code>src/albert/collections/attachments.py</code> <pre><code>def upload_and_attach_file_as_note(\n    self, parent_id: str, file_data: IO, note_text: str = \"\", file_name: str = \"\"\n) -&gt; Note:\n    \"\"\"Uploads a file and attaches it to a new note. A user can be tagged in the note_text string by using f-string and the User.to_note_mention() method.\n    This allows for easy tagging and referencing of users within notes. example: f\"Hello {tagged_user.to_note_mention()}!\"\n\n        Parameters\n        ----------\n        parent_id : str\n            The ID of the parent entity onto which the note will be attached.\n        file_data : IO\n            The file data to upload.\n        note_text : str, optional\n            Any additional text to add to the note, by default \"\"\n        file_name : str, optional\n            The name of the file, by default \"\"\n\n        Returns\n        -------\n        Note\n            The created note.\n    \"\"\"\n    file_type = mimetypes.guess_type(file_name)[0]\n    file_collection = self._get_file_collection()\n    note_collection = self._get_note_collection()\n\n    file_collection.sign_and_upload_file(\n        data=file_data,\n        name=file_name,\n        namespace=FileNamespace.RESULT.value,\n        content_type=file_type,\n    )\n    file_info = file_collection.get_by_name(\n        name=file_name, namespace=FileNamespace.RESULT.value\n    )\n    note = Note(\n        parent_id=parent_id,\n        note=note_text,\n    )\n    registered_note = note_collection.create(note=note)\n    self.attach_file_to_note(\n        note_id=registered_note.id,\n        file_name=file_name,\n        file_key=file_info.name,\n    )\n    return note_collection.get_by_id(id=registered_note.id)\n</code></pre>"},{"location":"albert/#albert.albert.BTDatasetCollection","title":"BTDatasetCollection","text":"<pre><code>BTDatasetCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>BTDatasetCollection is a collection class for managing Breakthrough dataset entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base path for btdataset API requests.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new BTDataset.</p> <code>delete</code> <p>Delete a BTDataset by ID.</p> <code>get_by_id</code> <p>Get a BTDataset by ID.</p> <code>list</code> <p>List items in the BTInsight collection.</p> <code>update</code> <p>Update a BTDataset.</p> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initialize the BTDatasetCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{BTDatasetCollection._api_version}/btdataset\"\n</code></pre>"},{"location":"albert/#albert.albert.BTDatasetCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/btdataset'\n</code></pre>"},{"location":"albert/#albert.albert.BTDatasetCollection.create","title":"create","text":"<pre><code>create(*, dataset: BTDataset) -&gt; BTDataset\n</code></pre> <p>Create a new BTDataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>BTDataset</code> <p>The BTDataset record to create.</p> required <p>Returns:</p> Type Description <code>BTDataset</code> <p>The created BTDataset.</p> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def create(self, *, dataset: BTDataset) -&gt; BTDataset:\n    \"\"\"\n    Create a new BTDataset.\n\n    Parameters\n    ----------\n    dataset : BTDataset\n        The BTDataset record to create.\n\n    Returns\n    -------\n    BTDataset\n        The created BTDataset.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=dataset.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return BTDataset(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.BTDatasetCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a BTDataset by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the BTDataset to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a BTDataset by ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the BTDataset to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"albert/#albert.albert.BTDatasetCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; BTDataset\n</code></pre> <p>Get a BTDataset by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The Albert ID of the BTDataset.</p> required <p>Returns:</p> Type Description <code>BTDataset</code> <p>The retrived BTDataset.</p> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; BTDataset:\n    \"\"\"\n    Get a BTDataset by ID.\n\n    Parameters\n    ----------\n    id : str\n        The Albert ID of the BTDataset.\n\n    Returns\n    -------\n    BTDataset\n        The retrived BTDataset.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return BTDataset(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.BTDatasetCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    name: str | None = None,\n    start_key: str | None = None,\n    created_by: str | None = None,\n) -&gt; Iterator[BTDataset]\n</code></pre> <p>List items in the BTInsight collection.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Number of items to return per page, default 100</p> <code>100</code> <code>name</code> <code>str</code> <p>Name of the dataset to filter by, default None</p> <code>None</code> <code>start_key</code> <code>str</code> <p>The starting key for pagination, default None</p> <code>None</code> <code>created_by</code> <code>str</code> <p>The user who created the dataset, default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[BTDataset]</code> <p>An iterator of elements returned by the BTDataset listing.</p> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    name: str | None = None,\n    start_key: str | None = None,\n    created_by: str | None = None,\n) -&gt; Iterator[BTDataset]:\n    \"\"\"List items in the BTInsight collection.\n\n    Parameters\n    ----------\n    limit : int, optional\n        Number of items to return per page, default 100\n    name : str, optional\n        Name of the dataset to filter by, default None\n    start_key : str, optional\n        The starting key for pagination, default None\n    created_by : str, optional\n        The user who created the dataset, default None\n\n    Returns\n    -------\n    Iterator[BTDataset]\n        An iterator of elements returned by the BTDataset listing.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[BTDataset]:\n        yield from [BTDataset(**item) for item in items]\n\n    params = {\n        \"limit\": limit,\n        \"startKey\": start_key,\n        \"createdBy\": created_by,\n        \"name\": name,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.BTDatasetCollection.update","title":"update","text":"<pre><code>update(*, dataset: BTDataset) -&gt; BTDataset\n</code></pre> <p>Update a BTDataset.</p> <p>The provided dataset must be registered with an Albert ID.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>BTDataset</code> <p>The BTDataset with updated fields.</p> required <p>Returns:</p> Type Description <code>BTDataset</code> <p>The updated BTDataset object.</p> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def update(self, *, dataset: BTDataset) -&gt; BTDataset:\n    \"\"\"\n    Update a BTDataset.\n\n    The provided dataset must be registered with an Albert ID.\n\n    Parameters\n    ----------\n    dataset : BTDataset\n        The BTDataset with updated fields.\n\n    Returns\n    -------\n    BTDataset\n        The updated BTDataset object.\n    \"\"\"\n    path = f\"{self.base_path}/{dataset.id}\"\n    payload = self._generate_patch_payload(\n        existing=self.get_by_id(id=dataset.id),\n        updated=dataset,\n    )\n    self.session.patch(path, json=payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=dataset.id)\n</code></pre>"},{"location":"albert/#albert.albert.BTInsightCollection","title":"BTInsightCollection","text":"<pre><code>BTInsightCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>BTInsightCollection is a collection class for managing Breakthrough insight entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base path for BTInsight API requests.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new BTInsight.</p> <code>delete</code> <p>Delete a BTInsight by ID.</p> <code>get_by_id</code> <p>Get a BTInsight by ID.</p> <code>list</code> <p>List items in the BTInsight collection.</p> <code>update</code> <p>Update a BTInsight.</p> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initialize the BTInsightCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{BTInsightCollection._api_version}/btinsight\"\n</code></pre>"},{"location":"albert/#albert.albert.BTInsightCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/btinsight'\n</code></pre>"},{"location":"albert/#albert.albert.BTInsightCollection.create","title":"create","text":"<pre><code>create(*, insight: BTInsight) -&gt; BTInsight\n</code></pre> <p>Create a new BTInsight.</p> <p>Parameters:</p> Name Type Description Default <code>insight</code> <code>BTInsight</code> <p>The BTInsight record to create.</p> required <p>Returns:</p> Type Description <code>BTInsight</code> <p>The created BTInsight.</p> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def create(self, *, insight: BTInsight) -&gt; BTInsight:\n    \"\"\"\n    Create a new BTInsight.\n\n    Parameters\n    ----------\n    insight : BTInsight\n        The BTInsight record to create.\n\n    Returns\n    -------\n    BTInsight\n        The created BTInsight.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=insight.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return BTInsight(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.BTInsightCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a BTInsight by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the BTInsight to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a BTInsight by ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the BTInsight to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"albert/#albert.albert.BTInsightCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; BTInsight\n</code></pre> <p>Get a BTInsight by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The Albert ID of the insight.</p> required <p>Returns:</p> Type Description <code>BTInsight</code> <p>The retrived BTInsight.</p> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; BTInsight:\n    \"\"\"\n    Get a BTInsight by ID.\n\n    Parameters\n    ----------\n    id : str\n        The Albert ID of the insight.\n\n    Returns\n    -------\n    BTInsight\n        The retrived BTInsight.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return BTInsight(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.BTInsightCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    offset: int | None = None,\n    order_by: OrderBy | None = None,\n    sort_by: str | None = None,\n    text: str | None = None,\n    name: str | list[str] | None = None,\n    state: BTInsightState\n    | list[BTInsightState]\n    | None = None,\n    category: BTInsightCategory\n    | list[BTInsightCategory]\n    | None = None,\n) -&gt; Iterator[BTInsight]\n</code></pre> <p>List items in the BTInsight collection.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Number of items to return per page, default 100</p> <code>100</code> <code>offset</code> <code>int | None</code> <p>Item offset to begin search at, default None</p> <code>None</code> <code>order_by</code> <code>OrderBy | None</code> <p>Asc/desc ordering, default None</p> <code>None</code> <code>sort_by</code> <code>str | None</code> <p>Sort field, default None</p> <code>None</code> <code>text</code> <code>str | None</code> <p>Text field in search query, default None</p> <code>None</code> <code>name</code> <code>str | list[str] | None</code> <p>BTInsight name search filter, default None</p> <code>None</code> <code>state</code> <code>BTInsightState | list[BTInsightState] | None</code> <p>BTInsight state search filter, default None</p> <code>None</code> <code>category</code> <code>BTInsightCategory | list[BTInsightCategory] | None</code> <p>BTInsight category search filter, default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[BTInsight]</code> <p>An iterator of elements returned by the BTInsight search query.</p> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    offset: int | None = None,\n    order_by: OrderBy | None = None,\n    sort_by: str | None = None,\n    text: str | None = None,\n    name: str | list[str] | None = None,\n    state: BTInsightState | list[BTInsightState] | None = None,\n    category: BTInsightCategory | list[BTInsightCategory] | None = None,\n) -&gt; Iterator[BTInsight]:\n    \"\"\"List items in the BTInsight collection.\n\n    Parameters\n    ----------\n    limit : int, optional\n        Number of items to return per page, default 100\n    offset : int | None, optional\n        Item offset to begin search at, default None\n    order_by : OrderBy | None, optional\n        Asc/desc ordering, default None\n    sort_by : str | None\n        Sort field, default None\n    text : str | None\n        Text field in search query, default None\n    name : str | list[str] | None\n        BTInsight name search filter, default None\n    state : BTInsightState | list[BTInsightState] | None\n        BTInsight state search filter, default None\n    category : BTInsightCategory | list[BTInsightCategory] | None\n        BTInsight category search filter, default None\n\n    Returns\n    -------\n    Iterator[BTInsight]\n        An iterator of elements returned by the BTInsight search query.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[BTInsight]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching insight '{id}': {e}\")\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"order\": OrderBy(order_by).value if order_by else None,\n        \"sortBy\": sort_by,\n        \"text\": text,\n        \"name\": name,\n    }\n    if state:\n        state = state if isinstance(state, list) else [state]\n        params[\"state\"] = [BTInsightState(x).value for x in state]\n    if category:\n        category = category if isinstance(category, list) else [category]\n        params[\"category\"] = [BTInsightCategory(x).value for x in category]\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.BTInsightCollection.update","title":"update","text":"<pre><code>update(*, insight: BTInsight) -&gt; BTInsight\n</code></pre> <p>Update a BTInsight.</p> <p>Parameters:</p> Name Type Description Default <code>insight</code> <code>BTInsight</code> <p>The BTInsight to update.</p> required <p>Returns:</p> Type Description <code>BTInsight</code> <p>The updated BTInsight.</p> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def update(self, *, insight: BTInsight) -&gt; BTInsight:\n    \"\"\"Update a BTInsight.\n\n    Parameters\n    ----------\n    insight : BTInsight\n        The BTInsight to update.\n\n    Returns\n    -------\n    BTInsight\n        The updated BTInsight.\n    \"\"\"\n    path = f\"{self.base_path}/{insight.id}\"\n    payload = self._generate_patch_payload(\n        existing=self.get_by_id(id=insight.id),\n        updated=insight,\n        generate_metadata_diff=False,\n    )\n    self.session.patch(path, json=payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=insight.id)\n</code></pre>"},{"location":"albert/#albert.albert.BTModelCollection","title":"BTModelCollection","text":"<pre><code>BTModelCollection(\n    *, session: AlbertSession, parent_id: str\n)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>BTModelCollection is a collection class for managing Breakthrough model entities.</p> <p>Breakthrough models are associated with a parent Breakthrough model session.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <code>parent_id</code> <code>str</code> <p>The Albert ID for the parent BTModelSession.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base path for BTModel API requests.</p> <p>Methods:</p> Name Description <code>create</code> <code>delete</code> <p>Delete a BTModel by ID.</p> <code>get_by_id</code> <code>update</code> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def __init__(self, *, session: AlbertSession, parent_id: str):\n    super().__init__(session=session)\n    self.parent_id = parent_id\n    self.base_path = f\"/api/{BTModelCollection._api_version}/btmodel/{parent_id}/model\"\n</code></pre>"},{"location":"albert/#albert.albert.BTModelCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f\"/api/{_api_version}/btmodel/{parent_id}/model\"\n</code></pre>"},{"location":"albert/#albert.albert.BTModelCollection.parent_id","title":"parent_id  <code>instance-attribute</code>","text":"<pre><code>parent_id = parent_id\n</code></pre>"},{"location":"albert/#albert.albert.BTModelCollection.create","title":"create","text":"<pre><code>create(*, model: BTModel) -&gt; BTModel\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def create(self, *, model: BTModel) -&gt; BTModel:\n    response = self.session.post(\n        self.base_path,\n        json=model.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return BTModel(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.BTModelCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a BTModel by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the BTModel to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a BTModel by ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the BTModel to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"albert/#albert.albert.BTModelCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; BTModel\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; BTModel:\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return BTModel(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.BTModelCollection.update","title":"update","text":"<pre><code>update(*, model: BTModel) -&gt; BTModel\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def update(self, *, model: BTModel) -&gt; BTModel:\n    path = f\"{self.base_path}/{model.id}\"\n    payload = self._generate_patch_payload(\n        existing=self.get_by_id(id=model.id),\n        updated=model,\n    )\n    self.session.patch(path, json=payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=model.id)\n</code></pre>"},{"location":"albert/#albert.albert.BTModelSessionCollection","title":"BTModelSessionCollection","text":"<pre><code>BTModelSessionCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>BTModelSessionCollection is a collection class for managing Breakthrough model session entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base path for BTModelSession API requests.</p> <p>Methods:</p> Name Description <code>create</code> <code>delete</code> <p>Delete a BTModelSession by ID.</p> <code>get_by_id</code> <code>update</code> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{BTModelSessionCollection._api_version}/btmodel\"\n</code></pre>"},{"location":"albert/#albert.albert.BTModelSessionCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/btmodel'\n</code></pre>"},{"location":"albert/#albert.albert.BTModelSessionCollection.create","title":"create","text":"<pre><code>create(*, model_session: BTModelSession) -&gt; BTModelSession\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def create(self, *, model_session: BTModelSession) -&gt; BTModelSession:\n    response = self.session.post(\n        self.base_path,\n        json=model_session.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return self._deserialize_with_session(response.json())\n</code></pre>"},{"location":"albert/#albert.albert.BTModelSessionCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a BTModelSession by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the BTModelSession to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a BTModelSession by ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the BTModelSession to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"albert/#albert.albert.BTModelSessionCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; BTModelSession\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; BTModelSession:\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return self._deserialize_with_session(response.json())\n</code></pre>"},{"location":"albert/#albert.albert.BTModelSessionCollection.update","title":"update","text":"<pre><code>update(*, model_session: BTModelSession) -&gt; BTModelSession\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def update(self, *, model_session: BTModelSession) -&gt; BTModelSession:\n    path = f\"{self.base_path}/{model_session.id}\"\n    payload = self._generate_patch_payload(\n        existing=self.get_by_id(id=model_session.id),\n        updated=model_session,\n    )\n    self.session.patch(path, json=payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=model_session.id)\n</code></pre>"},{"location":"albert/#albert.albert.BatchDataCollection","title":"BatchDataCollection","text":"<pre><code>BatchDataCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>BatchDataCollection is a collection class for managing BatchData entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create_batch_data</code> <p>Create a new batch data entry.</p> <code>get</code> <p>Retrieve BatchData by ID.</p> <code>update_used_batch_amounts</code> <p>Update the used batch amounts for a given task ID.</p> Source code in <code>src/albert/collections/batch_data.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the BatchDataCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{BatchDataCollection._api_version}/batchdata\"\n</code></pre>"},{"location":"albert/#albert.albert.BatchDataCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/batchdata'\n</code></pre>"},{"location":"albert/#albert.albert.BatchDataCollection.create_batch_data","title":"create_batch_data","text":"<pre><code>create_batch_data(*, task_id: TaskId)\n</code></pre> <p>Create a new batch data entry.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task for which the batch data is being created.</p> required <p>Returns:</p> Type Description <code>BatchData</code> <p>The created BatchData object.</p> Source code in <code>src/albert/collections/batch_data.py</code> <pre><code>def create_batch_data(self, *, task_id: TaskId):\n    \"\"\"\n    Create a new batch data entry.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task for which the batch data is being created.\n\n    Returns\n    -------\n    BatchData\n        The created BatchData object.\n    \"\"\"\n    url = f\"{self.base_path}\"\n    response = self.session.post(url, json={\"parentId\": task_id})\n    return BatchData(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.BatchDataCollection.get","title":"get","text":"<pre><code>get(\n    *,\n    id: TaskId,\n    type: BatchDataType = TASK_ID,\n    limit: int = 100,\n    start_key: str | None = None,\n    order_by: OrderBy = DESCENDING,\n) -&gt; BatchData\n</code></pre> <p>Retrieve BatchData by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TaskId</code> <p>Unique Id of the selected type.</p> required <code>type</code> <code>BatchDataType</code> <p>Type of Id for which BatchData will be fetched.</p> <code>TASK_ID</code> <code>limit</code> <code>int</code> <p>The maximum number of list entities to return.</p> <code>100</code> <code>start_key</code> <code>str</code> <p>The primary key of the first item that this operation will evaluate.</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING</p> <code>DESCENDING</code> <p>Returns:</p> Type Description <code>BatchData</code> <p>The BatchData object.</p> Source code in <code>src/albert/collections/batch_data.py</code> <pre><code>def get(\n    self,\n    *,\n    id: TaskId,\n    type: BatchDataType = BatchDataType.TASK_ID,\n    limit: int = 100,\n    start_key: str | None = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n) -&gt; BatchData:\n    \"\"\"\n    Retrieve BatchData by ID.\n\n    Parameters\n    ----------\n    id : TaskId\n        Unique Id of the selected type.\n    type : BatchDataType\n        Type of Id for which BatchData will be fetched.\n    limit : int, optional\n        The maximum number of list entities to return.\n    start_key : str, optional\n        The primary key of the first item that this operation will evaluate.\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING\n    Returns\n    ------\n    BatchData\n        The BatchData object.\n    \"\"\"\n    params = {\n        \"id\": id,\n        \"limit\": limit,\n        \"type\": type,\n        \"startKey\": start_key,\n        \"orderBy\": order_by,\n    }\n    response = self.session.get(self.base_path, params=params)\n    return BatchData(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.BatchDataCollection.update_used_batch_amounts","title":"update_used_batch_amounts","text":"<pre><code>update_used_batch_amounts(\n    *, task_id: str, patches=list[BatchValuePatchPayload]\n) -&gt; None\n</code></pre> <p>Update the used batch amounts for a given task ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to update.</p> required <code>patch</code> <code>BatchValuePatchPayload</code> <p>The patch payload containing the data to update.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This method does not return anything.</p> Source code in <code>src/albert/collections/batch_data.py</code> <pre><code>def update_used_batch_amounts(\n    self, *, task_id: str, patches=list[BatchValuePatchPayload]\n) -&gt; None:\n    \"\"\"\n    Update the used batch amounts for a given task ID.\n\n    Parameters\n    ----------\n    task_id : str\n        The ID of the task to update.\n    patch : BatchValuePatchPayload\n        The patch payload containing the data to update.\n\n    Returns\n    -------\n    None\n        This method does not return anything.\n    \"\"\"\n    url = f\"{self.base_path}/{task_id}/values\"\n    self.session.patch(\n        url,\n        json=[\n            patch.model_dump(exclude_none=True, by_alias=True, mode=\"json\")\n            for patch in patches\n        ],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.CasCollection","title":"CasCollection","text":"<pre><code>CasCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>CasCollection is a collection class for managing Cas entities on the Albert Platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>cas_exists</code> <p>Checks if a CAS exists by its number.</p> <code>create</code> <p>Creates a new CAS entity.</p> <code>delete</code> <p>Deletes a CAS by its ID.</p> <code>get_by_id</code> <p>Retrieves a CAS by its ID.</p> <code>get_by_number</code> <p>Retrieves a CAS by its number.</p> <code>list</code> <p>Lists CAS entities with optional filters.</p> <code>update</code> <p>Updates a CAS entity. The updated object must have the same ID as the object you want to update.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CasCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{CasCollection._api_version}/cas\"\n</code></pre>"},{"location":"albert/#albert.albert.CasCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/cas'\n</code></pre>"},{"location":"albert/#albert.albert.CasCollection.cas_exists","title":"cas_exists","text":"<pre><code>cas_exists(\n    *, number: str, exact_match: bool = True\n) -&gt; bool\n</code></pre> <p>Checks if a CAS exists by its number.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The number of the CAS to check.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the number exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the CAS exists, False otherwise.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def cas_exists(self, *, number: str, exact_match: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if a CAS exists by its number.\n\n    Parameters\n    ----------\n    number : str\n        The number of the CAS to check.\n    exact_match : bool, optional\n        Whether to match the number exactly, by default True.\n\n    Returns\n    -------\n    bool\n        True if the CAS exists, False otherwise.\n    \"\"\"\n    cas_list = self.get_by_number(number=number, exact_match=exact_match)\n    return cas_list is not None\n</code></pre>"},{"location":"albert/#albert.albert.CasCollection.create","title":"create","text":"<pre><code>create(*, cas: str | Cas) -&gt; Cas\n</code></pre> <p>Creates a new CAS entity.</p> <p>Parameters:</p> Name Type Description Default <code>cas</code> <code>Union[str, Cas]</code> <p>The CAS number or Cas object to create.</p> required <p>Returns:</p> Type Description <code>Cas</code> <p>The created Cas object.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def create(self, *, cas: str | Cas) -&gt; Cas:\n    \"\"\"\n    Creates a new CAS entity.\n\n    Parameters\n    ----------\n    cas : Union[str, Cas]\n        The CAS number or Cas object to create.\n\n    Returns\n    -------\n    Cas\n        The created Cas object.\n    \"\"\"\n    if isinstance(cas, str):\n        cas = Cas(number=cas)\n    hit = self.get_by_number(number=cas.number, exact_match=True)\n    if hit:\n        return hit\n    else:\n        payload = cas.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n        response = self.session.post(self.base_path, json=payload)\n        cas = Cas(**response.json())\n        return cas\n</code></pre>"},{"location":"albert/#albert.albert.CasCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a CAS by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the CAS to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a CAS by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the CAS to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.CasCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Cas\n</code></pre> <p>Retrieves a CAS by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the CAS to retrieve.</p> required <p>Returns:</p> Type Description <code>Cas</code> <p>The Cas object if found, None otherwise.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Cas:\n    \"\"\"\n    Retrieves a CAS by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the CAS to retrieve.\n\n    Returns\n    -------\n    Cas\n        The Cas object if found, None otherwise.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    cas = Cas(**response.json())\n    return cas\n</code></pre>"},{"location":"albert/#albert.albert.CasCollection.get_by_number","title":"get_by_number","text":"<pre><code>get_by_number(\n    *, number: str, exact_match: bool = True\n) -&gt; Cas | None\n</code></pre> <p>Retrieves a CAS by its number.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The number of the CAS to retrieve.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the number exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[Cas]</code> <p>The Cas object if found, None otherwise.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def get_by_number(self, *, number: str, exact_match: bool = True) -&gt; Cas | None:\n    \"\"\"\n    Retrieves a CAS by its number.\n\n    Parameters\n    ----------\n    number : str\n        The number of the CAS to retrieve.\n    exact_match : bool, optional\n        Whether to match the number exactly, by default True.\n\n    Returns\n    -------\n    Optional[Cas]\n        The Cas object if found, None otherwise.\n    \"\"\"\n    found = self.list(number=number)\n    if exact_match:\n        for f in found:\n            if self._clean_cas_number(f.number) == self._clean_cas_number(number):\n                return f\n    return next(found, None)\n</code></pre>"},{"location":"albert/#albert.albert.CasCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 50,\n    start_key: str | None = None,\n    number: str | None = None,\n    id: str | None = None,\n    order_by: OrderBy = DESCENDING,\n) -&gt; Iterator[Cas]\n</code></pre> <p>Lists CAS entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>The maximum number of CAS entities to return, by default 50.</p> <code>50</code> <code>start_key</code> <code>str | None</code> <p>The primary key of the first item that this operation will evaluate.</p> <code>None</code> <code>number</code> <code>str | None</code> <p>Fetches list of CAS by CAS number.</p> <code>None</code> <code>id</code> <code>str | None</code> <p>Fetches list of CAS using the CAS Albert ID.</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <p>Returns:</p> Type Description <code>Iterator[Cas]</code> <p>An iterator of Cas objects.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 50,\n    start_key: str | None = None,\n    number: str | None = None,\n    id: str | None = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n) -&gt; Iterator[Cas]:\n    \"\"\"\n    Lists CAS entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int | None, optional\n        The maximum number of CAS entities to return, by default 50.\n    start_key : str | None, optional\n        The primary key of the first item that this operation will evaluate.\n    number : str | None, optional\n        Fetches list of CAS by CAS number.\n    id : str | None, optional\n        Fetches list of CAS using the CAS Albert ID.\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING.\n\n    Returns\n    -------\n    Iterator[Cas]\n        An iterator of Cas objects.\n    \"\"\"\n    params = {\n        \"limit\": limit,\n        \"orderBy\": order_by.value,\n        \"startKey\": start_key,\n        \"number\": number,\n        \"albertId\": id,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Cas(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.CasCollection.update","title":"update","text":"<pre><code>update(*, updated_object: Cas) -&gt; Cas\n</code></pre> <p>Updates a CAS entity. The updated object must have the same ID as the object you want to update.</p> <p>Parameters:</p> Name Type Description Default <code>updated_object</code> <code>Cas</code> <p>The Updated Cas object.</p> required <p>Returns:</p> Type Description <code>Cas</code> <p>The updated Cas object as it appears in Albert</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def update(self, *, updated_object: Cas) -&gt; Cas:\n    \"\"\"Updates a CAS entity. The updated object must have the same ID as the object you want to update.\n\n    Parameters\n    ----------\n    updated_object : Cas\n        The Updated Cas object.\n\n    Returns\n    -------\n    Cas\n        The updated Cas object as it appears in Albert\n    \"\"\"\n    # Fetch the current object state from the server or database\n    existing_cas = self.get_by_id(id=updated_object.id)\n\n    # Generate the PATCH payload\n    patch_payload = self._generate_patch_payload(existing=existing_cas, updated=updated_object)\n    url = f\"{self.base_path}/{updated_object.id}\"\n    self.session.patch(url, json=patch_payload.model_dump(mode=\"json\", by_alias=True))\n\n    updated_cas = self.get_by_id(id=updated_object.id)\n    return updated_cas\n</code></pre>"},{"location":"albert/#albert.albert.CompanyCollection","title":"CompanyCollection","text":"<pre><code>CompanyCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>CompanyCollection is a collection class for managing Company entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>company_exists</code> <p>Checks if a company exists by its name.</p> <code>create</code> <p>Creates a new company entity.</p> <code>delete</code> <p>Deletes a company entity.</p> <code>get_by_id</code> <p>Get a company by its ID.</p> <code>get_by_name</code> <p>Retrieves a company by its name.</p> <code>list</code> <p>Lists company entities with optional filters.</p> <code>rename</code> <p>Renames an existing company entity.</p> <code>update</code> <p>Update a Company entity. The id of the company must be provided.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CompanyCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{CompanyCollection._api_version}/companies\"\n</code></pre>"},{"location":"albert/#albert.albert.CompanyCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/companies'\n</code></pre>"},{"location":"albert/#albert.albert.CompanyCollection.company_exists","title":"company_exists","text":"<pre><code>company_exists(\n    *, name: str, exact_match: bool = True\n) -&gt; bool\n</code></pre> <p>Checks if a company exists by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the company to check.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the company exists, False otherwise.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def company_exists(self, *, name: str, exact_match: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if a company exists by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the company to check.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    bool\n        True if the company exists, False otherwise.\n    \"\"\"\n    companies = self.get_by_name(name=name, exact_match=exact_match)\n    return bool(companies)\n</code></pre>"},{"location":"albert/#albert.albert.CompanyCollection.create","title":"create","text":"<pre><code>create(\n    *, company: str | Company, check_if_exists: bool = True\n) -&gt; Company\n</code></pre> <p>Creates a new company entity.</p> <p>Parameters:</p> Name Type Description Default <code>company</code> <code>Union[str, Company]</code> <p>The company name or Company object to create.</p> required <code>check_if_exists</code> <code>bool</code> <p>Whether to check if the company already exists, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Company</code> <p>The created Company object.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def create(self, *, company: str | Company, check_if_exists: bool = True) -&gt; Company:\n    \"\"\"\n    Creates a new company entity.\n\n    Parameters\n    ----------\n    company : Union[str, Company]\n        The company name or Company object to create.\n    check_if_exists : bool, optional\n        Whether to check if the company already exists, by default True.\n\n    Returns\n    -------\n    Company\n        The created Company object.\n    \"\"\"\n    if isinstance(company, str):\n        company = Company(name=company)\n    hit = self.get_by_name(name=company.name, exact_match=True)\n    if check_if_exists and hit:\n        logging.warning(f\"Company {company.name} already exists with id {hit.id}.\")\n        return hit\n\n    payload = company.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    response = self.session.post(self.base_path, json=payload)\n    this_company = Company(**response.json())\n    return this_company\n</code></pre>"},{"location":"albert/#albert.albert.CompanyCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a company entity.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the company to delete.</p> required Source code in <code>src/albert/collections/companies.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Deletes a company entity.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the company to delete.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.CompanyCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Company\n</code></pre> <p>Get a company by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the company to retrieve.</p> required <p>Returns:</p> Type Description <code>Company</code> <p>The Company object.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Company:\n    \"\"\"\n    Get a company by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the company to retrieve.\n\n    Returns\n    -------\n    Company\n        The Company object.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    company = response.json()\n    found_company = Company(**company)\n    return found_company\n</code></pre>"},{"location":"albert/#albert.albert.CompanyCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(\n    *, name: str, exact_match: bool = True\n) -&gt; Company | None\n</code></pre> <p>Retrieves a company by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the company to retrieve.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Company</code> <p>The Company object if found, None otherwise.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def get_by_name(self, *, name: str, exact_match: bool = True) -&gt; Company | None:\n    \"\"\"\n    Retrieves a company by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the company to retrieve.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    Company\n        The Company object if found, None otherwise.\n    \"\"\"\n    found = self.list(name=name, exact_match=exact_match)\n    return next(found, None)\n</code></pre>"},{"location":"albert/#albert.albert.CompanyCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 50,\n    name: str | list[str] = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Company]\n</code></pre> <p>Lists company entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of companies to return, by default 50.</p> <code>50</code> <code>name</code> <code>Union[str, None]</code> <p>The name of the company to filter by, by default None.</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Iterator</code> <p>An iterator of Company objects.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 50,\n    name: str | list[str] = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Company]:\n    \"\"\"\n    Lists company entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of companies to return, by default 50.\n    name : Union[str, None], optional\n        The name of the company to filter by, by default None.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    Iterator\n        An iterator of Company objects.\n    \"\"\"\n    params = {\"limit\": limit, \"dupDetection\": \"false\", \"startKey\": start_key}\n    if name:\n        params[\"name\"] = name if isinstance(name, list) else [name]\n        params[\"exactMatch\"] = str(exact_match).lower()\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Company(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.CompanyCollection.rename","title":"rename","text":"<pre><code>rename(*, old_name: str, new_name: str) -&gt; Company\n</code></pre> <p>Renames an existing company entity.</p> <p>Parameters:</p> Name Type Description Default <code>old_name</code> <code>str</code> <p>The current name of the company.</p> required <code>new_name</code> <code>str</code> <p>The new name of the company.</p> required <p>Returns:</p> Type Description <code>Company</code> <p>The renamed Company object</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def rename(self, *, old_name: str, new_name: str) -&gt; Company:\n    \"\"\"\n    Renames an existing company entity.\n\n    Parameters\n    ----------\n    old_name : str\n        The current name of the company.\n    new_name : str\n        The new name of the company.\n\n    Returns\n    -------\n    Company\n        The renamed Company object\n    \"\"\"\n    company = self.get_by_name(name=old_name, exact_match=True)\n    if not company:\n        msg = f'Company \"{old_name}\" not found.'\n        logger.error(msg)\n        raise AlbertException(msg)\n    company_id = company.id\n    endpoint = f\"{self.base_path}/{company_id}\"\n    payload = {\n        \"data\": [\n            {\n                \"operation\": \"update\",\n                \"attribute\": \"name\",\n                \"oldValue\": old_name,\n                \"newValue\": new_name,\n            }\n        ]\n    }\n    self.session.patch(endpoint, json=payload)\n    updated_company = self.get_by_id(id=company_id)\n    return updated_company\n</code></pre>"},{"location":"albert/#albert.albert.CompanyCollection.update","title":"update","text":"<pre><code>update(*, company: Company) -&gt; Company\n</code></pre> <p>Update a Company entity. The id of the company must be provided.</p> <p>Parameters:</p> Name Type Description Default <code>company</code> <code>Company</code> <p>The updated Company object.</p> required <p>Returns:</p> Type Description <code>Company</code> <p>The updated Company object as registered in Albert.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def update(self, *, company: Company) -&gt; Company:\n    \"\"\"Update a Company entity. The id of the company must be provided.\n\n    Parameters\n    ----------\n    company : Company\n        The updated Company object.\n\n    Returns\n    -------\n    Company\n        The updated Company object as registered in Albert.\n    \"\"\"\n    # Fetch the current object state from the server or database\n    current_object = self.get_by_id(id=company.id)\n\n    # Generate the PATCH payload\n    patch_payload = self._generate_patch_payload(existing=current_object, updated=company)\n    url = f\"{self.base_path}/{company.id}\"\n    self.session.patch(url, json=patch_payload.model_dump(mode=\"json\", by_alias=True))\n    updated_company = self.get_by_id(id=company.id)\n    return updated_company\n</code></pre>"},{"location":"albert/#albert.albert.CustomFieldCollection","title":"CustomFieldCollection","text":"<pre><code>CustomFieldCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>CustomFieldCollection is a collection class for managing CustomField entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new CustomField item.</p> <code>get_by_id</code> <p>Get a CustomField item by its ID.</p> <code>get_by_name</code> <p>Get a CustomField item by its name.</p> <code>list</code> <p>Searches for CustomField items based on the provided parameters.</p> <code>update</code> <p>Update a CustomField item.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CasCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{CustomFieldCollection._api_version}/customfields\"\n</code></pre>"},{"location":"albert/#albert.albert.CustomFieldCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/customfields'\n</code></pre>"},{"location":"albert/#albert.albert.CustomFieldCollection.create","title":"create","text":"<pre><code>create(*, custom_field: CustomField) -&gt; CustomField\n</code></pre> <p>Create a new CustomField item.</p> <p>Parameters:</p> Name Type Description Default <code>custom_field</code> <code>CustomField</code> <p>The CustomField item to create.</p> required <p>Returns:</p> Type Description <code>CustomField</code> <p>The created CustomField item with its ID.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def create(self, *, custom_field: CustomField) -&gt; CustomField:\n    \"\"\"Create a new CustomField item.\n\n    Parameters\n    ----------\n    custom_field : CustomField\n        The CustomField item to create.\n\n    Returns\n    -------\n    CustomField\n        The created CustomField item with its ID.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=custom_field.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return CustomField(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.CustomFieldCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; CustomField\n</code></pre> <p>Get a CustomField item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the CustomField item.</p> required <p>Returns:</p> Type Description <code>CustomField</code> <p>The CustomField item.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; CustomField:\n    \"\"\"Get a CustomField item by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the CustomField item.\n\n    Returns\n    -------\n    CustomField\n        The CustomField item.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return CustomField(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.CustomFieldCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(\n    *, name: str, service: ServiceType | None = None\n) -&gt; CustomField | None\n</code></pre> <p>Get a CustomField item by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the CustomField item.</p> required <code>service</code> <code>ServiceType | None</code> <p>The service the field relates to, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>CustomField | None</code> <p>The CustomField item, or None if not found.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def get_by_name(self, *, name: str, service: ServiceType | None = None) -&gt; CustomField | None:\n    \"\"\"Get a CustomField item by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the CustomField item.\n    service : ServiceType | None, optional\n        The service the field relates to, by default None\n\n    Returns\n    -------\n    CustomField | None\n        The CustomField item, or None if not found.\n    \"\"\"\n    for custom_field in self.list(name=name, service=service):\n        if custom_field.name.lower() == name.lower():\n            return custom_field\n    return None\n</code></pre>"},{"location":"albert/#albert.albert.CustomFieldCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    name: str | None = None,\n    service: ServiceType | None = None,\n    lookup_column: bool | None = None,\n    lookup_row: bool | None = None,\n) -&gt; Iterator[CustomField]\n</code></pre> <p>Searches for CustomField items based on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the field, by default None</p> <code>None</code> <code>service</code> <code>ServiceType | None</code> <p>The related service the field is in, by default None</p> <code>None</code> <code>lookup_column</code> <code>bool | None</code> <p>Whether the field relates to a lookup column, by default None</p> <code>None</code> <code>lookup_row</code> <code>bool | None</code> <p>Whether the field relates to a lookup row, by default None</p> <code>None</code> <p>Yields:</p> Type Description <code>Iterator[CustomField]</code> <p>Returns an iterator of CustomField items matching the search criteria.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def list(\n    self,\n    *,\n    name: str | None = None,\n    service: ServiceType | None = None,\n    lookup_column: bool | None = None,\n    lookup_row: bool | None = None,\n) -&gt; Iterator[CustomField]:\n    \"\"\"Searches for CustomField items based on the provided parameters.\n\n    Parameters\n    ----------\n    name : str | None, optional\n        The name of the field, by default None\n    service : ServiceType | None, optional\n        The related service the field is in, by default None\n    lookup_column : bool | None, optional\n        Whether the field relates to a lookup column, by default None\n    lookup_row : bool | None, optional\n        Whether the field relates to a lookup row, by default None\n\n    Yields\n    ------\n    Iterator[CustomField]\n        Returns an iterator of CustomField items matching the search criteria.\n    \"\"\"\n    params = {\n        \"name\": name,\n        \"service\": service if service else None,\n        \"lookupColumn\": json.dumps(lookup_column) if lookup_column is not None else None,\n        \"lookupRow\": json.dumps(lookup_row) if lookup_row is not None else None,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        params=params,\n        session=self.session,\n        deserialize=lambda items: [CustomField(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.CustomFieldCollection.update","title":"update","text":"<pre><code>update(*, custom_field: CustomField) -&gt; CustomField\n</code></pre> <p>Update a CustomField item.</p> <p>Parameters:</p> Name Type Description Default <code>custom_field</code> <code>CustomField</code> <p>The updated CustomField item. The ID must be set and match the Field you want to update.</p> required <p>Returns:</p> Type Description <code>CustomField</code> <p>The updated CustomField item as registered in Albert.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def update(self, *, custom_field: CustomField) -&gt; CustomField:\n    \"\"\"Update a CustomField item.\n\n    Parameters\n    ----------\n    custom_field : CustomField\n        The updated CustomField item. The ID must be set and match the Field you want to update.\n\n    Returns\n    -------\n    CustomField\n        The updated CustomField item as registered in Albert.\n    \"\"\"\n    # fetch current object state\n    current_object = self.get_by_id(id=custom_field.id)\n\n    # generate the patch payload\n    payload = self._generate_patch_payload(\n        existing=current_object,\n        updated=custom_field,\n        generate_metadata_diff=False,\n        stringify_values=False,\n    )\n\n    for patch in payload.data:\n        if (\n            patch.attribute in (\"hidden\", \"search\", \"lkpColumn\", \"lkpRow\")\n            and patch.operation == \"add\"\n        ):\n            patch.operation = \"update\"\n            patch.old_value = False\n        if (\n            patch.attribute in (\"entityCategory\")\n            and patch.operation == \"add\"\n            and isinstance(patch.new_value, list)\n        ):\n            patch.new_value = patch.new_value[0]\n\n    # run patch\n    url = f\"{self.base_path}/{custom_field.id}\"\n    self.session.patch(url, json=payload.model_dump(mode=\"json\", by_alias=True))\n    updated_ctf = self.get_by_id(id=custom_field.id)\n    return updated_ctf\n</code></pre>"},{"location":"albert/#albert.albert.CustomTemplatesCollection","title":"CustomTemplatesCollection","text":"<pre><code>CustomTemplatesCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>CustomTemplatesCollection is a collection class for managing CustomTemplate entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>get_by_id</code> <p>Get a Custom Template by ID</p> <code>list</code> <p>Searches for custom templates matching the provided criteria.</p> Source code in <code>src/albert/collections/custom_templates.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CustomTemplatesCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{CustomTemplatesCollection._api_version}/customtemplates\"\n</code></pre>"},{"location":"albert/#albert.albert.CustomTemplatesCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/customtemplates'\n</code></pre>"},{"location":"albert/#albert.albert.CustomTemplatesCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id) -&gt; CustomTemplate\n</code></pre> <p>Get a Custom Template by ID</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>id of the custom template</p> required <p>Returns:</p> Type Description <code>CustomTemplate</code> <p>The CutomTemplate with the provided ID (or None if not found)</p> Source code in <code>src/albert/collections/custom_templates.py</code> <pre><code>def get_by_id(self, *, id) -&gt; CustomTemplate:\n    \"\"\"Get a Custom Template by ID\n\n    Parameters\n    ----------\n    id : str\n        id of the custom template\n\n    Returns\n    -------\n    CustomTemplate\n        The CutomTemplate with the provided ID (or None if not found)\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return CustomTemplate(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.CustomTemplatesCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    text: str | None = None,\n    limit: int = 50,\n    offset: int = 0,\n) -&gt; Iterator[CustomTemplate]\n</code></pre> <p>Searches for custom templates matching the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>The text to search for, by default None</p> <code>None</code> <p>Yields:</p> Type Description <code>Iterator[CustomTemplate]</code> <p>An iterator of CustomTemplate items matching the search criteria.</p> Source code in <code>src/albert/collections/custom_templates.py</code> <pre><code>def list(\n    self,\n    *,\n    text: str | None = None,\n    limit: int = 50,\n    offset: int = 0,\n) -&gt; Iterator[CustomTemplate]:\n    \"\"\"Searches for custom templates matching the provided criteria.\n\n    Parameters\n    ----------\n    text : str | None, optional\n        The text to search for, by default None\n\n\n    Yields\n    ------\n    Iterator[CustomTemplate]\n        An iterator of CustomTemplate items matching the search criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[CustomTemplate]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching custom template {id}: {e}\")\n\n    params = {\"limit\": limit, \"offset\": offset, \"text\": text}\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.DataColumnCollection","title":"DataColumnCollection","text":"<pre><code>DataColumnCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>DataColumnCollection is a collection class for managing DataColumn entities in the Albert platform.</p> <p>Methods:</p> Name Description <code>create</code> <p>Create a new data column entity.</p> <code>delete</code> <p>Delete a data column entity.</p> <code>get_by_id</code> <p>Get a data column by its ID.</p> <code>get_by_name</code> <p>Get a data column by its name.</p> <code>list</code> <p>Lists data column entities with optional filters.</p> <code>update</code> <p>Update a data column entity.</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initialize the DataColumnCollection with the provided session.\"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{DataColumnCollection._api_version}/datacolumns\"\n</code></pre>"},{"location":"albert/#albert.albert.DataColumnCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/datacolumns'\n</code></pre>"},{"location":"albert/#albert.albert.DataColumnCollection.create","title":"create","text":"<pre><code>create(*, data_column: DataColumn) -&gt; DataColumn\n</code></pre> <p>Create a new data column entity.</p> <p>Parameters:</p> Name Type Description Default <code>data_column</code> <code>DataColumn</code> <p>The data column object to create.</p> required <p>Returns:</p> Type Description <code>DataColumn</code> <p>The created data column object.</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def create(self, *, data_column: DataColumn) -&gt; DataColumn:\n    \"\"\"\n    Create a new data column entity.\n\n    Parameters\n    ----------\n    data_column : DataColumn\n        The data column object to create.\n\n    Returns\n    -------\n    DataColumn\n        The created data column object.\n    \"\"\"\n    payload = [data_column.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")]\n    response = self.session.post(self.base_path, json=payload)\n\n    return DataColumn(**response.json()[0])\n</code></pre>"},{"location":"albert/#albert.albert.DataColumnCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a data column entity.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the data column object to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Delete a data column entity.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the data column object to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"albert/#albert.albert.DataColumnCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id) -&gt; DataColumn\n</code></pre> <p>Get a data column by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the data column to get.</p> required <p>Returns:</p> Type Description <code>DataColumn | None</code> <p>The data column object on match or None</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def get_by_id(self, *, id) -&gt; DataColumn:\n    \"\"\"\n    Get a data column by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the data column to get.\n\n    Returns\n    -------\n    DataColumn | None\n        The data column object on match or None\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    dc = DataColumn(**response.json())\n    return dc\n</code></pre>"},{"location":"albert/#albert.albert.DataColumnCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(*, name) -&gt; DataColumn | None\n</code></pre> <p>Get a data column by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data column to get.</p> required <p>Returns:</p> Type Description <code>DataColumn | None</code> <p>The data column object on match or None</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def get_by_name(self, *, name) -&gt; DataColumn | None:\n    \"\"\"\n    Get a data column by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the data column to get.\n\n    Returns\n    -------\n    DataColumn | None\n        The data column object on match or None\n    \"\"\"\n    for dc in self.list(name=name):\n        if dc.name.lower() == name.lower():\n            return dc\n    return None\n</code></pre>"},{"location":"albert/#albert.albert.DataColumnCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    order_by: OrderBy = DESCENDING,\n    ids: str | list[str] | None = None,\n    name: str | list[str] | None = None,\n    exact_match: bool | None = None,\n    default: bool | None = None,\n    start_key: str | None = None,\n    limit: int = 100,\n) -&gt; Iterator[DataColumn]\n</code></pre> <p>Lists data column entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <code>ids</code> <code>str | list[str] | None</code> <p>Data column IDs to filter the search by, default None.</p> <code>None</code> <code>name</code> <code>Union[str, None]</code> <p>The name of the tag to filter by, by default None.</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>None</code> <code>default</code> <code>bool</code> <p>Whether to return only default columns, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[DataColumn]</code> <p>An iterator of DataColumns matching the provided criteria.</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def list(\n    self,\n    *,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    ids: str | list[str] | None = None,\n    name: str | list[str] | None = None,\n    exact_match: bool | None = None,\n    default: bool | None = None,\n    start_key: str | None = None,\n    limit: int = 100,\n) -&gt; Iterator[DataColumn]:\n    \"\"\"\n    Lists data column entities with optional filters.\n\n    Parameters\n    ----------\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING.\n    ids: str | list[str] | None, optional\n        Data column IDs to filter the search by, default None.\n    name : Union[str, None], optional\n        The name of the tag to filter by, by default None.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n    default : bool, optional\n        Whether to return only default columns, by default None.\n\n    Returns\n    -------\n    Iterator[DataColumn]\n        An iterator of DataColumns matching the provided criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[DataColumn]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching Data Column '{id}': {e}\")\n\n    params = {\n        \"limit\": limit,\n        \"orderBy\": order_by.value,\n        \"startKey\": start_key,\n        \"name\": [name] if isinstance(name, str) else name,\n        \"exactMatch\": json.dumps(exact_match) if exact_match is not None else None,\n        \"default\": json.dumps(default) if default is not None else None,\n        \"dataColumns\": [ids] if isinstance(ids, str) else ids,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.DataColumnCollection.update","title":"update","text":"<pre><code>update(*, data_column: DataColumn) -&gt; DataColumn\n</code></pre> <p>Update a data column entity.</p> <p>Parameters:</p> Name Type Description Default <code>data_column</code> <code>DataColumn</code> <p>The updated data column object. The ID must be set and match an existing data column.</p> required <p>Returns:</p> Type Description <code>DataColumn</code> <p>The updated data column object as registered in Albert.</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def update(self, *, data_column: DataColumn) -&gt; DataColumn:\n    \"\"\"Update a data column entity.\n\n    Parameters\n    ----------\n    data_column : DataColumn\n        The updated data column object. The ID must be set and match an existing data column.\n\n    Returns\n    -------\n    DataColumn\n        The updated data column object as registered in Albert.\n    \"\"\"\n    existing = self.get_by_id(id=data_column.id)\n    payload = self._generate_patch_payload(\n        existing=existing,\n        updated=data_column,\n    )\n    payload_dump = payload.model_dump(mode=\"json\", by_alias=True)\n    for i, change in enumerate(payload_dump[\"data\"]):\n        if not self._is_metadata_item_list(\n            existing_object=existing,\n            updated_object=data_column,\n            metadata_field=change[\"attribute\"],\n        ):\n            change[\"operation\"] = \"update\"\n            if \"newValue\" in change and change[\"newValue\"] is None:\n                del change[\"newValue\"]\n            if \"oldValue\" in change and change[\"oldValue\"] is None:\n                del change[\"oldValue\"]\n            payload_dump[\"data\"][i] = change\n    if len(payload_dump[\"data\"]) == 0:\n        return data_column\n    for e in payload_dump[\"data\"]:\n        self.session.patch(\n            f\"{self.base_path}/{data_column.id}\",\n            json={\"data\": [e]},\n        )\n    return self.get_by_id(id=data_column.id)\n</code></pre>"},{"location":"albert/#albert.albert.DataTemplateCollection","title":"DataTemplateCollection","text":"<pre><code>DataTemplateCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>DataTemplateCollection is a collection class for managing DataTemplate entities in the Albert platform.</p> <p>Methods:</p> Name Description <code>add_data_columns</code> <p>Adds data columns to a data template.</p> <code>create</code> <p>Creates a new data template.</p> <code>delete</code> <p>Deletes a data template by its ID.</p> <code>get_by_id</code> <p>Get a data template by its ID.</p> <code>get_by_ids</code> <p>Get a list of data templates by their IDs.</p> <code>get_by_name</code> <p>Get a data template by its name.</p> <code>list</code> <p>Lists data template entities with optional filters.</p> <code>update</code> <p>Updates a data template.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{DataTemplateCollection._api_version}/datatemplates\"\n</code></pre>"},{"location":"albert/#albert.albert.DataTemplateCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/datatemplates'\n</code></pre>"},{"location":"albert/#albert.albert.DataTemplateCollection.add_data_columns","title":"add_data_columns","text":"<pre><code>add_data_columns(\n    *,\n    data_template_id: str,\n    data_columns: list[DataColumnValue],\n) -&gt; DataTemplate\n</code></pre> <p>Adds data columns to a data template.</p> <p>Parameters:</p> Name Type Description Default <code>data_template_id</code> <code>str</code> <p>The ID of the data template to add the columns to.</p> required <code>data_columns</code> <code>list[DataColumnValue]</code> <p>The list of DataColumnValue objects to add to the data template.</p> required <p>Returns:</p> Type Description <code>DataTemplate</code> <p>The updated DataTemplate object.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def add_data_columns(\n    self, *, data_template_id: str, data_columns: list[DataColumnValue]\n) -&gt; DataTemplate:\n    \"\"\"Adds data columns to a data template.\n\n    Parameters\n    ----------\n    data_template_id : str\n        The ID of the data template to add the columns to.\n    data_columns : list[DataColumnValue]\n        The list of DataColumnValue objects to add to the data template.\n\n    Returns\n    -------\n    DataTemplate\n        The updated DataTemplate object.\n    \"\"\"\n    payload = {\n        \"DataColumns\": [\n            x.model_dump(mode=\"json\", by_alias=True, exclude_none=True) for x in data_columns\n        ]\n    }\n    self.session.put(\n        f\"{self.base_path}/{data_template_id}/datacolumns\",\n        json=payload,\n    )\n    return self.get_by_id(id=data_template_id)\n</code></pre>"},{"location":"albert/#albert.albert.DataTemplateCollection.create","title":"create","text":"<pre><code>create(*, data_template: DataTemplate) -&gt; DataTemplate\n</code></pre> <p>Creates a new data template.</p> <p>Parameters:</p> Name Type Description Default <code>data_template</code> <code>DataTemplate</code> <p>The DataTemplate object to create.</p> required <p>Returns:</p> Type Description <code>DataTemplate</code> <p>The registered DataTemplate object with an ID.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def create(self, *, data_template: DataTemplate) -&gt; DataTemplate:\n    \"\"\"Creates a new data template.\n\n    Parameters\n    ----------\n    data_template : DataTemplate\n        The DataTemplate object to create.\n\n    Returns\n    -------\n    DataTemplate\n        The registered DataTemplate object with an ID.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=data_template.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return DataTemplate(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.DataTemplateCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a data template by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the data template to delete.</p> required Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Deletes a data template by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the data template to delete.\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"albert/#albert.albert.DataTemplateCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: DataTemplateId) -&gt; DataTemplate\n</code></pre> <p>Get a data template by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>DataTemplateId</code> <p>The ID of the data template to get.</p> required <p>Returns:</p> Type Description <code>DataTemplate</code> <p>The data template object on match or None</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def get_by_id(self, *, id: DataTemplateId) -&gt; DataTemplate:\n    \"\"\"Get a data template by its ID.\n\n    Parameters\n    ----------\n    id : DataTemplateId\n        The ID of the data template to get.\n\n    Returns\n    -------\n    DataTemplate\n        The data template object on match or None\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return DataTemplate(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.DataTemplateCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(\n    *, ids: list[DataTemplateId]\n) -&gt; list[DataTemplate]\n</code></pre> <p>Get a list of data templates by their IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[DataTemplateId]</code> <p>The list of DataTemplate IDs to get.</p> required <p>Returns:</p> Type Description <code>list[DataTemplate]</code> <p>A list of DataTemplate objects with the provided IDs.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def get_by_ids(self, *, ids: list[DataTemplateId]) -&gt; list[DataTemplate]:\n    \"\"\"Get a list of data templates by their IDs.\n\n    Parameters\n    ----------\n    ids : list[DataTemplateId]\n        The list of DataTemplate IDs to get.\n\n    Returns\n    -------\n    list[DataTemplate]\n        A list of DataTemplate objects with the provided IDs.\n    \"\"\"\n    url = f\"{self.base_path}/ids\"\n    batches = [ids[i : i + 250] for i in range(0, len(ids), 250)]\n    return [\n        DataTemplate(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()[\"Items\"]\n    ]\n</code></pre>"},{"location":"albert/#albert.albert.DataTemplateCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(*, name: str) -&gt; DataTemplate | None\n</code></pre> <p>Get a data template by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data template to get.</p> required <p>Returns:</p> Type Description <code>DataTemplate | None</code> <p>The matching data template object or None if not found.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def get_by_name(self, *, name: str) -&gt; DataTemplate | None:\n    \"\"\"Get a data template by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the data template to get.\n\n    Returns\n    -------\n    DataTemplate | None\n        The matching data template object or None if not found.\n    \"\"\"\n    hits = list(self.list(name=name))\n    for h in hits:\n        if h.name.lower() == name.lower():\n            return h\n    return None\n</code></pre>"},{"location":"albert/#albert.albert.DataTemplateCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    name: str | None = None,\n    user_id: str | None = None,\n    order_by: OrderBy = DESCENDING,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; Iterator[DataTemplate]\n</code></pre> <p>Lists data template entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Union[str, None]</code> <p>The name of the data template to filter by, by default None.</p> <code>None</code> <code>user_id</code> <code>str</code> <p>user_id to filter by, by default None.</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <p>Returns:</p> Type Description <code>Iterator[DataTemplate]</code> <p>An iterator of DataTemplate objects matching the provided criteria.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def list(\n    self,\n    *,\n    name: str | None = None,\n    user_id: str | None = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; Iterator[DataTemplate]:\n    \"\"\"\n    Lists data template entities with optional filters.\n\n    Parameters\n    ----------\n    name : Union[str, None], optional\n        The name of the data template to filter by, by default None.\n    user_id : str, optional\n        user_id to filter by, by default None.\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING.\n\n    Returns\n    -------\n    Iterator[DataTemplate]\n        An iterator of DataTemplate objects matching the provided criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[DataTemplate]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching parameter group {id}: {e}\")\n        # get by ids is not currently returning metadata correctly, so temp fixing this\n        # return self.get_by_ids(ids=[x[\"albertId\"] for x in items])\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"order\": OrderBy(order_by).value if order_by else None,\n        \"text\": name,\n        \"userId\": user_id,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        deserialize=deserialize,\n        params=params,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.DataTemplateCollection.update","title":"update","text":"<pre><code>update(*, data_template: DataTemplate) -&gt; DataTemplate\n</code></pre> <p>Updates a data template.</p> <p>Parameters:</p> Name Type Description Default <code>data_template</code> <code>DataTemplate</code> <p>The DataTemplate object to update. The ID must be set and matching the ID of the DataTemplate to update.</p> required <p>Returns:</p> Type Description <code>DataTemplate</code> <p>The Updated DataTemplate object.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def update(self, *, data_template: DataTemplate) -&gt; DataTemplate:\n    \"\"\"Updates a data template.\n\n    Parameters\n    ----------\n    data_template : DataTemplate\n        The DataTemplate object to update. The ID must be set and matching the ID of the DataTemplate to update.\n\n    Returns\n    -------\n    DataTemplate\n        The Updated DataTemplate object.\n    \"\"\"\n    existing = self.get_by_id(id=data_template.id)\n    base_payload = self._generate_patch_payload(existing=existing, updated=data_template)\n    payload = base_payload.model_dump(mode=\"json\", by_alias=True)\n    _updatable_attributes_special = {\"tags\", \"data_column_values\"}\n    for attribute in _updatable_attributes_special:\n        old_value = getattr(existing, attribute)\n        new_value = getattr(data_template, attribute)\n        if attribute == \"tags\":\n            if (old_value is None or old_value == []) and new_value is not None:\n                for t in new_value:\n                    payload[\"data\"].append(\n                        {\n                            \"operation\": \"add\",\n                            \"attribute\": \"tagId\",\n                            \"newValue\": t.id,  # This will be a CasAmount Object,\n                            \"entityId\": t.id,\n                        }\n                    )\n            else:\n                if old_value is None:  # pragma: no cover\n                    old_value = []\n                if new_value is None:  # pragma: no cover\n                    new_value = []\n                old_set = {obj.id for obj in old_value}\n                new_set = {obj.id for obj in new_value}\n\n                # Find what's in set 1 but not in set 2\n                to_del = old_set - new_set\n\n                # Find what's in set 2 but not in set 1\n                to_add = new_set - old_set\n\n                for id in to_add:\n                    payload[\"data\"].append(\n                        {\n                            \"operation\": \"add\",\n                            \"attribute\": \"tagId\",\n                            \"newValue\": id,\n                        }\n                    )\n                for id in to_del:\n                    payload[\"data\"].append(\n                        {\n                            \"operation\": \"delete\",\n                            \"attribute\": \"tagId\",\n                            \"oldValue\": id,\n                        }\n                    )\n        elif attribute == \"data_column_values\":\n            # Do the update by column\n            to_remove = set([x.data_column_id for x in old_value]) - set(\n                [x.data_column_id for x in new_value]\n            )\n            to_add = set([x.data_column_id for x in new_value]) - set(\n                [x.data_column_id for x in old_value]\n            )\n            to_update = set([x.data_column_id for x in new_value]) &amp; set(\n                [x.data_column_id for x in old_value]\n            )\n            if len(to_remove) &gt; 0:\n                logger.error(\n                    \"Data Columns cannot be Removed from a Data Template. Set to hidden instead and retry.\"\n                )\n            if len(to_add) &gt; 0:\n                new_dcs = [x for x in new_value if x.data_column_id in to_add]\n                self.add_data_columns(data_template_id=data_template.id, data_columns=new_dcs)\n            for dc_id in to_update:\n                actions = []\n                old_dc_val = next(x for x in old_value if x.data_column_id == dc_id)\n                new_dc_val = next(x for x in new_value if x.data_column_id == dc_id)\n                # do hidden last because it can change the column sequence.\n                if old_dc_val.unit != new_dc_val.unit:\n                    payload[\"data\"].append(\n                        {\n                            \"operation\": \"update\",\n                            \"attribute\": \"unit\",\n                            \"newValue\": new_dc_val.unit.id,\n                            \"oldValue\": old_dc_val.unit.id,\n                            \"colId\": old_dc_val.column_sequence,\n                        }\n                    )\n                if old_dc_val.hidden != new_dc_val.hidden:\n                    actions.append(\n                        {\n                            \"operation\": \"update\",\n                            \"attribute\": \"hidden\",\n                            \"newValue\": new_dc_val.hidden,\n                            \"oldValue\": old_dc_val.hidden,\n                        }\n                    )\n                if len(actions) &gt; 0:\n                    payload[\"data\"].append(\n                        {\n                            \"actions\": actions,\n                            \"attribute\": \"datacolumn\",\n                            \"colId\": old_dc_val.column_sequence,\n                        }\n                    )\n    if len(payload[\"data\"]) &gt; 0:\n        url = f\"{self.base_path}/{existing.id}\"\n        self.session.patch(url, json=payload)\n    return self.get_by_id(id=existing.id)  # always do this in case columns were added\n</code></pre>"},{"location":"albert/#albert.albert.FileCollection","title":"FileCollection","text":"<pre><code>FileCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>FileCollection is a collection class for managing File entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>get_by_name</code> <p>Gets a file by name and namespace.</p> <code>get_signed_download_url</code> <p>Get a signed download URL for a file.</p> <code>get_signed_upload_url</code> <p>Get a signed upload URL for a file.</p> <code>sign_and_upload_file</code> <p>Sign and upload a file to Albert.</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initialize the FileCllection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{FileCollection._api_version}/files\"\n</code></pre>"},{"location":"albert/#albert.albert.FileCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/files'\n</code></pre>"},{"location":"albert/#albert.albert.FileCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(\n    *,\n    name: str,\n    namespace: FileNamespace,\n    generic: bool = False,\n) -&gt; FileInfo\n</code></pre> <p>Gets a file by name and namespace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The Name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>generic</code> <code>bool</code> <p>description, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>FileInfo</code> <p>The file information related to the matching file.</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def get_by_name(\n    self,\n    *,\n    name: str,\n    namespace: FileNamespace,\n    generic: bool = False,\n) -&gt; FileInfo:\n    \"\"\"Gets a file by name and namespace.\n\n    Parameters\n    ----------\n    name : str\n        The Name of the file\n    namespace : FileNamespace\n        The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    generic : bool, optional\n        _description_, by default False\n\n    Returns\n    -------\n    FileInfo\n        The file information related to the matching file.\n    \"\"\"\n    params = {\n        \"name\": name,\n        \"namespace\": namespace,\n        \"generic\": json.dumps(generic),\n    }\n    response = self.session.get(f\"{self.base_path}/info\", params=params)\n    return FileInfo(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.FileCollection.get_signed_download_url","title":"get_signed_download_url","text":"<pre><code>get_signed_download_url(\n    *,\n    name: str,\n    namespace: FileNamespace,\n    version_id: str | None = None,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str\n</code></pre> <p>Get a signed download URL for a file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The Name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>version_id</code> <code>str | None</code> <p>The version of the file, by default None</p> <code>None</code> <code>category</code> <code>FileCategory | None</code> <p>The file category (E.g., SDS, OTHER), by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>description</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def get_signed_download_url(\n    self,\n    *,\n    name: str,\n    namespace: FileNamespace,\n    version_id: str | None = None,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str:\n    \"\"\"Get a signed download URL for a file.\n\n    Parameters\n    ----------\n    name : str\n        The Name of the file\n    namespace : FileNamespace\n        The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    version_id : str | None, optional\n        The version of the file, by default None\n    category : FileCategory | None, optional\n        The file category (E.g., SDS, OTHER), by default None\n\n    Returns\n    -------\n    str\n        _description_\n    \"\"\"\n    params = {\n        \"name\": name,\n        \"namespace\": namespace,\n        \"versionId\": version_id,\n        \"generic\": json.dumps(generic),\n        \"category\": category,\n    }\n    response = self.session.get(\n        f\"{self.base_path}/sign\",\n        params={k: v for k, v in params.items() if v is not None},\n    )\n    return response.json()[\"URL\"]\n</code></pre>"},{"location":"albert/#albert.albert.FileCollection.get_signed_upload_url","title":"get_signed_upload_url","text":"<pre><code>get_signed_upload_url(\n    *,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str\n</code></pre> <p>Get a signed upload URL for a file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The Name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>content_type</code> <code>str</code> <p>The content type of the file</p> required <code>category</code> <code>FileCategory | None</code> <p>The File category (E.g., SDS, OTHER), by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>description</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def get_signed_upload_url(\n    self,\n    *,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str:\n    \"\"\"Get a signed upload URL for a file.\n\n    Parameters\n    ----------\n    name : str\n        The Name of the file\n    namespace : FileNamespace\n        The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    content_type : str\n        The content type of the file\n    category : FileCategory | None, optional\n        The File category (E.g., SDS, OTHER), by default None\n\n    Returns\n    -------\n    str\n        _description_\n    \"\"\"\n    params = {\"generic\": json.dumps(generic)}\n\n    post_body = SignURLPOST(\n        files=[\n            SignURLPOSTFile(\n                name=name,\n                namespace=namespace,\n                content_type=content_type,\n                category=category,\n            )\n        ]\n    )\n\n    response = self.session.post(\n        f\"{self.base_path}/sign\",\n        json=post_body.model_dump(by_alias=True, exclude_unset=True, mode=\"json\"),\n        params=params,\n    )\n    return response.json()[0][\"URL\"]\n</code></pre>"},{"location":"albert/#albert.albert.FileCollection.sign_and_upload_file","title":"sign_and_upload_file","text":"<pre><code>sign_and_upload_file(\n    data: IO,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; None\n</code></pre> <p>Sign and upload a file to Albert.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>IO</code> <p>The file data</p> required <code>name</code> <code>str</code> <p>The name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The File Namespace (e.g., AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>content_type</code> <code>str</code> <p>The content type of the file</p> required <code>category</code> <code>FileCategory | None</code> <p>The category of the file (E.g., SDS, OTHER), by default None</p> <code>None</code> Source code in <code>src/albert/collections/files.py</code> <pre><code>def sign_and_upload_file(\n    self,\n    data: IO,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; None:\n    \"\"\"Sign and upload a file to Albert.\n\n    Parameters\n    ----------\n    data : IO\n        The file data\n    name : str\n        The name of the file\n    namespace : FileNamespace\n        The File Namespace (e.g., AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    content_type : str\n        The content type of the file\n    category : FileCategory | None, optional\n        The category of the file (E.g., SDS, OTHER), by default None\n    \"\"\"\n    upload_url = self.get_signed_upload_url(\n        name=name,\n        namespace=namespace,\n        content_type=content_type,\n        generic=generic,\n        category=category,\n    )\n    requests.put(upload_url, data=data, headers={\"Content-Type\": content_type})\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection","title":"InventoryCollection","text":"<pre><code>InventoryCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>InventoryCollection is a collection class for managing Inventory Item entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Albert</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>add_specs</code> <p>Add inventory specs to the inventory item.</p> <code>create</code> <p>Create a new inventory item.</p> <code>delete</code> <p>Delete an inventory item by its ID.</p> <code>get_all_facets</code> <p>Get available facets for inventory items based on the provided filters.</p> <code>get_by_id</code> <p>Retrieve an inventory item by its ID.</p> <code>get_by_ids</code> <p>Retrieve an set of inventory items by their IDs.</p> <code>get_facet_by_name</code> <p>Returns a specific facet by its name with all the filters applied to the search.</p> <code>get_match_or_none</code> <p>Get a matching inventory item or return None if not found.</p> <code>get_specs</code> <p>Get the specs for a list of inventory items.</p> <code>inventory_exists</code> <p>Check if an inventory item exists.</p> <code>list</code> <p>List inventory items with optional filters.</p> <code>merge</code> <p>Merge one or multiple child inventory into a parent inventory item.</p> <code>search</code> <p>Get a list of inventory items that match the search criteria and</p> <code>update</code> <p>Update an inventory item.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    InventoryCollection is a collection class for managing inventory items.\n\n    Parameters\n    ----------\n    session : Albert\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{InventoryCollection._api_version}/inventories\"\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/inventories'\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.add_specs","title":"add_specs","text":"<pre><code>add_specs(\n    *,\n    inventory_id: InventoryId,\n    specs: InventorySpec | list[InventorySpec],\n) -&gt; InventorySpecList\n</code></pre> <p>Add inventory specs to the inventory item.</p> <p>An <code>InventorySpec</code> is a property that was not directly measured via a task, but is a generic property of that inentory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The Albert ID of the inventory item to add the specs to</p> required <code>specs</code> <code>list[InventorySpec]</code> <p>List of InventorySpec objects to add to the inventory item, which described the value and, optionally, the conditions associated with the value (via workflow).</p> required <p>Returns:</p> Type Description <code>InventorySpecList</code> <p>The list of InventorySpecs attached to the InventoryItem.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef add_specs(\n    self,\n    *,\n    inventory_id: InventoryId,\n    specs: InventorySpec | list[InventorySpec],\n) -&gt; InventorySpecList:\n    \"\"\"Add inventory specs to the inventory item.\n\n    An `InventorySpec` is a property that was not directly measured via a task,\n    but is a generic property of that inentory item.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The Albert ID of the inventory item to add the specs to\n    specs : list[InventorySpec]\n        List of InventorySpec objects to add to the inventory item,\n        which described the value and, optionally,\n        the conditions associated with the value (via workflow).\n\n    Returns\n    -------\n    InventorySpecList\n        The list of InventorySpecs attached to the InventoryItem.\n    \"\"\"\n    if isinstance(specs, InventorySpec):\n        specs = [specs]\n    response = self.session.put(\n        url=f\"{self.base_path}/{inventory_id}/specs\",\n        json=[x.model_dump(exclude_unset=True, by_alias=True, mode=\"json\") for x in specs],\n    )\n    return InventorySpecList(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.create","title":"create","text":"<pre><code>create(\n    *,\n    inventory_item: InventoryItem,\n    avoid_duplicates: bool = True,\n) -&gt; InventoryItem\n</code></pre> <p>Create a new inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_item</code> <code>InventoryItem</code> <p>The inventory item to create.</p> required <code>avoid_duplicates</code> <code>bool</code> <p>Whether to avoid creating duplicate items (default is True).</p> <code>True</code> <p>Returns:</p> Type Description <code>InventoryItem</code> <p>The created inventory item.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def create(\n    self,\n    *,\n    inventory_item: InventoryItem,\n    avoid_duplicates: bool = True,\n) -&gt; InventoryItem:\n    \"\"\"\n    Create a new inventory item.\n\n    Parameters\n    ----------\n    inventory_item : InventoryItem\n        The inventory item to create.\n    avoid_duplicates : bool, optional\n        Whether to avoid creating duplicate items (default is True).\n\n    Returns\n    -------\n    InventoryItem\n        The created inventory item.\n    \"\"\"\n    category = (\n        inventory_item.category\n        if isinstance(inventory_item.category, str)\n        else inventory_item.category.value\n    )\n    if category == InventoryCategory.FORMULAS.value:\n        # This will need to interact with worksheets\n        raise NotImplementedError(\"Registrations of formulas not yet implemented\")\n    tag_collection = TagCollection(session=self.session)\n    if inventory_item.tags is not None and inventory_item.tags != []:\n        all_tags = [\n            tag_collection.create(tag=t) if t.id is None else t for t in inventory_item.tags\n        ]\n        inventory_item.tags = all_tags\n    if inventory_item.company and inventory_item.company.id is None:\n        company_collection = CompanyCollection(session=self.session)\n        inventory_item.company = company_collection.create(company=inventory_item.company)\n    # Check to see if there is a match on name + Company already\n    if avoid_duplicates:\n        existing = self.get_match_or_none(inventory_item=inventory_item)\n        if isinstance(existing, InventoryItem):\n            logging.warning(\n                f\"Inventory item already exists with name {existing.name} and company {existing.company.name}, returning existing item.\"\n            )\n            return existing\n    response = self.session.post(\n        self.base_path,\n        json=inventory_item.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return InventoryItem(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.delete","title":"delete","text":"<pre><code>delete(*, id: InventoryId) -&gt; None\n</code></pre> <p>Delete an inventory item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>InventoryId</code> <p>The ID of the inventory item.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef delete(self, *, id: InventoryId) -&gt; None:\n    \"\"\"\n    Delete an inventory item by its ID.\n\n    Parameters\n    ----------\n    id : InventoryId\n        The ID of the inventory item.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.get_all_facets","title":"get_all_facets","text":"<pre><code>get_all_facets(\n    *,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory]\n    | InventoryCategory\n    | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation]\n    | StorageLocation\n    | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; list[FacetItem]\n</code></pre> <p>Get available facets for inventory items based on the provided filters.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef get_all_facets(\n    self,\n    *,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory] | InventoryCategory | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation] | StorageLocation | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; list[FacetItem]:\n    \"\"\"\n    Get available facets for inventory items based on the provided filters.\n    \"\"\"\n\n    params = self._prepare_parameters(\n        limit=1,\n        text=text,\n        cas=cas,\n        category=category,\n        company=company,\n        location=location,\n        storage_location=storage_location,\n        project_id=project_id,\n        sheet_id=sheet_id,\n        created_by=created_by,\n        lot_owner=lot_owner,\n        tags=tags,\n    )\n    response = self.session.get(\n        url=f\"{self.base_path}/llmsearch\"\n        if match_all_conditions\n        else f\"{self.base_path}/search\",\n        params=params,\n    )\n    return [FacetItem.model_validate(x) for x in response.json()[\"Facets\"]]\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: InventoryId) -&gt; InventoryItem\n</code></pre> <p>Retrieve an inventory item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>InventoryId</code> <p>The ID of the inventory item.</p> required <p>Returns:</p> Type Description <code>InventoryItem</code> <p>The retrieved inventory item.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef get_by_id(self, *, id: InventoryId) -&gt; InventoryItem:\n    \"\"\"\n    Retrieve an inventory item by its ID.\n\n    Parameters\n    ----------\n    id : InventoryId\n        The ID of the inventory item.\n\n    Returns\n    -------\n    InventoryItem\n        The retrieved inventory item.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return InventoryItem(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(\n    *, ids: list[InventoryId]\n) -&gt; list[InventoryItem]\n</code></pre> <p>Retrieve an set of inventory items by their IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[InventoryId]</code> <p>The list of IDs of the inventory items.</p> required <p>Returns:</p> Type Description <code>list[InventoryItem]</code> <p>The retrieved inventory items.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef get_by_ids(self, *, ids: list[InventoryId]) -&gt; list[InventoryItem]:\n    \"\"\"\n    Retrieve an set of inventory items by their IDs.\n\n    Parameters\n    ----------\n    ids : list[InventoryId]\n        The list of IDs of the inventory items.\n\n    Returns\n    -------\n    list[InventoryItem]\n        The retrieved inventory items.\n    \"\"\"\n    url = f\"{self.base_path}/ids\"\n    batches = [ids[i : i + 250] for i in range(0, len(ids), 250)]\n    return [\n        InventoryItem(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()[\"Items\"]\n    ]\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.get_facet_by_name","title":"get_facet_by_name","text":"<pre><code>get_facet_by_name(\n    name: str | list[str],\n    *,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory]\n    | InventoryCategory\n    | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation]\n    | StorageLocation\n    | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; list[FacetItem]\n</code></pre> <p>Returns a specific facet by its name with all the filters applied to the search. This can be used for example to fetch all remaining tags as part of an iterative refinement of a search.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef get_facet_by_name(\n    self,\n    name: str | list[str],\n    *,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory] | InventoryCategory | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation] | StorageLocation | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; list[FacetItem]:\n    \"\"\"\n    Returns a specific facet by its name with all the filters applied to the search.\n    This can be used for example to fetch all remaining tags as part of an iterative\n    refinement of a search.\n    \"\"\"\n    if isinstance(name, str):\n        name = [name]\n\n    facets = self.get_all_facets(\n        text=text,\n        cas=cas,\n        category=category,\n        company=company,\n        location=location,\n        storage_location=storage_location,\n        project_id=project_id,\n        sheet_id=sheet_id,\n        created_by=created_by,\n        lot_owner=lot_owner,\n        tags=tags,\n        match_all_conditions=match_all_conditions,\n    )\n    filtered_facets = []\n    for facet in facets:\n        if facet.name in name or facet.name.lower() in name:\n            filtered_facets.append(facet)\n\n    return filtered_facets\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.get_match_or_none","title":"get_match_or_none","text":"<pre><code>get_match_or_none(\n    *, inventory_item: InventoryItem\n) -&gt; InventoryItem | None\n</code></pre> <p>Get a matching inventory item or return None if not found.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_item</code> <code>InventoryItem</code> <p>The inventory item to match.</p> required <p>Returns:</p> Type Description <code>Union[InventoryItem, None]</code> <p>The matching inventory item or None if not found.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def get_match_or_none(self, *, inventory_item: InventoryItem) -&gt; InventoryItem | None:\n    \"\"\"\n    Get a matching inventory item or return None if not found.\n\n    Parameters\n    ----------\n    inventory_item : InventoryItem\n        The inventory item to match.\n\n    Returns\n    -------\n    Union[InventoryItem, None]\n        The matching inventory item or None if not found.\n    \"\"\"\n    hits = self.list(text=inventory_item.name, company=[inventory_item.company])\n    inv_company = (\n        inventory_item.company.name\n        if isinstance(inventory_item.company, Company)\n        else inventory_item.company\n    )\n    for inv in hits:\n        if inv and inv.name == inventory_item.name and inv.company.name == inv_company:\n            return inv\n    else:\n        return None\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.get_specs","title":"get_specs","text":"<pre><code>get_specs(\n    *, ids: list[InventoryId]\n) -&gt; list[InventorySpecList]\n</code></pre> <p>Get the specs for a list of inventory items.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[InventoryId]</code> <p>List of Inventory IDs to get the specs for.</p> required <p>Returns:</p> Type Description <code>list[InventorySpecList]</code> <p>A list of InventorySpecList objects, each containing the specs for an inventory item.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef get_specs(self, *, ids: list[InventoryId]) -&gt; list[InventorySpecList]:\n    \"\"\"Get the specs for a list of inventory items.\n\n    Parameters\n    ----------\n    ids : list[InventoryId]\n        List of Inventory IDs to get the specs for.\n\n    Returns\n    -------\n    list[InventorySpecList]\n        A list of InventorySpecList objects, each containing the specs for an inventory item.\n    \"\"\"\n    url = f\"{self.base_path}/specs\"\n    batches = [ids[i : i + 250] for i in range(0, len(ids), 250)]\n    ta = TypeAdapter(InventorySpecList)\n    return [\n        ta.validate_python(item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()\n    ]\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.inventory_exists","title":"inventory_exists","text":"<pre><code>inventory_exists(*, inventory_item: InventoryItem) -&gt; bool\n</code></pre> <p>Check if an inventory item exists.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_item</code> <code>InventoryItem</code> <p>The inventory item to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the inventory item exists, False otherwise.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def inventory_exists(self, *, inventory_item: InventoryItem) -&gt; bool:\n    \"\"\"\n    Check if an inventory item exists.\n\n    Parameters\n    ----------\n    inventory_item : InventoryItem\n        The inventory item to check.\n\n    Returns\n    -------\n    bool\n        True if the inventory item exists, False otherwise.\n    \"\"\"\n    hit = self.get_match_or_none(inventory_item=inventory_item)\n    return bool(hit)\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory]\n    | InventoryCategory\n    | None = None,\n    company: list[Company] | Company | None = None,\n    order: OrderBy = DESCENDING,\n    sort_by: str | None = \"createdAt\",\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation]\n    | StorageLocation\n    | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; Iterator[InventoryItem]\n</code></pre> <p>List inventory items with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of items to return (default is 100)</p> <code>100</code> <code>text</code> <code>str</code> <p>Text to search for in inventory names and descriptions</p> <code>None</code> <code>cas</code> <code>list[Cas] | Cas | None</code> <p>Filter by CAS number(s)</p> <code>None</code> <code>category</code> <code>list[InventoryCategory] | InventoryCategory | None</code> <p>Filter by inventory category/categories</p> <code>None</code> <code>company</code> <code>list[Company] | Company | None</code> <p>Filter by manufacturing company/companies</p> <code>None</code> <code>order</code> <code>OrderBy</code> <p>Sort order, either ASCENDING or DESCENDING (default is DESCENDING)</p> <code>DESCENDING</code> <code>sort_by</code> <code>str</code> <p>Field to sort by (default is \"createdAt\")</p> <code>'createdAt'</code> <code>location</code> <code>list[Location] | None</code> <p>Filter by location(s)</p> <code>None</code> <code>storage_location</code> <code>list[StorageLocation] | None</code> <p>Filter by storage location(s)</p> <code>None</code> <code>project_id</code> <code>str</code> <p>Filter by project ID</p> <code>None</code> <code>sheet_id</code> <code>str</code> <p>Filter by sheet ID</p> <code>None</code> <code>created_by</code> <code>list[User]</code> <p>Filter by creator(s)</p> <code>None</code> <code>lot_owner</code> <code>list[User]</code> <p>Filter by lot owner(s)</p> <code>None</code> <code>tags</code> <code>list[str]</code> <p>Filter by tag(s)</p> <code>None</code> <code>match_all_conditions</code> <code>bool</code> <p>Whether to match all conditions (default is False -- e.g. OR between conditions)</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterator[InventoryItem]</code> <p>An iterator over the matching inventory items</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef list(\n    self,\n    *,\n    limit: int = 100,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory] | InventoryCategory | None = None,\n    company: list[Company] | Company | None = None,\n    order: OrderBy = OrderBy.DESCENDING,\n    sort_by: str | None = \"createdAt\",\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation] | StorageLocation | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; Iterator[InventoryItem]:\n    \"\"\"\n    List inventory items with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        Maximum number of items to return (default is 100)\n    text : str, optional\n        Text to search for in inventory names and descriptions\n    cas : list[Cas] | Cas | None, optional\n        Filter by CAS number(s)\n    category : list[InventoryCategory] | InventoryCategory | None, optional\n        Filter by inventory category/categories\n    company : list[Company] | Company | None, optional\n        Filter by manufacturing company/companies\n    order : OrderBy, optional\n        Sort order, either ASCENDING or DESCENDING (default is DESCENDING)\n    sort_by : str, optional\n        Field to sort by (default is \"createdAt\")\n    location : list[Location] | None, optional\n        Filter by location(s)\n    storage_location : list[StorageLocation] | None, optional\n        Filter by storage location(s)\n    project_id : str, optional\n        Filter by project ID\n    sheet_id : str, optional\n        Filter by sheet ID\n    created_by : list[User], optional\n        Filter by creator(s)\n    lot_owner : list[User], optional\n        Filter by lot owner(s)\n    tags : list[str], optional\n        Filter by tag(s)\n    match_all_conditions : bool, optional\n        Whether to match all conditions (default is False -- e.g. OR between conditions)\n\n    Returns\n    -------\n    Iterator[InventoryItem]\n        An iterator over the matching inventory items\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; list[InventoryItem]:\n        return self.get_by_ids(ids=[x[\"albertId\"] for x in items])\n\n    search_text = text if (text is None or len(text) &lt; 50) else text[0:50]\n\n    params = self._prepare_parameters(\n        limit=limit,\n        text=search_text,\n        cas=cas,\n        category=category,\n        company=company,\n        order=order,\n        sort_by=sort_by,\n        location=location,\n        storage_location=storage_location,\n        project_id=project_id,\n        sheet_id=sheet_id,\n        created_by=created_by,\n        lot_owner=lot_owner,\n        tags=tags,\n    )\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/llmsearch\"\n        if match_all_conditions\n        else f\"{self.base_path}/search\",\n        params=params,\n        session=self.session,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.merge","title":"merge","text":"<pre><code>merge(\n    *,\n    parent_id: InventoryId,\n    child_id: InventoryId | list[InventoryId],\n    modules: list[str] | None = None,\n) -&gt; None\n</code></pre> <p>Merge one or multiple child inventory into a parent inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>InventoryId</code> <p>The ID of the parent inventory item.</p> required <code>child_id</code> <code>InventoryId | list[InventoryId]</code> <p>The ID(s) of the child inventory item(s).</p> required <code>modules</code> <code>list[str]</code> <p>The merge modules to use (default is all).</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def merge(\n    self,\n    *,\n    parent_id: InventoryId,\n    child_id: InventoryId | list[InventoryId],\n    modules: list[str] | None = None,\n) -&gt; None:\n    \"\"\"\n    Merge one or multiple child inventory into a parent inventory item.\n\n    Parameters\n    ----------\n    parent_id : InventoryId\n        The ID of the parent inventory item.\n    child_id : InventoryId | list[InventoryId]\n        The ID(s) of the child inventory item(s).\n    modules : list[str], optional\n        The merge modules to use (default is all).\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    # assume \"all\" modules if not specified explicitly\n    modules = modules if modules is not None else ALL_MERGE_MODULES\n\n    # define merge endpoint\n    url = f\"{self.base_path}/merge\"\n\n    if isinstance(child_id, list):\n        child_inventories = [{\"id\": i} for i in child_id]\n    else:\n        child_inventories = [{\"id\": child_id}]\n\n    # define payload using the class\n    payload = MergeInventory(\n        parent_id=parent_id,\n        child_inventories=child_inventories,\n        modules=modules,\n    )\n\n    # post request\n    self.session.post(url, json=payload.model_dump(mode=\"json\", by_alias=True))\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.search","title":"search","text":"<pre><code>search(\n    *,\n    limit: int = 100,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory]\n    | InventoryCategory\n    | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation]\n    | StorageLocation\n    | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; Iterator[InventorySearchItem]\n</code></pre> <p>Get a list of inventory items that match the search criteria and return the raw search records. These are not full inventory item objects, but are special short documents intended for fast summary results</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef search(\n    self,\n    *,\n    limit: int = 100,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory] | InventoryCategory | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation] | StorageLocation | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; Iterator[InventorySearchItem]:\n    \"\"\"\n    Get a list of inventory items that match the search criteria and\n    return the raw search records. These are not full inventory item\n    objects, but are special short documents intended for fast summary results\n    \"\"\"\n\n    def deserialize(items: list[dict]):\n        return [InventorySearchItem.model_validate(x) for x in items]\n\n    params = self._prepare_parameters(\n        limit=limit,\n        text=text,\n        cas=cas,\n        category=category,\n        company=company,\n        location=location,\n        storage_location=storage_location,\n        project_id=project_id,\n        sheet_id=sheet_id,\n        created_by=created_by,\n        lot_owner=lot_owner,\n        tags=tags,\n    )\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/llmsearch\"\n        if match_all_conditions\n        else f\"{self.base_path}/search\",\n        params=params,\n        session=self.session,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.InventoryCollection.update","title":"update","text":"<pre><code>update(*, inventory_item: InventoryItem) -&gt; InventoryItem\n</code></pre> <p>Update an inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_item</code> <code>InventoryItem</code> <p>The updated inventory item object.</p> required <p>Returns:</p> Type Description <code>InventoryItem</code> <p>The updated inventory item retrieved from the server.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def update(self, *, inventory_item: InventoryItem) -&gt; InventoryItem:\n    \"\"\"\n    Update an inventory item.\n\n    Parameters\n    ----------\n    inventory_item : InventoryItem\n        The updated inventory item object.\n\n    Returns\n    -------\n    InventoryItem\n        The updated inventory item retrieved from the server.\n    \"\"\"\n    # Fetch the current object state from the server or database\n    current_object = self.get_by_id(id=inventory_item.id)\n\n    # Generate the PATCH payload\n    patch_payload = self._generate_inventory_patch_payload(\n        existing=current_object, updated=inventory_item\n    )\n\n    # Complex patching is not working, so I'm going to do this in a loop :(\n    # https://teams.microsoft.com/l/message/19:de4a48c366664ce1bafcdbea02298810@thread.tacv2/1724856117312?tenantId=98aab90e-764b-48f1-afaa-02e3c7300653&amp;groupId=35a36a3d-fc25-4899-a1dd-ad9c7d77b5b3&amp;parentMessageId=1724856117312&amp;teamName=Product%20%2B%20Engineering&amp;channelName=General%20-%20API&amp;createdTime=1724856117312\n    url = f\"{self.base_path}/{inventory_item.id}\"\n    for change in patch_payload[\"data\"]:\n        change_payload = {\"data\": [change]}\n        self.session.patch(url, json=change_payload)\n    updated_inv = self.get_by_id(id=inventory_item.id)\n    return updated_inv\n</code></pre>"},{"location":"albert/#albert.albert.LinksCollection","title":"LinksCollection","text":"<pre><code>LinksCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>LinksCollection is a collection class for managing Link entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Creates a new link entity.</p> <code>delete</code> <p>Deletes a link entity by its ID.</p> <code>get_by_id</code> <p>Retrieves a link entity by its ID.</p> <code>list</code> <p>Generates a list of link entities with optional filters.</p> Source code in <code>src/albert/collections/links.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the LinksCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{LinksCollection._api_version}/links\"\n</code></pre>"},{"location":"albert/#albert.albert.LinksCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/links'\n</code></pre>"},{"location":"albert/#albert.albert.LinksCollection.create","title":"create","text":"<pre><code>create(*, links: list[Link]) -&gt; list[Link]\n</code></pre> <p>Creates a new link entity.</p> <p>Parameters:</p> Name Type Description Default <code>links</code> <code>list[Link]</code> <p>List of Link entities to create.</p> required <p>Returns:</p> Type Description <code>Link</code> <p>The created link entity.</p> Source code in <code>src/albert/collections/links.py</code> <pre><code>def create(self, *, links: list[Link]) -&gt; list[Link]:\n    \"\"\"\n    Creates a new link entity.\n\n    Parameters\n    ----------\n    links : list[Link]\n        List of Link entities to create.\n\n    Returns\n    -------\n    Link\n        The created link entity.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=[l.model_dump(by_alias=True, exclude_none=True, mode=\"json\") for l in links],\n    )\n    return [Link(**l) for l in response.json()]\n</code></pre>"},{"location":"albert/#albert.albert.LinksCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a link entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the link entity to delete.</p> required Source code in <code>src/albert/collections/links.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a link entity by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the link entity to delete.\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    self.session.delete(path)\n</code></pre>"},{"location":"albert/#albert.albert.LinksCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Link\n</code></pre> <p>Retrieves a link entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the link entity to retrieve.</p> required <p>Returns:</p> Type Description <code>Link</code> <p>The retrieved link entity.</p> Source code in <code>src/albert/collections/links.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Link:\n    \"\"\"\n    Retrieves a link entity by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the link entity to retrieve.\n\n    Returns\n    -------\n    Link\n        The retrieved link entity.\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    response = self.session.get(path)\n    return Link(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.LinksCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    type: str | None = None,\n    category: LinkCategory | None = None,\n    id: str | None = None,\n) -&gt; Iterator[Link]\n</code></pre> <p>Generates a list of link entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of link entities to return.</p> <code>100</code> <code>type</code> <code>str</code> <p>The type of the link entities to return. Allowed values are <code>parent</code>, <code>child</code>, and <code>all</code>. If type is \"all\" then it will fetch both parent/child record for mentioned id.</p> <code>None</code> <code>category</code> <code>LinkCategory</code> <p>The category of the link entities to return. Allowed values are <code>mention</code>, <code>linkedTask</code>, and <code>synthesis</code>.</p> <code>None</code> <code>id</code> <code>str</code> <p>The ID of the link entity to return. (Use with <code>type</code> parameter)</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Link]</code> <p>An iterator of Links.</p> Source code in <code>src/albert/collections/links.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    type: str | None = None,\n    category: LinkCategory | None = None,\n    id: str | None = None,\n) -&gt; Iterator[Link]:\n    \"\"\"\n    Generates a list of link entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of link entities to return.\n    type : str, optional\n        The type of the link entities to return. Allowed values are `parent`, `child`, and `all`. If type is \"all\" then it will fetch both parent/child record for mentioned id.\n    category : LinkCategory, optional\n        The category of the link entities to return. Allowed values are `mention`, `linkedTask`, and `synthesis`.\n    id : str\n        The ID of the link entity to return. (Use with `type` parameter)\n\n    Returns\n    ------\n    Iterator[Link]\n        An iterator of Links.\n    \"\"\"\n    params = {\"limit\": limit, \"type\": type, \"category\": category, \"id\": id}\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        params=params,\n        session=self.session,\n        deserialize=lambda items: [Link(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.ListsCollection","title":"ListsCollection","text":"<pre><code>ListsCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ListsCollection is a collection class for managing ListItem entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Creates a list entity.</p> <code>delete</code> <p>Delete a lists entry item by its ID.</p> <code>get_by_id</code> <p>Retrieves a list entity by its ID.</p> <code>get_matching_item</code> <p>Get a list item by name and list type.</p> <code>list</code> <p>Generates a list of list entities with optional filters.</p> <code>update</code> <p>Update a list item.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the TagCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ListsCollection._api_version}/lists\"\n</code></pre>"},{"location":"albert/#albert.albert.ListsCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/lists'\n</code></pre>"},{"location":"albert/#albert.albert.ListsCollection.create","title":"create","text":"<pre><code>create(*, list_item: ListItem) -&gt; ListItem\n</code></pre> <p>Creates a list entity.</p> <p>Parameters:</p> Name Type Description Default <code>list_item</code> <code>ListItem</code> <p>The list entity to create.</p> required <p>Returns:</p> Type Description <code>List</code> <p>The created list entity.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def create(self, *, list_item: ListItem) -&gt; ListItem:\n    \"\"\"\n    Creates a list entity.\n\n    Parameters\n    ----------\n    list_item : ListItem\n        The list entity to create.\n\n    Returns\n    -------\n    List\n        The created list entity.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=list_item.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return ListItem(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.ListsCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a lists entry item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the lists item.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Delete a lists entry item by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the lists item.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.ListsCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; ListItem\n</code></pre> <p>Retrieves a list entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the list entity to retrieve.</p> required <p>Returns:</p> Type Description <code>List</code> <p>A list entity.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; ListItem:\n    \"\"\"\n    Retrieves a list entity by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the list entity to retrieve.\n\n    Returns\n    -------\n    List\n        A list entity.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return ListItem(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.ListsCollection.get_matching_item","title":"get_matching_item","text":"<pre><code>get_matching_item(\n    *, name: str, list_type: str\n) -&gt; ListItem | None\n</code></pre> <p>Get a list item by name and list type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of it item to retrieve.</p> required <code>list_type</code> <code>str</code> <p>The type of list (can be the name of the custom field)</p> required <p>Returns:</p> Type Description <code>ListItem | None</code> <p>A list item with the provided name and list type, or None if not found.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def get_matching_item(self, *, name: str, list_type: str) -&gt; ListItem | None:\n    \"\"\"Get a list item by name and list type.\n\n    Parameters\n    ----------\n    name : str\n        The name of it item to retrieve.\n    list_type : str\n        The type of list (can be the name of the custom field)\n\n    Returns\n    -------\n    ListItem | None\n        A list item with the provided name and list type, or None if not found.\n    \"\"\"\n    for list_item in self.list(names=[name], list_type=list_type):\n        if list_item.name.lower() == name.lower():\n            return list_item\n    return None\n</code></pre>"},{"location":"albert/#albert.albert.ListsCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    names: list[str] | None = None,\n    category: ListItemCategory | None = None,\n    list_type: str | None = None,\n    start_key: str | None = None,\n) -&gt; Iterator[ListItem]\n</code></pre> <p>Generates a list of list entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of list entities to return.</p> <code>100</code> <code>names</code> <code>list[str]</code> <p>A list of names of the list entity to retrieve.</p> <code>None</code> <code>category</code> <code>ListItemCategory</code> <p>The category of the list entity to retrieve.</p> <code>None</code> <code>list_type</code> <code>str</code> <p>The type of list entity to retrieve.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[ListItem]</code> <p>An iterator of ListItems.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    names: list[str] | None = None,\n    category: ListItemCategory | None = None,\n    list_type: str | None = None,\n    start_key: str | None = None,\n) -&gt; Iterator[ListItem]:\n    \"\"\"\n    Generates a list of list entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of list entities to return.\n    names : list[str], optional\n        A list of names of the list entity to retrieve.\n    category : ListItemCategory, optional\n        The category of the list entity to retrieve.\n    list_type : str, optional\n        The type of list entity to retrieve.\n    Returns\n    ------\n    Iterator[ListItem]\n        An iterator of ListItems.\n    \"\"\"\n    params = {\n        \"limit\": limit,\n        \"startKey\": start_key,\n        \"name\": [names] if isinstance(names, str) else names,\n        \"category\": category.value if isinstance(category, ListItemCategory) else category,\n        \"listType\": list_type,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [ListItem(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.ListsCollection.update","title":"update","text":"<pre><code>update(*, list_item=ListItem) -&gt; ListItem\n</code></pre> <p>Update a list item.</p> <p>Parameters:</p> Name Type Description Default <code>list_item</code> <code>ListItem</code> <p>The list item to update.</p> <code>ListItem</code> <p>Returns:</p> Type Description <code>ListItem</code> <p>The updated list item.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def update(self, *, list_item=ListItem) -&gt; ListItem:\n    \"\"\"Update a list item.\n\n    Parameters\n    ----------\n    list_item : ListItem\n        The list item to update.\n\n    Returns\n    -------\n    ListItem\n        The updated list item.\n    \"\"\"\n    existing = self.get_by_id(id=list_item.id)\n    patches = self._generate_patch_payload(\n        existing=existing, updated=list_item, generate_metadata_diff=False\n    )\n    if len(patches.data) == 0:\n        return existing\n    self.session.patch(\n        url=f\"{self.base_path}/{list_item.id}\",\n        json=patches.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return self.get_by_id(id=list_item.id)\n</code></pre>"},{"location":"albert/#albert.albert.LocationCollection","title":"LocationCollection","text":"<pre><code>LocationCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>LocationCollection is a collection class for managing Location entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Creates a new Location entity.</p> <code>delete</code> <p>Deletes a Location entity.</p> <code>get_by_id</code> <p>Retrieves a location by its ID.</p> <code>list</code> <p>Searches for locations matching the provided criteria.</p> <code>location_exists</code> <p>Determines if a location, with the same name, exists in the collection.</p> <code>update</code> <p>Update a Location entity.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the LocationCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{LocationCollection._api_version}/locations\"\n</code></pre>"},{"location":"albert/#albert.albert.LocationCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/locations'\n</code></pre>"},{"location":"albert/#albert.albert.LocationCollection.create","title":"create","text":"<pre><code>create(*, location: Location) -&gt; Location\n</code></pre> <p>Creates a new Location entity.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Location</code> <p>The Location object to create.</p> required <p>Returns:</p> Type Description <code>Location</code> <p>The created Location object.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def create(self, *, location: Location) -&gt; Location:\n    \"\"\"\n    Creates a new Location entity.\n\n    Parameters\n    ----------\n    location : Location\n        The Location object to create.\n\n    Returns\n    -------\n    Location\n        The created Location object.\n    \"\"\"\n    exists = self.location_exists(location=location)\n    if exists:\n        logging.warning(\n            f\"Location with name {location.name} matches an existing location. Returning the existing Location.\"\n        )\n        return exists\n\n    payload = location.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    response = self.session.post(self.base_path, json=payload)\n\n    return Location(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.LocationCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a Location entity.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>Str</code> <p>The id of the Location object to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a Location entity.\n\n    Parameters\n    ----------\n    id : Str\n        The id of the Location object to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.LocationCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Location\n</code></pre> <p>Retrieves a location by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the location to retrieve.</p> required <p>Returns:</p> Type Description <code>Location</code> <p>The Location object.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Location:\n    \"\"\"\n    Retrieves a location by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the location to retrieve.\n\n    Returns\n    -------\n    Location\n        The Location object.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return Location(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.LocationCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    name: str | list[str] | None = None,\n    country: str | None = None,\n    exact_match: bool = False,\n    limit: int = 50,\n    start_key: str | None = None,\n) -&gt; Iterator[Location]\n</code></pre> <p>Searches for locations matching the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | list[str] | None</code> <p>The name or names of locations to search for, by default None</p> <code>None</code> <code>country</code> <code>str | None</code> <p>The country code of the country to filter the locations , by default None</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to return exact matches only, by default False</p> <code>False</code> <p>Yields:</p> Type Description <code>Iterator[Location]</code> <p>An iterator of Location objects matching the search criteria.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def list(\n    self,\n    *,\n    name: str | list[str] | None = None,\n    country: str | None = None,\n    exact_match: bool = False,\n    limit: int = 50,\n    start_key: str | None = None,\n) -&gt; Iterator[Location]:\n    \"\"\"Searches for locations matching the provided criteria.\n\n    Parameters\n    ----------\n    name : str | list[str] | None, optional\n        The name or names of locations to search for, by default None\n    country : str | None, optional\n        The country code of the country to filter the locations , by default None\n    exact_match : bool, optional\n        Whether to return exact matches only, by default False\n\n\n    Yields\n    ------\n    Iterator[Location]\n        An iterator of Location objects matching the search criteria.\n    \"\"\"\n    params = {\"limit\": limit, \"startKey\": start_key, \"country\": country}\n    if name:\n        params[\"name\"] = [name] if isinstance(name, str) else name\n        params[\"exactMatch\"] = json.dumps(exact_match)\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Location(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.LocationCollection.location_exists","title":"location_exists","text":"<pre><code>location_exists(*, location: Location) -&gt; Location | None\n</code></pre> <p>Determines if a location, with the same name, exists in the collection.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Location</code> <p>The Location object to check</p> required <p>Returns:</p> Type Description <code>Location | None</code> <p>The existing registered Location object if found, otherwise None.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def location_exists(self, *, location: Location) -&gt; Location | None:\n    \"\"\"Determines if a location, with the same name, exists in the collection.\n\n    Parameters\n    ----------\n    location : Location\n        The Location object to check\n\n    Returns\n    -------\n    Location | None\n        The existing registered Location object if found, otherwise None.\n    \"\"\"\n    hits = self.list(name=location.name)\n    if hits:\n        for hit in hits:\n            if hit and hit.name.lower() == location.name.lower():\n                return hit\n    return None\n</code></pre>"},{"location":"albert/#albert.albert.LocationCollection.update","title":"update","text":"<pre><code>update(*, location: Location) -&gt; Location\n</code></pre> <p>Update a Location entity.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Location</code> <p>The Location object to update. The ID of the Location object must be provided.</p> required <p>Returns:</p> Type Description <code>Location</code> <p>The updated Location object as returned by the server.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def update(self, *, location: Location) -&gt; Location:\n    \"\"\"Update a Location entity.\n\n    Parameters\n    ----------\n    location : Location\n        The Location object to update. The ID of the Location object must be provided.\n\n    Returns\n    -------\n    Location\n        The updated Location object as returned by the server.\n    \"\"\"\n    # Fetch the current object state from the server or database\n    current_object = self.get_by_id(id=location.id)\n    # Generate the PATCH payload\n    patch_payload = self._generate_patch_payload(\n        existing=current_object,\n        updated=location,\n        stringify_values=True,\n    )\n    url = f\"{self.base_path}/{location.id}\"\n    self.session.patch(url, json=patch_payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=location.id)\n</code></pre>"},{"location":"albert/#albert.albert.LotCollection","title":"LotCollection","text":"<pre><code>LotCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>LotCollection is a collection class for managing Lot entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>An Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <code>delete</code> <p>Delete a lot by its ID.</p> <code>get_by_id</code> <p>Get a lot by its ID.</p> <code>get_by_ids</code> <p>Get a list of lots by their IDs.</p> <code>list</code> <p>Lists Lot entities with optional filters.</p> <code>update</code> <p>Update a lot.</p> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"A collection for interacting with Lots in Albert.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        An Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{LotCollection._api_version}/lots\"\n</code></pre>"},{"location":"albert/#albert.albert.LotCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/lots'\n</code></pre>"},{"location":"albert/#albert.albert.LotCollection.create","title":"create","text":"<pre><code>create(*, lots: list[Lot]) -&gt; list[Lot]\n</code></pre> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def create(self, *, lots: list[Lot]) -&gt; list[Lot]:\n    # TODO: Once thi endpoint is fixed, go back to passing the whole list at once\n    payload = [lot.model_dump(by_alias=True, exclude_none=True, mode=\"json\") for lot in lots]\n    all_lots = []\n    for lot in payload:\n        response = self.session.post(self.base_path, json=[lot])\n        all_lots.append(Lot(**response.json()[0]))\n    # response = self.session.post(self.base_path, json=payload)\n    # return [Lot(**lot) for lot in response.json().get(\"CreatedLots\", [])]\n    return all_lots\n</code></pre>"},{"location":"albert/#albert.albert.LotCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a lot by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the lot to delete.</p> required Source code in <code>src/albert/collections/lots.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a lot by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the lot to delete.\n    \"\"\"\n    url = f\"{self.base_path}?id={id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.LotCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Lot\n</code></pre> <p>Get a lot by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the lot to get.</p> required <p>Returns:</p> Type Description <code>Lot</code> <p>The lot with the provided ID.</p> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Lot:\n    \"\"\"Get a lot by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the lot to get.\n\n    Returns\n    -------\n    Lot\n        The lot with the provided ID.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return Lot(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.LotCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(*, ids: list[str]) -&gt; list[Lot]\n</code></pre> <p>Get a list of lots by their IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>A list of lot IDs to get.</p> required <p>Returns:</p> Type Description <code>list[Lot]</code> <p>A list of lots with the provided IDs.</p> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def get_by_ids(self, *, ids: list[str]) -&gt; list[Lot]:\n    \"\"\"Get a list of lots by their IDs.\n\n    Parameters\n    ----------\n    ids : list[str]\n        A list of lot IDs to get.\n\n    Returns\n    -------\n    list[Lot]\n        A list of lots with the provided IDs.\n    \"\"\"\n    url = f\"{self.base_path}/ids\"\n    response = self.session.get(url, params={\"id\": ids})\n    return [Lot(**lot) for lot in response.json()[\"Items\"]]\n</code></pre>"},{"location":"albert/#albert.albert.LotCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    start_key: str | None = None,\n    parent_id: str | None = None,\n    inventory_id: str | None = None,\n    barcode_id: str | None = None,\n    parent_id_category: str | None = None,\n    inventory_on_hand: str | None = None,\n    location_id: str | None = None,\n    exact_match: bool = False,\n    begins_with: bool = False,\n) -&gt; Iterator[Lot]\n</code></pre> <p>Lists Lot entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of Lots to return, by default 100.</p> <code>100</code> <code>start_key</code> <code>Optional[str]</code> <p>The primary key of the first item to evaluate for pagination.</p> <code>None</code> <code>parent_id</code> <code>Optional[str]</code> <p>Fetches list of lots for a parentId (inventory).</p> <code>None</code> <code>inventory_id</code> <code>Optional[str]</code> <p>Fetches list of lots for an inventory.</p> <code>None</code> <code>barcode_id</code> <code>Optional[str]</code> <p>Fetches list of lots for a barcodeId.</p> <code>None</code> <code>parent_id_category</code> <code>Optional[str]</code> <p>Fetches list of lots for a parentIdCategory (e.g., RawMaterials, Consumables).</p> <code>None</code> <code>inventory_on_hand</code> <code>Optional[str]</code> <p>Fetches records based on inventoryOnHand (lteZero, gtZero, eqZero).</p> <code>None</code> <code>location_id</code> <code>Optional[str]</code> <p>Fetches list of lots for a locationId.</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Determines if barcodeId field should be an exact match, by default False.</p> <code>False</code> <code>begins_with</code> <code>bool</code> <p>Determines if barcodeId begins with a certain value, by default False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Iterator[Lot]</code> <p>An iterator of Lot objects.</p> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    start_key: str | None = None,\n    parent_id: str | None = None,\n    inventory_id: str | None = None,\n    barcode_id: str | None = None,\n    parent_id_category: str | None = None,\n    inventory_on_hand: str | None = None,\n    location_id: str | None = None,\n    exact_match: bool = False,\n    begins_with: bool = False,\n) -&gt; Iterator[Lot]:\n    \"\"\"\n    Lists Lot entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of Lots to return, by default 100.\n    start_key : Optional[str], optional\n        The primary key of the first item to evaluate for pagination.\n    parent_id : Optional[str], optional\n        Fetches list of lots for a parentId (inventory).\n    inventory_id : Optional[str], optional\n        Fetches list of lots for an inventory.\n    barcode_id : Optional[str], optional\n        Fetches list of lots for a barcodeId.\n    parent_id_category : Optional[str], optional\n        Fetches list of lots for a parentIdCategory (e.g., RawMaterials, Consumables).\n    inventory_on_hand : Optional[str], optional\n        Fetches records based on inventoryOnHand (lteZero, gtZero, eqZero).\n    location_id : Optional[str], optional\n        Fetches list of lots for a locationId.\n    exact_match : bool, optional\n        Determines if barcodeId field should be an exact match, by default False.\n    begins_with : bool, optional\n        Determines if barcodeId begins with a certain value, by default False.\n\n    Yields\n    -------\n    Iterator[Lot]\n        An iterator of Lot objects.\n    \"\"\"\n    params = {\n        \"limit\": limit,\n        \"startKey\": start_key,\n        \"parentId\": parent_id,\n        \"inventoryId\": inventory_id,\n        \"barcodeId\": barcode_id,\n        \"parentIdCategory\": parent_id_category,\n        \"inventoryOnHand\": inventory_on_hand,\n        \"locationId\": location_id,\n        \"exactMatch\": json.dumps(exact_match),\n        \"beginsWith\": json.dumps(begins_with),\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Lot(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.LotCollection.update","title":"update","text":"<pre><code>update(*, lot: Lot) -&gt; Lot\n</code></pre> <p>Update a lot.</p> <p>Parameters:</p> Name Type Description Default <code>lot</code> <code>Lot</code> <p>The updated lot object.</p> required <p>Returns:</p> Type Description <code>Lot</code> <p>The updated lot object as returned by the server.</p> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def update(self, *, lot: Lot) -&gt; Lot:\n    \"\"\"Update a lot.\n\n    Parameters\n    ----------\n    lot : Lot\n        The updated lot object.\n\n    Returns\n    -------\n    Lot\n        The updated lot object as returned by the server.\n    \"\"\"\n    existing_lot = self.get_by_id(id=lot.id)\n    patch_data = self._generate_patch_payload(existing=existing_lot, updated=lot)\n    url = f\"{self.base_path}/{lot.id}\"\n\n    self.session.patch(url, json=patch_data.model_dump(mode=\"json\", by_alias=True))\n\n    return self.get_by_id(id=lot.id)\n</code></pre>"},{"location":"albert/#albert.albert.NotebookCollection","title":"NotebookCollection","text":"<pre><code>NotebookCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>NotebookCollection is a collection class for managing Notebook entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>copy</code> <p>Create a copy of a Notebook into a specified parent</p> <code>create</code> <p>Create or return notebook for the provided notebook.</p> <code>delete</code> <p>Deletes a notebook by its ID.</p> <code>get_block_by_id</code> <p>Retrieve a Notebook Block by its ID.</p> <code>get_by_id</code> <p>Retrieve a Notebook by its ID.</p> <code>list_by_parent_id</code> <p>Retrieve a Notebook by parent ID.</p> <code>update</code> <p>Update a notebook.</p> <code>update_block_content</code> <p>Updates the block content of a Notebook. This does not update the notebook name (use .update for that).</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the NotebookCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{NotebookCollection._api_version}/notebooks\"\n</code></pre>"},{"location":"albert/#albert.albert.NotebookCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/notebooks'\n</code></pre>"},{"location":"albert/#albert.albert.NotebookCollection.copy","title":"copy","text":"<pre><code>copy(\n    *,\n    notebook_copy_info: NotebookCopyInfo,\n    type: NotebookCopyType,\n) -&gt; Notebook\n</code></pre> <p>Create a copy of a Notebook into a specified parent</p> <p>Parameters:</p> Name Type Description Default <code>notebook_copy_info</code> <code>NotebookCopyInfo</code> <p>The copy information for the Notebook copy</p> required <code>type</code> <code>NotebookCopyType</code> <p>Differentiate whether copy is for templates, task, project or restoreTemplate</p> required <p>Returns:</p> Type Description <code>Notebook</code> <p>The result of the copied Notebook.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def copy(self, *, notebook_copy_info: NotebookCopyInfo, type: NotebookCopyType) -&gt; Notebook:\n    \"\"\"Create a copy of a Notebook into a specified parent\n\n    Parameters\n    ----------\n    notebook_copy_info : NotebookCopyInfo\n        The copy information for the Notebook copy\n    type : NotebookCopyType\n        Differentiate whether copy is for templates, task, project or restoreTemplate\n\n    Returns\n    -------\n    Notebook\n        The result of the copied Notebook.\n    \"\"\"\n    response = self.session.post(\n        url=f\"{self.base_path}/copy\",\n        json=notebook_copy_info.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n        params={\"type\": type, \"parentId\": notebook_copy_info.parent_id},\n    )\n    return Notebook(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.NotebookCollection.create","title":"create","text":"<pre><code>create(*, notebook: Notebook) -&gt; Notebook\n</code></pre> <p>Create or return notebook for the provided notebook. This endpoint automatically tries to find an existing notebook with the same parameter setpoints, and will either return the existing notebook or create a new one.</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>Notebook</code> <p>A list of Notebook objects to find or create.</p> required <p>Returns:</p> Type Description <code>Notebook</code> <p>A list of created or found Notebook objects.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def create(self, *, notebook: Notebook) -&gt; Notebook:\n    \"\"\"Create or return notebook for the provided notebook.\n    This endpoint automatically tries to find an existing notebook with the same parameter setpoints, and will either return the existing notebook or create a new one.\n\n    Parameters\n    ----------\n    notebook : Notebook\n        A list of Notebook objects to find or create.\n\n    Returns\n    -------\n    Notebook\n        A list of created or found Notebook objects.\n    \"\"\"\n    if notebook.blocks:\n        # This check keeps a user from corrupting the Notebook data.\n        msg = (\n            \"Cannot create a Notebook with pre-filled blocks. \"\n            \"Set `blocks=[]` (or do not set it) when creating it. \"\n            \"Use `.update_block_content()` afterward to add, update, or delete blocks.\"\n        )\n        raise AlbertException(msg)\n    response = self.session.post(\n        url=self.base_path,\n        json=notebook.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n        params={\"parentId\": notebook.parent_id},\n    )\n    return Notebook(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.NotebookCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a notebook by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the notebook to delete.</p> required Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a notebook by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the notebook to delete.\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"albert/#albert.albert.NotebookCollection.get_block_by_id","title":"get_block_by_id","text":"<pre><code>get_block_by_id(\n    *, notebook_id: str, block_id: str\n) -&gt; NotebookBlock\n</code></pre> <p>Retrieve a Notebook Block by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the Notebook Block to retrieve.</p> required <p>Returns:</p> Type Description <code>NotebookBlock</code> <p>The NotebookBlock object.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def get_block_by_id(self, *, notebook_id: str, block_id: str) -&gt; NotebookBlock:\n    \"\"\"Retrieve a Notebook Block by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the Notebook Block to retrieve.\n\n    Returns\n    -------\n    NotebookBlock\n        The NotebookBlock object.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{notebook_id}/blocks/{block_id}\")\n    return TypeAdapter(NotebookBlock).validate_python(response.json())\n</code></pre>"},{"location":"albert/#albert.albert.NotebookCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Notebook\n</code></pre> <p>Retrieve a Notebook by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the Notebook to retrieve.</p> required <p>Returns:</p> Type Description <code>Notebook</code> <p>The Notebook object.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Notebook:\n    \"\"\"Retrieve a Notebook by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the Notebook to retrieve.\n\n    Returns\n    -------\n    Notebook\n        The Notebook object.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return Notebook(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.NotebookCollection.list_by_parent_id","title":"list_by_parent_id","text":"<pre><code>list_by_parent_id(*, parent_id: str) -&gt; list[Notebook]\n</code></pre> <p>Retrieve a Notebook by parent ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the parent ID, e.g. task.</p> required <p>Returns:</p> Type Description <code>list[Notebook]</code> <p>list of notebook references.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def list_by_parent_id(self, *, parent_id: str) -&gt; list[Notebook]:\n    \"\"\"Retrieve a Notebook by parent ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the parent ID, e.g. task.\n\n    Returns\n    -------\n    list[Notebook]\n        list of notebook references.\n\n    \"\"\"\n\n    # search\n    response = self.session.get(f\"{self.base_path}/{parent_id}/search\")\n    # return\n    return [self.get_by_id(id=x[\"id\"]) for x in response.json()[\"Items\"]]\n</code></pre>"},{"location":"albert/#albert.albert.NotebookCollection.update","title":"update","text":"<pre><code>update(*, notebook: Notebook) -&gt; Notebook\n</code></pre> <p>Update a notebook.</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>Notebook</code> <p>The updated notebook object.</p> required <p>Returns:</p> Type Description <code>Notebook</code> <p>The updated notebook object as returned by the server.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def update(self, *, notebook: Notebook) -&gt; Notebook:\n    \"\"\"Update a notebook.\n\n    Parameters\n    ----------\n    notebook : Notebook\n        The updated notebook object.\n\n    Returns\n    -------\n    Notebook\n        The updated notebook object as returned by the server.\n    \"\"\"\n    existing_notebook = self.get_by_id(id=notebook.id)\n    patch_data = self._generate_patch_payload(existing=existing_notebook, updated=notebook)\n    url = f\"{self.base_path}/{notebook.id}\"\n\n    self.session.patch(url, json=patch_data.model_dump(mode=\"json\", by_alias=True))\n\n    return self.get_by_id(id=notebook.id)\n</code></pre>"},{"location":"albert/#albert.albert.NotebookCollection.update_block_content","title":"update_block_content","text":"<pre><code>update_block_content(*, notebook: Notebook) -&gt; Notebook\n</code></pre> <p>Updates the block content of a Notebook. This does not update the notebook name (use .update for that). If a block in the Notebook does not already exist on Albert, it will be created. Note: The order of the Blocks in your Notebook matter and will be used in the updated Notebook!</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>Notebook</code> <p>The updated notebook object.</p> required <p>Returns:</p> Type Description <code>Notebook</code> <p>The updated notebook object as returned by the server.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def update_block_content(self, *, notebook: Notebook) -&gt; Notebook:\n    \"\"\"\n    Updates the block content of a Notebook. This does not update the notebook name (use .update for that).\n    If a block in the Notebook does not already exist on Albert, it will be created.\n    *Note: The order of the Blocks in your Notebook matter and will be used in the updated Notebook!*\n\n\n    Parameters\n    ----------\n    notebook : Notebook\n        The updated notebook object.\n\n    Returns\n    -------\n    Notebook\n        The updated notebook object as returned by the server.\n    \"\"\"\n    put_data = self._generate_put_block_payload(notebook=notebook)\n    url = f\"{self.base_path}/{notebook.id}/content\"\n\n    self.session.put(url, json=put_data.model_dump(mode=\"json\", by_alias=True))\n\n    return self.get_by_id(id=notebook.id)\n</code></pre>"},{"location":"albert/#albert.albert.NotesCollection","title":"NotesCollection","text":"<pre><code>NotesCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>NotesCollection is a collection class for managing Note entities in the Albert platform.</p> <p>Methods:</p> Name Description <code>create</code> <p>Creates a new note.</p> <code>delete</code> <p>Deletes a note by its ID.</p> <code>get_by_id</code> <p>Retrieves a note by its ID.</p> <code>list</code> <p>Lists notes by their parent ID.</p> <code>update</code> <p>Updates a note.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{NotesCollection._api_version}/notes\"\n</code></pre>"},{"location":"albert/#albert.albert.NotesCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/notes'\n</code></pre>"},{"location":"albert/#albert.albert.NotesCollection.create","title":"create","text":"<pre><code>create(*, note: Note) -&gt; Note\n</code></pre> <p>Creates a new note.</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>str</code> <p>The note content.</p> required <p>Returns:</p> Type Description <code>Note</code> <p>The created note.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def create(self, *, note: Note) -&gt; Note:\n    \"\"\"\n    Creates a new note.\n\n    Parameters\n    ----------\n    note : str\n        The note content.\n\n    Returns\n    -------\n    Note\n        The created note.\n    \"\"\"\n    response = self.session.post(\n        self.base_path, json=note.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    )\n    return Note(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.NotesCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a note by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the note to delete.</p> required Source code in <code>src/albert/collections/notes.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a note by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the note to delete.\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"albert/#albert.albert.NotesCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Note\n</code></pre> <p>Retrieves a note by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the note to retrieve.</p> required <p>Returns:</p> Type Description <code>Note</code> <p>The note if found, None otherwise.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Note:\n    \"\"\"\n    Retrieves a note by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the note to retrieve.\n\n    Returns\n    -------\n    Note\n        The note if found, None otherwise.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return Note(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.NotesCollection.list","title":"list","text":"<pre><code>list(\n    *, parent_id: str, order_by: OrderBy = DESCENDING\n) -&gt; list[Note]\n</code></pre> <p>Lists notes by their parent ID.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>str</code> <p>The parent ID of the notes to list.</p> required <code>order_by</code> <code>OrderBy</code> <p>The order to list notes in, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <p>Returns:</p> Type Description <code>List[Note]</code> <p>The list of notes.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def list(self, *, parent_id: str, order_by: OrderBy = OrderBy.DESCENDING) -&gt; list[Note]:\n    \"\"\"\n    Lists notes by their parent ID.\n\n    Parameters\n    ----------\n    parent_id : str\n        The parent ID of the notes to list.\n    order_by : OrderBy, optional\n        The order to list notes in, by default OrderBy.DESCENDING.\n\n    Returns\n    -------\n    List[Note]\n        The list of notes.\n    \"\"\"\n\n    params = {\"parentId\": parent_id, \"orderBy\": order_by.value}\n    return AlbertPaginator(\n        session=self.session,\n        path=self.base_path,\n        mode=PaginationMode.KEY,\n        params=params,\n        deserialize=lambda items: [Note(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.NotesCollection.update","title":"update","text":"<pre><code>update(*, note: Note) -&gt; Note\n</code></pre> <p>Updates a note.</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>Note</code> <p>The note to update. The note must have an ID.</p> required <p>Returns:</p> Type Description <code>Note</code> <p>The updated note as returned by the server.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def update(self, *, note: Note) -&gt; Note:\n    \"\"\"Updates a note.\n\n    Parameters\n    ----------\n    note : Note\n        The note to update. The note must have an ID.\n\n    Returns\n    -------\n    Note\n        The updated note as returned by the server.\n    \"\"\"\n    patch = self._generate_patch_payload(\n        existing=self.get_by_id(id=note.id), updated=note, generate_metadata_diff=False\n    )\n    self.session.patch(\n        f\"{self.base_path}/{note.id}\",\n        json=patch.model_dump(mode=\"json\", by_alias=True, exclude_unset=True),\n    )\n    return self.get_by_id(id=note.id)\n</code></pre>"},{"location":"albert/#albert.albert.ParameterCollection","title":"ParameterCollection","text":"<pre><code>ParameterCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ParameterCollection is a collection class for managing Parameter entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new parameter.</p> <code>delete</code> <p>Delete a parameter by its ID.</p> <code>get_by_id</code> <p>Retrieve a parameter by its ID.</p> <code>list</code> <p>Lists parameters that match the provided criteria.</p> <code>update</code> <p>Update a parameter.</p> Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initializes the ParameterCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ParameterCollection._api_version}/parameters\"\n</code></pre>"},{"location":"albert/#albert.albert.ParameterCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/parameters'\n</code></pre>"},{"location":"albert/#albert.albert.ParameterCollection.create","title":"create","text":"<pre><code>create(*, parameter: Parameter) -&gt; Parameter\n</code></pre> <p>Create a new parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>Parameter</code> <p>The parameter to create.</p> required <p>Returns:</p> Type Description <code>Parameter</code> <p>Returns the created parameter or the existing parameter if it already exists.</p> Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def create(self, *, parameter: Parameter) -&gt; Parameter:\n    \"\"\"Create a new parameter.\n\n    Parameters\n    ----------\n    parameter : Parameter\n        The parameter to create.\n\n    Returns\n    -------\n    Parameter\n        Returns the created parameter or the existing parameter if it already exists.\n    \"\"\"\n    match = next(self.list(names=parameter.name, exact_match=True), None)\n    if match is not None:\n        logging.warning(\n            f\"Parameter with name {parameter.name} already exists. Returning existing parameter.\"\n        )\n        return match\n    response = self.session.post(\n        self.base_path,\n        json=parameter.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return Parameter(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.ParameterCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a parameter by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the parameter to delete.</p> required Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a parameter by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the parameter to delete.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.ParameterCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Parameter\n</code></pre> <p>Retrieve a parameter by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the parameter to retrieve.</p> required <p>Returns:</p> Type Description <code>Parameter</code> <p>The parameter with the given ID.</p> Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Parameter:\n    \"\"\"Retrieve a parameter by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the parameter to retrieve.\n\n    Returns\n    -------\n    Parameter\n        The parameter with the given ID.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return Parameter(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.ParameterCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    ids: list[str] | None = None,\n    names: str | list[str] = None,\n    exact_match: bool = False,\n    order_by: OrderBy = DESCENDING,\n    start_key: str | None = None,\n    limit: int = 50,\n) -&gt; Iterator[Parameter]\n</code></pre> <p>Lists parameters that match the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str] | None</code> <p>A list of parameter IDs to retrieve, by default None</p> <code>None</code> <code>names</code> <code>str | list[str]</code> <p>A list of parameter names to retrieve, by default None</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default False</p> <code>False</code> <code>order_by</code> <code>OrderBy</code> <p>The order in which to return results, by default OrderBy.DESCENDING</p> <code>DESCENDING</code> <p>Yields:</p> Type Description <code>Iterator[Parameter]</code> <p>An iterator of Parameters matching the given criteria.</p> Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def list(\n    self,\n    *,\n    ids: list[str] | None = None,\n    names: str | list[str] = None,\n    exact_match: bool = False,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    start_key: str | None = None,\n    limit: int = 50,\n) -&gt; Iterator[Parameter]:\n    \"\"\"Lists parameters that match the provided criteria.\n\n    Parameters\n    ----------\n    ids : list[str] | None, optional\n        A list of parameter IDs to retrieve, by default None\n    names : str | list[str], optional\n        A list of parameter names to retrieve, by default None\n    exact_match : bool, optional\n        Whether to match the name exactly, by default False\n    order_by : OrderBy, optional\n        The order in which to return results, by default OrderBy.DESCENDING\n\n    Yields\n    ------\n    Iterator[Parameter]\n        An iterator of Parameters matching the given criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[Parameter]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching Parameter '{id}': {e}\")\n\n    params = {\"limit\": limit, \"orderBy\": order_by, \"parameters\": ids, \"startKey\": start_key}\n    if names:\n        params[\"name\"] = [names] if isinstance(names, str) else names\n        params[\"exactMatch\"] = json.dumps(exact_match)\n\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.ParameterCollection.update","title":"update","text":"<pre><code>update(*, parameter: Parameter) -&gt; Parameter\n</code></pre> <p>Update a parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>Parameter</code> <p>The updated parameter to save. The parameter must have an ID.</p> required <p>Returns:</p> Type Description <code>Parameter</code> <p>The updated parameter as returned by the server.</p> Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def update(self, *, parameter: Parameter) -&gt; Parameter:\n    \"\"\"Update a parameter.\n\n    Parameters\n    ----------\n    parameter : Parameter\n        The updated parameter to save. The parameter must have an ID.\n\n    Returns\n    -------\n    Parameter\n        The updated parameter as returned by the server.\n    \"\"\"\n    existing = self.get_by_id(id=parameter.id)\n    payload = self._generate_patch_payload(\n        existing=existing,\n        updated=parameter,\n    )\n    payload_dump = payload.model_dump(mode=\"json\", by_alias=True)\n    for i, change in enumerate(payload_dump[\"data\"]):\n        if not self._is_metadata_item_list(\n            existing_object=existing,\n            updated_object=parameter,\n            metadata_field=change[\"attribute\"],\n        ):\n            change[\"operation\"] = \"update\"\n            if \"newValue\" in change and change[\"newValue\"] is None:\n                del change[\"newValue\"]\n            if \"oldValue\" in change and change[\"oldValue\"] is None:\n                del change[\"oldValue\"]\n            payload_dump[\"data\"][i] = change\n    if len(payload_dump[\"data\"]) == 0:\n        return parameter\n    for e in payload_dump[\"data\"]:\n        self.session.patch(\n            f\"{self.base_path}/{parameter.id}\",\n            json={\"data\": [e]},\n        )\n    return self.get_by_id(id=parameter.id)\n</code></pre>"},{"location":"albert/#albert.albert.ParameterGroupCollection","title":"ParameterGroupCollection","text":"<pre><code>ParameterGroupCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ParameterGroupCollection is a collection class for managing ParameterGroup entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session to use for making requests.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new parameter group.</p> <code>delete</code> <p>Delete a parameter group by its ID.</p> <code>get_by_id</code> <p>Get a parameter group by its ID.</p> <code>get_by_ids</code> <code>get_by_name</code> <p>Get a parameter group by its name.</p> <code>list</code> <p>Search for Parameter Groups matching the given criteria.</p> <code>update</code> <p>Update a parameter group.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"A collection for interacting with Albert parameter groups.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session to use for making requests.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ParameterGroupCollection._api_version}/parametergroups\"\n</code></pre>"},{"location":"albert/#albert.albert.ParameterGroupCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/parametergroups'\n</code></pre>"},{"location":"albert/#albert.albert.ParameterGroupCollection.create","title":"create","text":"<pre><code>create(\n    *, parameter_group: ParameterGroup\n) -&gt; ParameterGroup\n</code></pre> <p>Create a new parameter group.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_group</code> <code>ParameterGroup</code> <p>The parameter group to create.</p> required <p>Returns:</p> Type Description <code>ParameterGroup</code> <p>The created parameter group.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def create(self, *, parameter_group: ParameterGroup) -&gt; ParameterGroup:\n    \"\"\"Create a new parameter group.\n\n    Parameters\n    ----------\n    parameter_group : ParameterGroup\n        The parameter group to create.\n\n    Returns\n    -------\n    ParameterGroup\n        The created parameter group.\n    \"\"\"\n\n    response = self.session.post(\n        self.base_path,\n        json=parameter_group.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return ParameterGroup(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.ParameterGroupCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a parameter group by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the parameter group to delete</p> required Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a parameter group by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the parameter group to delete\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    self.session.delete(path)\n</code></pre>"},{"location":"albert/#albert.albert.ParameterGroupCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; ParameterGroup\n</code></pre> <p>Get a parameter group by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the parameter group to retrieve.</p> required <p>Returns:</p> Type Description <code>ParameterGroup</code> <p>The parameter group with the given ID.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; ParameterGroup:\n    \"\"\"Get a parameter group by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the parameter group to retrieve.\n\n    Returns\n    -------\n    ParameterGroup\n        The parameter group with the given ID.\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    response = self.session.get(path)\n    return ParameterGroup(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.ParameterGroupCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(*, ids: list[str]) -&gt; ParameterGroup\n</code></pre> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def get_by_ids(self, *, ids: list[str]) -&gt; ParameterGroup:\n    url = f\"{self.base_path}/ids\"\n    batches = [ids[i : i + 100] for i in range(0, len(ids), 100)]\n    return [\n        ParameterGroup(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()[\"Items\"]\n    ]\n</code></pre>"},{"location":"albert/#albert.albert.ParameterGroupCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(*, name: str) -&gt; ParameterGroup | None\n</code></pre> <p>Get a parameter group by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter group to retrieve.</p> required <p>Returns:</p> Type Description <code>ParameterGroup | None</code> <p>The parameter group with the given name, or None if not found.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def get_by_name(self, *, name: str) -&gt; ParameterGroup | None:\n    \"\"\"Get a parameter group by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the parameter group to retrieve.\n\n    Returns\n    -------\n    ParameterGroup | None\n        The parameter group with the given name, or None if not found.\n    \"\"\"\n    matches = self.list(text=name)\n    for m in matches:\n        if m.name.lower() == name.lower():\n            return m\n    return None\n</code></pre>"},{"location":"albert/#albert.albert.ParameterGroupCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    text: str | None = None,\n    types: PGType | list[PGType] | None = None,\n    order_by: OrderBy = DESCENDING,\n    limit: int = 25,\n    offset: int | None = None,\n) -&gt; Iterator[ParameterGroup]\n</code></pre> <p>Search for Parameter Groups matching the given criteria.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Text to search for, by default None</p> <code>None</code> <code>types</code> <code>PGType | list[PGType] | None</code> <p>Filer the returned Parameter Groups by Type, by default None</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order in which to return results, by default OrderBy.DESCENDING</p> <code>DESCENDING</code> <p>Yields:</p> Type Description <code>Iterator[ParameterGroup]</code> <p>An iterator of Parameter Groups matching the given criteria.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def list(\n    self,\n    *,\n    text: str | None = None,\n    types: PGType | list[PGType] | None = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    limit: int = 25,\n    offset: int | None = None,\n) -&gt; Iterator[ParameterGroup]:\n    \"\"\"Search for Parameter Groups matching the given criteria.\n\n    Parameters\n    ----------\n    text : str | None, optional\n        Text to search for, by default None\n    types : PGType | list[PGType] | None, optional\n        Filer the returned Parameter Groups by Type, by default None\n    order_by : OrderBy, optional\n        The order in which to return results, by default OrderBy.DESCENDING\n\n    Yields\n    ------\n    Iterator[ParameterGroup]\n        An iterator of Parameter Groups matching the given criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[ParameterGroup]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:  # pragma: no cover\n                logger.warning(f\"Error fetching parameter group {id}: {e}\")\n        # Currently, the API is not returning metadata for the list_by_ids endpoint, so we need to fetch individually until that is fixed\n        # return self.get_by_ids(ids=[x[\"albertId\"] for x in items])\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"order\": order_by.value,\n        \"text\": text,\n        \"types\": [types] if isinstance(types, PGType) else types,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.ParameterGroupCollection.update","title":"update","text":"<pre><code>update(\n    *, parameter_group: ParameterGroup\n) -&gt; ParameterGroup\n</code></pre> <p>Update a parameter group.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_group</code> <code>ParameterGroup</code> <p>The updated ParameterGroup. The ParameterGroup must have an ID.</p> required <p>Returns:</p> Type Description <code>ParameterGroup</code> <p>The updated ParameterGroup as returned by the server.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def update(self, *, parameter_group: ParameterGroup) -&gt; ParameterGroup:\n    \"\"\"Update a parameter group.\n\n    Parameters\n    ----------\n    parameter_group : ParameterGroup\n        The updated ParameterGroup. The ParameterGroup must have an ID.\n\n    Returns\n    -------\n    ParameterGroup\n        The updated ParameterGroup as returned by the server.\n    \"\"\"\n\n    existing = self.get_by_id(id=parameter_group.id)\n    path = f\"{self.base_path}/{existing.id}\"\n\n    payload = self._generate_patch_payload(existing=existing, updated=parameter_group)\n    # need to use a different payload for the special update parameters\n    payload = PGPatchPayload(\n        data=payload.data,\n    )\n\n    # Handle special update parameters\n    special_patches, special_enum_patches, new_param_patches = (\n        self._handle_special_update_parameters(existing=existing, updated=parameter_group)\n    )\n\n    payload.data.extend(special_patches)\n    if len(payload.data) &gt; 0:\n        self.session.patch(\n            path, json=payload.model_dump(mode=\"json\", by_alias=True, exclude_none=True)\n        )\n\n    # handle adding new parameters\n    if len(new_param_patches) &gt; 0:\n        self.session.put(\n            f\"{self.base_path}/{existing.id}/parameters\",\n            json={\"Parameters\": new_param_patches},\n        )\n    # Handle special enum update parameters\n    for sequence, enum_patches in special_enum_patches.items():\n        if len(enum_patches) == 0:\n            continue\n        enum_path = f\"{self.base_path}/{existing.id}/parameters/{sequence}/enums\"\n        self.session.put(enum_path, json=enum_patches)\n    return self.get_by_id(id=parameter_group.id)\n</code></pre>"},{"location":"albert/#albert.albert.PricingCollection","title":"PricingCollection","text":"<pre><code>PricingCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>PricingCollection is a collection class for managing Pricing entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Creates a new Pricing entity.</p> <code>delete</code> <p>Deletes a Pricing entity by its ID.</p> <code>get_by_id</code> <p>Retrieves a Pricing entity by its ID.</p> <code>get_by_inventory_id</code> <p>Returns a list of Pricing entities for the given inventory ID as per the provided parameters.</p> <code>get_by_inventory_ids</code> <p>Returns a list of Pricing resources for each parent inventory ID.</p> <code>update</code> <p>Updates a Pricing entity.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initializes the PricingCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{PricingCollection._api_version}/pricings\"\n</code></pre>"},{"location":"albert/#albert.albert.PricingCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/pricings'\n</code></pre>"},{"location":"albert/#albert.albert.PricingCollection.create","title":"create","text":"<pre><code>create(*, pricing: Pricing) -&gt; Pricing\n</code></pre> <p>Creates a new Pricing entity.</p> <p>Parameters:</p> Name Type Description Default <code>pricing</code> <code>Pricing</code> <p>The Pricing entity to create.</p> required <p>Returns:</p> Type Description <code>Pricing</code> <p>The created Pricing entity.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def create(self, *, pricing: Pricing) -&gt; Pricing:\n    \"\"\"Creates a new Pricing entity.\n\n    Parameters\n    ----------\n    pricing : Pricing\n        The Pricing entity to create.\n\n    Returns\n    -------\n    Pricing\n        The created Pricing entity.\n    \"\"\"\n    payload = pricing.model_dump(by_alias=True, exclude_none=True, mode=\"json\")\n    response = self.session.post(self.base_path, json=payload)\n    return Pricing(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.PricingCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a Pricing entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the Pricing entity to delete.</p> required Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Deletes a Pricing entity by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the Pricing entity to delete.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.PricingCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Pricing\n</code></pre> <p>Retrieves a Pricing entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the Pricing entity to retrieve.</p> required <p>Returns:</p> Type Description <code>Pricing</code> <p>The Pricing entity if found, None otherwise.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Pricing:\n    \"\"\"Retrieves a Pricing entity by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the Pricing entity to retrieve.\n\n    Returns\n    -------\n    Pricing\n        The Pricing entity if found, None otherwise.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return Pricing(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.PricingCollection.get_by_inventory_id","title":"get_by_inventory_id","text":"<pre><code>get_by_inventory_id(\n    *,\n    inventory_id: str,\n    group_by: PricingBy | None = None,\n    filter_by: PricingBy | None = None,\n    filter_id: str | None = None,\n    order_by: OrderBy | None = None,\n) -&gt; list[Pricing]\n</code></pre> <p>Returns a list of Pricing entities for the given inventory ID as per the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>str</code> <p>The ID of the inventory to retrieve pricings for.</p> required <code>group_by</code> <code>PricingBy | None</code> <p>Grouping by PricingBy, by default None</p> <code>None</code> <code>filter_by</code> <code>PricingBy | None</code> <p>Filter by PricingBy, by default None</p> <code>None</code> <code>filter_id</code> <code>str | None</code> <p>The string to use as the filter, by default None</p> <code>None</code> <code>order_by</code> <code>OrderBy | None</code> <p>The order to sort the results by, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Pricing]</code> <p>A list of Pricing entities matching the provided parameters.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def get_by_inventory_id(\n    self,\n    *,\n    inventory_id: str,\n    group_by: PricingBy | None = None,\n    filter_by: PricingBy | None = None,\n    filter_id: str | None = None,\n    order_by: OrderBy | None = None,\n) -&gt; list[Pricing]:\n    \"\"\"Returns a list of Pricing entities for the given inventory ID as per the provided parameters.\n\n    Parameters\n    ----------\n    inventory_id : str\n        The ID of the inventory to retrieve pricings for.\n    group_by : PricingBy | None, optional\n        Grouping by PricingBy, by default None\n    filter_by : PricingBy | None, optional\n        Filter by PricingBy, by default None\n    filter_id : str | None, optional\n        The string to use as the filter, by default None\n    order_by : OrderBy | None, optional\n        The order to sort the results by, by default None\n\n    Returns\n    -------\n    list[Pricing]\n        A list of Pricing entities matching the provided parameters.\n    \"\"\"\n    params = {\n        \"parentId\": inventory_id,\n        \"groupBy\": group_by,\n        \"filterBy\": filter_by,\n        \"id\": filter_id,\n        \"orderBy\": order_by,\n    }\n    params = {k: v for k, v in params.items() if v is not None}\n    response = self.session.get(self.base_path, params=params)\n    items = response.json().get(\"Items\", [])\n    return [Pricing(**x) for x in items]\n</code></pre>"},{"location":"albert/#albert.albert.PricingCollection.get_by_inventory_ids","title":"get_by_inventory_ids","text":"<pre><code>get_by_inventory_ids(\n    *, inventory_ids: list[InventoryId]\n) -&gt; list[InventoryPricings]\n</code></pre> <p>Returns a list of Pricing resources for each parent inventory ID.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_ids</code> <code>list[str]</code> <p>The list of inventory IDs to retrieve pricings for.</p> required <p>Returns:</p> Type Description <code>list[InventoryPricing]</code> <p>A list of InventoryPricing objects matching the provided inventory.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>@validate_call\ndef get_by_inventory_ids(self, *, inventory_ids: list[InventoryId]) -&gt; list[InventoryPricings]:\n    \"\"\"Returns a list of Pricing resources for each parent inventory ID.\n\n    Parameters\n    ----------\n    inventory_ids : list[str]\n        The list of inventory IDs to retrieve pricings for.\n\n    Returns\n    -------\n    list[InventoryPricing]\n        A list of InventoryPricing objects matching the provided inventory.\n    \"\"\"\n    params = {\"id\": inventory_ids}\n    response = self.session.get(f\"{self.base_path}/ids\", params=params)\n    return [InventoryPricings(**x) for x in response.json()[\"Items\"]]\n</code></pre>"},{"location":"albert/#albert.albert.PricingCollection.update","title":"update","text":"<pre><code>update(*, pricing: Pricing) -&gt; Pricing\n</code></pre> <p>Updates a Pricing entity.</p> <p>Parameters:</p> Name Type Description Default <code>pricing</code> <code>Pricing</code> <p>The updated Pricing entity.</p> required <p>Returns:</p> Type Description <code>Pricing</code> <p>The updated Pricing entity as it appears in Albert.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def update(self, *, pricing: Pricing) -&gt; Pricing:\n    \"\"\"Updates a Pricing entity.\n\n    Parameters\n    ----------\n    pricing : Pricing\n        The updated Pricing entity.\n\n    Returns\n    -------\n    Pricing\n        The updated Pricing entity as it appears in Albert.\n    \"\"\"\n    current_pricing = self.get_by_id(id=pricing.id)\n    patch_payload = self._pricing_patch_payload(existing=current_pricing, updated=pricing)\n    self.session.patch(\n        url=f\"{self.base_path}/{pricing.id}\",\n        json=patch_payload.model_dump(mode=\"json\", by_alias=True),\n    )\n    return self.get_by_id(id=pricing.id)\n</code></pre>"},{"location":"albert/#albert.albert.ProductDesignCollection","title":"ProductDesignCollection","text":"<pre><code>ProductDesignCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ProductDesignCollection is a collection class for managing Product Design entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>get_unpacked_products</code> <p>Get unpacked products by inventory IDs.</p> Source code in <code>src/albert/collections/product_design.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CasCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ProductDesignCollection._api_version}/productdesign\"\n</code></pre>"},{"location":"albert/#albert.albert.ProductDesignCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/productdesign'\n</code></pre>"},{"location":"albert/#albert.albert.ProductDesignCollection.get_unpacked_products","title":"get_unpacked_products","text":"<pre><code>get_unpacked_products(\n    *,\n    inventory_ids: list[InventoryId],\n    unpack_id: Literal[\n        \"DESIGN\", \"PREDICTION\"\n    ] = \"PREDICTION\",\n) -&gt; list[UnpackedProductDesign]\n</code></pre> <p>Get unpacked products by inventory IDs.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_ids</code> <code>list[InventoryId]</code> <p>The inventory ids to get unpacked formulas for.</p> required <code>unpack_id</code> <code>Literal['DESIGN', 'PREDICTION']</code> <p>The ID for the unpack operation.</p> <code>'PREDICTION'</code> <p>Returns:</p> Type Description <code>list[UnpackedProductDesign]</code> <p>The unpacked products/formulas.</p> Source code in <code>src/albert/collections/product_design.py</code> <pre><code>@validate_call\ndef get_unpacked_products(\n    self,\n    *,\n    inventory_ids: list[InventoryId],\n    unpack_id: Literal[\"DESIGN\", \"PREDICTION\"] = \"PREDICTION\",\n) -&gt; list[UnpackedProductDesign]:\n    \"\"\"\n    Get unpacked products by inventory IDs.\n\n    Parameters\n    ----------\n    inventory_ids : list[InventoryId]\n        The inventory ids to get unpacked formulas for.\n    unpack_id: Literal[\"DESIGN\", \"PREDICTION\"]\n        The ID for the unpack operation.\n\n    Returns\n    -------\n    list[UnpackedProductDesign]\n        The unpacked products/formulas.\n    \"\"\"\n    url = f\"{self.base_path}/{unpack_id}/unpack\"\n    batches = [inventory_ids[i : i + 50] for i in range(0, len(inventory_ids), 50)]\n    return [\n        UnpackedProductDesign(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"formulaId\": batch}).json()\n    ]\n</code></pre>"},{"location":"albert/#albert.albert.ProjectCollection","title":"ProjectCollection","text":"<pre><code>ProjectCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ProjectCollection is a collection class for managing Project entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new project.</p> <code>delete</code> <p>Delete a project by its ID.</p> <code>get_by_id</code> <p>Retrieve a project by its ID.</p> <code>list</code> <p>List projects with optional filters.</p> <code>update</code> <p>Update a project.</p> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initialize a ProjectCollection object.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ProjectCollection._api_version}/projects\"\n</code></pre>"},{"location":"albert/#albert.albert.ProjectCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/projects'\n</code></pre>"},{"location":"albert/#albert.albert.ProjectCollection.create","title":"create","text":"<pre><code>create(*, project: Project) -&gt; Project\n</code></pre> <p>Create a new project.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>The project to create.</p> required <p>Returns:</p> Type Description <code>Optional[Project]</code> <p>The created project object if successful, None otherwise.</p> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def create(self, *, project: Project) -&gt; Project:\n    \"\"\"\n    Create a new project.\n\n    Parameters\n    ----------\n    project : Project\n        The project to create.\n\n    Returns\n    -------\n    Optional[Project]\n        The created project object if successful, None otherwise.\n    \"\"\"\n    response = self.session.post(\n        self.base_path, json=project.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    )\n    return Project(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.ProjectCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a project by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the project to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Delete a project by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the project to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.ProjectCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Project\n</code></pre> <p>Retrieve a project by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the project to retrieve.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The project object if found</p> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Project:\n    \"\"\"\n    Retrieve a project by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the project to retrieve.\n\n    Returns\n    -------\n    Project\n        The project object if found\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n\n    return Project(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.ProjectCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    text: str = None,\n    status: list[str] = None,\n    market_segment: list[str] = None,\n    application: list[str] = None,\n    technology: list[str] = None,\n    created_by: list[str] = None,\n    location: list[str] = None,\n    from_created_at: str = None,\n    to_created_at: str = None,\n    facet_field: str = None,\n    facet_text: str = None,\n    contains_field: list[str] = None,\n    contains_text: list[str] = None,\n    linked_to: str = None,\n    my_projects: bool = None,\n    my_role: list[str] = None,\n    order_by: OrderBy = DESCENDING,\n    sort_by: str = None,\n    limit: int = 50,\n) -&gt; Iterator[Project]\n</code></pre> <p>List projects with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Search any test in the project.</p> <code>None</code> <code>status</code> <code>list[str]</code> <p>The status filter for the projects.</p> <code>None</code> <code>market_segment</code> <code>list[str]</code> <p>The market segment filter for the projects.</p> <code>None</code> <code>application</code> <code>list[str]</code> <p>The application filter for the projects.</p> <code>None</code> <code>technology</code> <code>list[str]</code> <p>The technology filter for the projects.</p> <code>None</code> <code>created_by</code> <code>list[str]</code> <p>The name of the user who created the project.</p> <code>None</code> <code>location</code> <code>list[str]</code> <p>The location filter for the projects.</p> <code>None</code> <code>from_created_at</code> <code>str</code> <p>The start date filter for the projects.</p> <code>None</code> <code>to_created_at</code> <code>str</code> <p>The end date filter for the projects.</p> <code>None</code> <code>facet_field</code> <code>str</code> <p>The facet field for the projects.</p> <code>None</code> <code>facet_text</code> <code>str</code> <p>The facet text for the projects.</p> <code>None</code> <code>contains_field</code> <code>list[str]</code> <p>To power project facets search</p> <code>None</code> <code>contains_text</code> <code>list[str]</code> <p>To power project facets search</p> <code>None</code> <code>linked_to</code> <code>str</code> <p>To pass text for linked to dropdown search in Task creation flow.</p> <code>None</code> <code>my_projects</code> <code>bool</code> <p>Return Projects owned by you.</p> <code>None</code> <code>my_role</code> <code>list[str]</code> <p>Filter Projects to ones which you have a specific role in.</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order in which to retrieve items (default is OrderBy.DESCENDING).</p> <code>DESCENDING</code> <code>sort_by</code> <code>str</code> <p>The field to sort by.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Project]</code> <p>An iterator of Project resources.</p> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def list(\n    self,\n    *,\n    text: str = None,\n    status: list[str] = None,\n    market_segment: list[str] = None,\n    application: list[str] = None,\n    technology: list[str] = None,\n    created_by: list[str] = None,\n    location: list[str] = None,\n    from_created_at: str = None,\n    to_created_at: str = None,\n    facet_field: str = None,\n    facet_text: str = None,\n    contains_field: list[str] = None,\n    contains_text: list[str] = None,\n    linked_to: str = None,\n    my_projects: bool = None,\n    my_role: list[str] = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    sort_by: str = None,\n    limit: int = 50,\n) -&gt; Iterator[Project]:\n    \"\"\"\n    List projects with optional filters.\n\n    Parameters\n    ----------\n    text : str, optional\n        Search any test in the project.\n    status : list[str], optional\n        The status filter for the projects.\n    market_segment : list[str], optional\n        The market segment filter for the projects.\n    application : list[str], optional\n        The application filter for the projects.\n    technology : list[str], optional\n        The technology filter for the projects.\n    created_by : list[str], optional\n        The name of the user who created the project.\n    location : list[str], optional\n        The location filter for the projects.\n    from_created_at : str, optional\n        The start date filter for the projects.\n    to_created_at : str, optional\n        The end date filter for the projects.\n    facet_field : str, optional\n        The facet field for the projects.\n    facet_text : str, optional\n        The facet text for the projects.\n    contains_field : list[str], optional\n        To power project facets search\n    contains_text : list[str], optional\n        To power project facets search\n    linked_to : str, optional\n        To pass text for linked to dropdown search in Task creation flow.\n    my_projects : bool, optional\n        Return Projects owned by you.\n    my_role : list[str], optional\n        Filter Projects to ones which you have a specific role in.\n    order_by : OrderBy, optional\n        The order in which to retrieve items (default is OrderBy.DESCENDING).\n    sort_by : str, optional\n        The field to sort by.\n\n    Returns\n    ------\n    Iterator[Project]\n        An iterator of Project resources.\n    \"\"\"\n    params = {\n        \"limit\": limit,\n        \"order\": order_by.value,\n        \"text\": text,\n        \"sortBy\": sort_by,\n        \"status\": status,\n        \"marketSegment\": market_segment,\n        \"application\": application,\n        \"technology\": technology,\n        \"createdBy\": created_by,\n        \"location\": location,\n        \"fromCreatedAt\": from_created_at,\n        \"toCreatedAt\": to_created_at,\n        \"facetField\": facet_field,\n        \"facetText\": facet_text,\n        \"containsField\": contains_field,\n        \"containsText\": contains_text,\n        \"linkedTo\": linked_to,\n        \"myProjects\": my_projects,\n        \"myRole\": my_role,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Project(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.ProjectCollection.update","title":"update","text":"<pre><code>update(*, project: Project) -&gt; Project\n</code></pre> <p>Update a project.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>The updated project object.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The updated project object as returned by the server.</p> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def update(self, *, project: Project) -&gt; Project:\n    \"\"\"Update a project.\n\n    Parameters\n    ----------\n    project : Project\n        The updated project object.\n\n    Returns\n    -------\n    Project\n        The updated project object as returned by the server.\n    \"\"\"\n    existing_project = self.get_by_id(id=project.id)\n    patch_data = self._generate_patch_payload(existing=existing_project, updated=project)\n    url = f\"{self.base_path}/{project.id}\"\n\n    self.session.patch(url, json=patch_data.model_dump(mode=\"json\", by_alias=True))\n\n    return self.get_by_id(id=project.id)\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection","title":"PropertyDataCollection","text":"<pre><code>PropertyDataCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>PropertyDataCollection is a collection class for managing Property Data entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>add_properties_to_inventory</code> <p>Add new properties to an inventory item.</p> <code>add_properties_to_task</code> <p>Add new task properties for a given task.</p> <code>bulk_delete_task_data</code> <p>Bulk delete task data for a given task.</p> <code>bulk_load_task_properties</code> <p>Bulk load task properties for a given task. WARNING: This will overwrite any existing properties!</p> <code>check_block_interval_for_data</code> <p>Check if a specific block interval has data.</p> <code>check_for_task_data</code> <p>Checks if a task has data.</p> <code>get_all_task_properties</code> <p>Returns all the properties for a specific task.</p> <code>get_properties_on_inventory</code> <p>Returns all the properties of an inventory item.</p> <code>get_task_block_properties</code> <p>Returns all the properties within a Property Task block for a specific inventory item.</p> <code>search</code> <p>Search for property data with various filtering options.</p> <code>update_or_create_task_properties</code> <p>Update or create task properties for a given task.</p> <code>update_property_on_inventory</code> <p>Update a property on an inventory item.</p> <code>update_property_on_task</code> <p>Updates a specific property on a task.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CompanyCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{PropertyDataCollection._api_version}/propertydata\"\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/propertydata'\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.add_properties_to_inventory","title":"add_properties_to_inventory","text":"<pre><code>add_properties_to_inventory(\n    *,\n    inventory_id: InventoryId,\n    properties: list[InventoryDataColumn],\n) -&gt; list[InventoryPropertyDataCreate]\n</code></pre> <p>Add new properties to an inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory item to add properties to.</p> required <code>properties</code> <code>list[InventoryDataColumn]</code> <p>The properties to add.</p> required <p>Returns:</p> Type Description <code>list[InventoryPropertyDataCreate]</code> <p>The registered properties.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef add_properties_to_inventory(\n    self, *, inventory_id: InventoryId, properties: list[InventoryDataColumn]\n) -&gt; list[InventoryPropertyDataCreate]:\n    \"\"\"Add new properties to an inventory item.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory item to add properties to.\n    properties : list[InventoryDataColumn]\n        The properties to add.\n\n    Returns\n    -------\n    list[InventoryPropertyDataCreate]\n        The registered properties.\n    \"\"\"\n    returned = []\n    for p in properties:\n        # Can only add one at a time.\n        create_object = InventoryPropertyDataCreate(\n            inventory_id=inventory_id, data_columns=[p]\n        )\n        response = self.session.post(\n            self.base_path,\n            json=create_object.model_dump(exclude_none=True, by_alias=True, mode=\"json\"),\n        )\n        response_json = response.json()\n        logger.info(response_json.get(\"message\", None))\n        returned.append(InventoryPropertyDataCreate(**response_json))\n    return returned\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.add_properties_to_task","title":"add_properties_to_task","text":"<pre><code>add_properties_to_task(\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n    properties: list[TaskPropertyCreate],\n)\n</code></pre> <p>Add new task properties for a given task.</p> <p>This method only works for new values. If a trial number is provided in the TaskPropertyCreate, it must relate to an existing trial. New trials must be added with no trial number provided. Do not try to create multiple new trials in one call as this will lead to unexpected behavior. Build out new trials in a loop if many new trials are needed.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory.</p> required <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>block_id</code> <code>BlockId</code> <p>The ID of the block.</p> required <code>lot_id</code> <code>LotId</code> <p>The ID of the lot, by default None.</p> <code>None</code> <code>properties</code> <code>list[TaskPropertyCreate]</code> <p>A list of TaskPropertyCreate objects representing the properties to add.</p> required <p>Returns:</p> Type Description <code>list[TaskPropertyData]</code> <p>The newly created task properties.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef add_properties_to_task(\n    self,\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n    properties: list[TaskPropertyCreate],\n):\n    \"\"\"\n    Add new task properties for a given task.\n\n    This method only works for new values. If a trial number is provided in the TaskPropertyCreate,\n    it must relate to an existing trial. New trials must be added with no trial number provided.\n    Do not try to create multiple new trials in one call as this will lead to unexpected behavior.\n    Build out new trials in a loop if many new trials are needed.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory.\n    task_id : TaskId\n        The ID of the task.\n    block_id : BlockId\n        The ID of the block.\n    lot_id : LotId, optional\n        The ID of the lot, by default None.\n    properties : list[TaskPropertyCreate]\n        A list of TaskPropertyCreate objects representing the properties to add.\n\n    Returns\n    -------\n    list[TaskPropertyData]\n        The newly created task properties.\n    \"\"\"\n    params = {\n        \"blockId\": block_id,\n        \"inventoryId\": inventory_id,\n        \"lotId\": lot_id,\n        \"autoCalculate\": \"true\",\n        \"history\": \"true\",\n    }\n    params = {k: v for k, v in params.items() if v is not None}\n    response = self.session.post(\n        url=f\"{self.base_path}/{task_id}\",\n        json=[x.model_dump(exclude_none=True, by_alias=True, mode=\"json\") for x in properties],\n        params=params,\n    )\n\n    registered_properties = [\n        TaskPropertyCreate(**x) for x in response.json() if \"DataTemplate\" in x\n    ]\n    existing_data_rows = self.get_task_block_properties(\n        inventory_id=inventory_id, task_id=task_id, block_id=block_id, lot_id=lot_id\n    )\n    patches = self._form_calculated_task_property_patches(\n        existing_data_rows=existing_data_rows, properties=registered_properties\n    )\n    if len(patches) &gt; 0:\n        return self.update_property_on_task(task_id=task_id, patch_payload=patches)\n    else:\n        return self.get_all_task_properties(task_id=task_id)\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.bulk_delete_task_data","title":"bulk_delete_task_data","text":"<pre><code>bulk_delete_task_data(\n    *,\n    task_id: TaskId,\n    block_id: BlockId,\n    inventory_id: InventoryId,\n    lot_id: LotId | None = None,\n    interval_id=None,\n) -&gt; None\n</code></pre> <p>Bulk delete task data for a given task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>block_id</code> <code>BlockId</code> <p>The ID of the block.</p> required <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory.</p> required <code>lot_id</code> <code>LotId</code> <p>The ID of the lot, by default None.</p> <code>None</code> <code>interval_id</code> <code>IntervalId</code> <p>The ID of the interval, by default None. If provided, will delete data for this specific interval.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>def bulk_delete_task_data(\n    self,\n    *,\n    task_id: TaskId,\n    block_id: BlockId,\n    inventory_id: InventoryId,\n    lot_id: LotId | None = None,\n    interval_id=None,\n) -&gt; None:\n    \"\"\"\n    Bulk delete task data for a given task.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task.\n    block_id : BlockId\n        The ID of the block.\n    inventory_id : InventoryId\n        The ID of the inventory.\n    lot_id : LotId, optional\n        The ID of the lot, by default None.\n    interval_id : IntervalId, optional\n        The ID of the interval, by default None. If provided, will delete data for this specific interval.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    params = {\n        \"inventoryId\": inventory_id,\n        \"blockId\": block_id,\n        \"lotId\": lot_id,\n        \"intervalRow\": interval_id if interval_id != \"default\" else None,\n    }\n    params = {k: v for k, v in params.items() if v is not None}\n    self.session.delete(f\"{self.base_path}/{task_id}\", params=params)\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.bulk_load_task_properties","title":"bulk_load_task_properties","text":"<pre><code>bulk_load_task_properties(\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    property_data: BulkPropertyData,\n    interval=\"default\",\n    lot_id: LotId = None,\n) -&gt; list[TaskPropertyData]\n</code></pre> <p>Bulk load task properties for a given task. WARNING: This will overwrite any existing properties! BulkPropertyData column names must exactly match the names of the data columns (Case Sensitive).</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory.</p> required <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>block_id</code> <code>BlockId</code> <p>The ID of the block.</p> required <code>lot_id</code> <code>LotId</code> <p>The ID of the lot, by default None.</p> <code>None</code> <code>interval</code> <code>str</code> <p>The interval to use for the properties, by default \"default\". Can be obtained using Workflow.get_interval_id().</p> <code>'default'</code> <code>property_data</code> <code>BulkPropertyData</code> <p>A list of columnwise data containing all your rows of data for a single interval. Can be created using BulkPropertyData.from_dataframe().</p> required <p>Returns:</p> Type Description <code>list[TaskPropertyData]</code> <p>The updated or newly created task properties.</p> Example <pre><code>from albert.resources.property_data import BulkPropertyData\n\ndata = BulkPropertyData.from_dataframe(df=my_dataframe)\nres = client.property_data.bulk_load_task_properties(\n    block_id=\"BLK1\",\n    inventory_id=\"INVEXP102748-042\",\n    property_data=data,\n    task_id=\"TASFOR291760\",\n)\n\n[TaskPropertyData(id=\"TASFOR291760\", ...)]\n</code></pre> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>def bulk_load_task_properties(\n    self,\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    property_data: BulkPropertyData,\n    interval=\"default\",\n    lot_id: LotId = None,\n) -&gt; list[TaskPropertyData]:\n    \"\"\"\n    Bulk load task properties for a given task. WARNING: This will overwrite any existing properties!\n    BulkPropertyData column names must exactly match the names of the data columns (Case Sensitive).\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory.\n    task_id : TaskId\n        The ID of the task.\n    block_id : BlockId\n        The ID of the block.\n    lot_id : LotId, optional\n        The ID of the lot, by default None.\n    interval : str, optional\n        The interval to use for the properties, by default \"default\". Can be obtained using Workflow.get_interval_id().\n    property_data : BulkPropertyData\n        A list of columnwise data containing all your rows of data for a single interval. Can be created using BulkPropertyData.from_dataframe().\n\n    Returns\n    -------\n    list[TaskPropertyData]\n        The updated or newly created task properties.\n\n    Example\n    -------\n\n    ```python\n    from albert.resources.property_data import BulkPropertyData\n\n    data = BulkPropertyData.from_dataframe(df=my_dataframe)\n    res = client.property_data.bulk_load_task_properties(\n        block_id=\"BLK1\",\n        inventory_id=\"INVEXP102748-042\",\n        property_data=data,\n        task_id=\"TASFOR291760\",\n    )\n\n    [TaskPropertyData(id=\"TASFOR291760\", ...)]\n    ```\n    \"\"\"\n    property_df = pd.DataFrame(\n        {x.data_column_name: x.data_series for x in property_data.columns}\n    )\n\n    def _get_column_map(dataframe: pd.DataFrame, property_data: TaskPropertyData):\n        data_col_info = property_data.data[0].trials[0].data_columns  # PropertyValue\n        column_map = {}\n        for col in dataframe.columns:\n            column = [x for x in data_col_info if x.name == col]\n            if len(column) == 1:\n                column_map[col] = column[0]\n            else:\n                raise ValueError(\n                    f\"Column '{col}' not found in block data columns or multiple matches found.\"\n                )\n        return column_map\n\n    def _df_to_task_prop_create_list(\n        dataframe: pd.DataFrame,\n        column_map: dict[str, PropertyValue],\n        data_template_id: DataTemplateId,\n    ) -&gt; list[TaskPropertyCreate]:\n        task_prop_create_list = []\n        for i, row in dataframe.iterrows():\n            for col_name, col_info in column_map.items():\n                if col_name not in dataframe.columns:\n                    raise ValueError(f\"Column '{col_name}' not found in DataFrame.\")\n\n                task_prop_create = TaskPropertyCreate(\n                    data_column=TaskDataColumn(\n                        data_column_id=col_info.id,\n                        column_sequence=col_info.sequence,\n                    ),\n                    value=str(row[col_name]),\n                    visible_trial_number=i + 1,\n                    interval_combination=interval,\n                    data_template=EntityLink(id=data_template_id),\n                )\n                task_prop_create_list.append(task_prop_create)\n        return task_prop_create_list\n\n    task_prop_data = self.get_task_block_properties(\n        inventory_id=inventory_id, task_id=task_id, block_id=block_id, lot_id=lot_id\n    )\n    column_map = _get_column_map(property_df, task_prop_data)\n    all_task_prop_create = _df_to_task_prop_create_list(\n        dataframe=property_df,\n        column_map=column_map,\n        data_template_id=task_prop_data.data_template.id,\n    )\n    with suppress(NotFoundError):\n        # This is expected if the task is new and has no data yet.\n        self.bulk_delete_task_data(\n            task_id=task_id,\n            block_id=block_id,\n            inventory_id=inventory_id,\n            lot_id=lot_id,\n            interval_id=interval,\n        )\n    return self.add_properties_to_task(\n        inventory_id=inventory_id,\n        task_id=task_id,\n        block_id=block_id,\n        lot_id=lot_id,\n        properties=all_task_prop_create,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.check_block_interval_for_data","title":"check_block_interval_for_data","text":"<pre><code>check_block_interval_for_data(\n    *,\n    block_id: BlockId,\n    task_id: TaskId,\n    interval_id: IntervalId,\n) -&gt; CheckPropertyData\n</code></pre> <p>Check if a specific block interval has data.</p> <p>Parameters:</p> Name Type Description Default <code>block_id</code> <code>BlockId</code> <p>The ID of the block.</p> required <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>interval_id</code> <code>IntervalId</code> <p>The ID of the interval.</p> required <p>Returns:</p> Type Description <code>CheckPropertyData</code> <p>description</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef check_block_interval_for_data(\n    self, *, block_id: BlockId, task_id: TaskId, interval_id: IntervalId\n) -&gt; CheckPropertyData:\n    \"\"\"Check if a specific block interval has data.\n\n    Parameters\n    ----------\n    block_id : BlockId\n        The ID of the block.\n    task_id : TaskId\n        The ID of the task.\n    interval_id : IntervalId\n        The ID of the interval.\n\n    Returns\n    -------\n    CheckPropertyData\n        _description_\n    \"\"\"\n    params = {\n        \"entity\": \"block\",\n        \"action\": \"checkdata\",\n        \"id\": block_id,\n        \"parentId\": task_id,\n        \"intervalId\": interval_id,\n    }\n\n    response = self.session.get(url=self.base_path, params=params)\n    return CheckPropertyData(response.json())\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.check_for_task_data","title":"check_for_task_data","text":"<pre><code>check_for_task_data(\n    *, task_id: TaskId\n) -&gt; list[CheckPropertyData]\n</code></pre> <p>Checks if a task has data.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task to check for data.</p> required <p>Returns:</p> Type Description <code>list[CheckPropertyData]</code> <p>A list of CheckPropertyData objects representing the data status of each block + inventory item of the task.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef check_for_task_data(self, *, task_id: TaskId) -&gt; list[CheckPropertyData]:\n    \"\"\"Checks if a task has data.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task to check for data.\n\n    Returns\n    -------\n    list[CheckPropertyData]\n        A list of CheckPropertyData objects representing the data status of each block + inventory item of the task.\n    \"\"\"\n    task_info = self._get_task_from_id(id=task_id)\n\n    params = {\n        \"entity\": \"block\",\n        \"action\": \"checkdata\",\n        \"parentId\": task_id,\n        \"id\": [x.id for x in task_info.blocks],\n    }\n\n    response = self.session.get(url=self.base_path, params=params)\n    return [CheckPropertyData(**x) for x in response.json()]\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.get_all_task_properties","title":"get_all_task_properties","text":"<pre><code>get_all_task_properties(\n    *, task_id: TaskId\n) -&gt; list[TaskPropertyData]\n</code></pre> <p>Returns all the properties for a specific task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task to retrieve properties for.</p> required <p>Returns:</p> Type Description <code>list[TaskPropertyData]</code> <p>A list of TaskPropertyData objects representing the properties within the task.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef get_all_task_properties(self, *, task_id: TaskId) -&gt; list[TaskPropertyData]:\n    \"\"\"Returns all the properties for a specific task.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task to retrieve properties for.\n\n    Returns\n    -------\n    list[TaskPropertyData]\n        A list of TaskPropertyData objects representing the properties within the task.\n    \"\"\"\n    all_info = []\n    task_data_info = self.check_for_task_data(task_id=task_id)\n    for combo_info in task_data_info:\n        all_info.append(\n            self.get_task_block_properties(\n                inventory_id=combo_info.inventory_id,\n                task_id=task_id,\n                block_id=combo_info.block_id,\n                lot_id=combo_info.lot_id,\n            )\n        )\n\n    return all_info\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.get_properties_on_inventory","title":"get_properties_on_inventory","text":"<pre><code>get_properties_on_inventory(\n    *, inventory_id: InventoryId\n) -&gt; InventoryPropertyData\n</code></pre> <p>Returns all the properties of an inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory item to retrieve properties for.</p> required <p>Returns:</p> Type Description <code>InventoryPropertyData</code> <p>The properties of the inventory item.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef get_properties_on_inventory(self, *, inventory_id: InventoryId) -&gt; InventoryPropertyData:\n    \"\"\"Returns all the properties of an inventory item.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory item to retrieve properties for.\n\n    Returns\n    -------\n    InventoryPropertyData\n        The properties of the inventory item.\n    \"\"\"\n    params = {\"entity\": \"inventory\", \"id\": [inventory_id]}\n    response = self.session.get(url=self.base_path, params=params)\n    response_json = response.json()\n    return InventoryPropertyData(**response_json[0])\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.get_task_block_properties","title":"get_task_block_properties","text":"<pre><code>get_task_block_properties(\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n) -&gt; TaskPropertyData\n</code></pre> <p>Returns all the properties within a Property Task block for a specific inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory.</p> required <code>task_id</code> <code>TaskId</code> <p>The Property task ID.</p> required <code>block_id</code> <code>BlockId</code> <p>The Block ID of the block to retrieve properties for.</p> required <code>lot_id</code> <code>LotId | None</code> <p>The specific Lot of the inventory Item to retrieve lots for, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskPropertyData</code> <p>The properties of the inventory item within the block.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef get_task_block_properties(\n    self,\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n) -&gt; TaskPropertyData:\n    \"\"\"Returns all the properties within a Property Task block for a specific inventory item.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory.\n    task_id : TaskId\n        The Property task ID.\n    block_id : BlockId\n        The Block ID of the block to retrieve properties for.\n    lot_id : LotId | None, optional\n        The specific Lot of the inventory Item to retrieve lots for, by default None\n\n    Returns\n    -------\n    TaskPropertyData\n        The properties of the inventory item within the block.\n    \"\"\"\n    params = {\n        \"entity\": \"task\",\n        \"blockId\": block_id,\n        \"id\": task_id,\n        \"inventoryId\": inventory_id,\n        \"lotId\": lot_id,\n    }\n    params = {k: v for k, v in params.items() if v is not None}\n\n    response = self.session.get(url=self.base_path, params=params)\n    response_json = response.json()\n    return TaskPropertyData(**response_json[0])\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.search","title":"search","text":"<pre><code>search(\n    *,\n    limit: int = 100,\n    result: str | None = None,\n    text: str | None = None,\n    order: OrderBy | None = None,\n    sort_by: str | None = None,\n    inventory_ids: list[SearchInventoryId]\n    | SearchInventoryId\n    | None = None,\n    project_ids: list[SearchProjectId]\n    | SearchProjectId\n    | None = None,\n    lot_ids: list[LotId] | LotId | None = None,\n    data_template_ids: DataTemplateId\n    | list[DataTemplateId]\n    | None = None,\n    data_column_ids: DataColumnId\n    | list[DataColumnId]\n    | None = None,\n    category: list[DataEntity] | DataEntity | None = None,\n    data_templates: list[str] | str | None = None,\n    data_columns: list[str] | str | None = None,\n    parameters: list[str] | str | None = None,\n    parameter_group: list[str] | str | None = None,\n    unit: list[str] | str | None = None,\n    created_by: list[UserId] | UserId | None = None,\n    task_created_by: list[UserId] | UserId | None = None,\n    return_fields: list[str] | str | None = None,\n    return_facets: list[str] | str | None = None,\n) -&gt; Iterator[PropertyDataSearchItem]\n</code></pre> <p>Search for property data with various filtering options.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>100</code> <code>result</code> <code>str</code> <p>Find results using search syntax. e.g. to find all results with viscosity &lt; 200 at a temperature of 25 we would do result=viscosity(&lt;200)@temperature(25)</p> <code>None</code> <code>text</code> <code>str</code> <p>Free text search across all searchable fields.</p> <code>None</code> <code>order</code> <code>OrderBy</code> <p>Sort order (ascending/descending).</p> <code>None</code> <code>sort_by</code> <code>str</code> <p>Field to sort results by.</p> <code>None</code> <code>inventory_ids</code> <code>SearchInventoryIdType or list of SearchInventoryIdType</code> <p>Filter by inventory IDs.</p> <code>None</code> <code>project_ids</code> <code>ProjectIdType or list of ProjectIdType</code> <p>Filter by project IDs.</p> <code>None</code> <code>lot_ids</code> <code>LotIdType or list of LotIdType</code> <p>Filter by lot IDs.</p> <code>None</code> <code>data_template_ids</code> <code>DataTemplateId or list of DataTemplateId</code> <p>Filter by data template IDs.</p> <code>None</code> <code>data_column_ids</code> <code>DataColumnId | list[DataColumnId] | None</code> <p>Filter by data column IDs.</p> <code>None</code> <code>category</code> <code>DataEntity or list of DataEntity</code> <p>Filter by data entity categories.</p> <code>None</code> <code>data_templates</code> <code>str or list of str (exact match)</code> <p>Filter by data template names.</p> <code>None</code> <code>data_columns</code> <code>str or list of str (exact match)</code> <p>Filter by data column names (currently non-functional).</p> <code>None</code> <code>parameters</code> <code>str or list of str (exact match)</code> <p>Filter by parameter names.</p> <code>None</code> <code>parameter_group</code> <code>str or list of str (exact match)</code> <p>Filter by parameter group names.</p> <code>None</code> <code>unit</code> <code>str or list of str (exact match)</code> <p>Filter by unit names.</p> <code>None</code> <code>created_by</code> <code>UserIdType or list of UserIdType</code> <p>Filter by creator user IDs.</p> <code>None</code> <code>task_created_by</code> <code>UserIdType or list of UserIdType</code> <p>Filter by task creator user IDs.</p> <code>None</code> <code>return_fields</code> <code>str or list of str</code> <p>Specific fields to include in results. If None, returns all fields.</p> <code>None</code> <code>return_facets</code> <code>str or list of str</code> <p>Specific facets to include in results.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Search results matching the specified criteria.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef search(\n    self,\n    *,\n    limit: int = 100,\n    result: str | None = None,\n    text: str | None = None,\n    # Sorting/pagination\n    order: OrderBy | None = None,\n    sort_by: str | None = None,\n    # Core platform identifiers\n    inventory_ids: list[SearchInventoryId] | SearchInventoryId | None = None,\n    project_ids: list[SearchProjectId] | SearchProjectId | None = None,\n    lot_ids: list[LotId] | LotId | None = None,\n    data_template_ids: DataTemplateId | list[DataTemplateId] | None = None,\n    data_column_ids: DataColumnId | list[DataColumnId] | None = None,\n    # Data structure filters\n    category: list[DataEntity] | DataEntity | None = None,\n    data_templates: list[str] | str | None = None,\n    data_columns: list[str] | str | None = None,\n    # Data content filters\n    parameters: list[str] | str | None = None,\n    parameter_group: list[str] | str | None = None,\n    unit: list[str] | str | None = None,\n    # User filters\n    created_by: list[UserId] | UserId | None = None,\n    task_created_by: list[UserId] | UserId | None = None,\n    # Response customization\n    return_fields: list[str] | str | None = None,\n    return_facets: list[str] | str | None = None,\n) -&gt; Iterator[PropertyDataSearchItem]:\n    \"\"\"Search for property data with various filtering options.\n\n    Parameters\n    ----------\n    limit : int, default=100\n        Maximum number of results to return.\n    result : str, optional\n        Find results using search syntax. e.g. to find all results with viscosity &lt; 200 at a temperature of 25 we would do\n        result=viscosity(&lt;200)@temperature(25)\n    text : str, optional\n        Free text search across all searchable fields.\n    order : OrderBy, optional\n        Sort order (ascending/descending).\n    sort_by : str, optional\n        Field to sort results by.\n    inventory_ids : SearchInventoryIdType or list of SearchInventoryIdType, optional\n        Filter by inventory IDs.\n    project_ids : ProjectIdType or list of ProjectIdType, optional\n        Filter by project IDs.\n    lot_ids : LotIdType or list of LotIdType, optional\n        Filter by lot IDs.\n    data_template_ids : DataTemplateId or list of DataTemplateId, optional\n        Filter by data template IDs.\n    data_column_ids: DataColumnId or list of DataColumnId, optional\n        Filter by data column IDs.\n    category : DataEntity or list of DataEntity, optional\n        Filter by data entity categories.\n    data_templates : str or list of str (exact match), optional\n        Filter by data template names.\n    data_columns : str or list of str (exact match), optional\n        Filter by data column names (currently non-functional).\n    parameters : str or list of str (exact match), optional\n        Filter by parameter names.\n    parameter_group : str or list of str (exact match), optional\n        Filter by parameter group names.\n    unit : str or list of str (exact match), optional\n        Filter by unit names.\n    created_by : UserIdType or list of UserIdType, optional\n        Filter by creator user IDs.\n    task_created_by : UserIdType or list of UserIdType, optional\n        Filter by task creator user IDs.\n    return_fields : str or list of str, optional\n        Specific fields to include in results. If None, returns all fields.\n    return_facets : str or list of str, optional\n        Specific facets to include in results.\n\n    Returns\n    -------\n    dict\n        Search results matching the specified criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; list[PropertyDataSearchItem]:\n        return [PropertyDataSearchItem.model_validate(x) for x in items]\n\n    if isinstance(inventory_ids, str):\n        inventory_ids = [inventory_ids]\n    if isinstance(project_ids, str):\n        project_ids = [project_ids]\n    if isinstance(lot_ids, str):\n        lot_ids = [lot_ids]\n    if isinstance(data_template_ids, str):\n        data_template_ids = [data_template_ids]\n    if isinstance(data_column_ids, str):\n        data_column_ids = [data_column_ids]\n    if isinstance(category, DataEntity):\n        category = [category]\n    if isinstance(data_templates, str):\n        data_templates = [data_templates]\n    if isinstance(data_columns, str):\n        data_columns = [data_columns]\n    if isinstance(parameters, str):\n        parameters = [parameters]\n    if isinstance(parameter_group, str):\n        parameter_group = [parameter_group]\n    if isinstance(unit, str):\n        unit = [unit]\n    if isinstance(created_by, str):\n        created_by = [created_by]\n    if isinstance(task_created_by, str):\n        task_created_by = [task_created_by]\n    if isinstance(return_fields, str):\n        return_fields = [return_fields]\n    if isinstance(return_facets, str):\n        return_facets = [return_facets]\n\n    params = {\n        \"limit\": limit,\n        \"result\": result,\n        \"text\": text,\n        \"order\": order.value if order is not None else None,\n        \"sortBy\": sort_by,\n        \"inventoryIds\": inventory_ids if inventory_ids is not None else None,\n        \"projectIds\": project_ids if project_ids is not None else None,\n        \"lotIds\": lot_ids if lot_ids is not None else None,\n        \"dataTemplateId\": data_template_ids if data_template_ids is not None else None,\n        \"dataColumnId\": data_column_ids if data_column_ids is not None else None,\n        \"category\": [c.value for c in category] if category is not None else None,\n        \"dataTemplates\": data_templates,\n        \"dataColumns\": data_columns,\n        \"parameters\": parameters,\n        \"parameterGroup\": parameter_group,\n        \"unit\": unit,\n        \"createdBy\": created_by if created_by is not None else None,\n        \"taskCreatedBy\": task_created_by if task_created_by is not None else None,\n        \"returnFields\": return_fields,\n        \"returnFacets\": return_facets,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        params=params,\n        session=self.session,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.update_or_create_task_properties","title":"update_or_create_task_properties","text":"<pre><code>update_or_create_task_properties(\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n    properties: list[TaskPropertyCreate],\n) -&gt; list[TaskPropertyData]\n</code></pre> <p>Update or create task properties for a given task.</p> <p>If a trial number is provided in the TaskPropertyCreate, it must relate to an existing trial. New trials must be added with no trial number provided. Do not try to create multiple new trials in one call as this will lead to unexpected behavior. Build out new trials in a loop if many new trials are needed.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory.</p> required <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>block_id</code> <code>BlockId</code> <p>The ID of the block.</p> required <code>lot_id</code> <code>LotId</code> <p>The ID of the lot, by default None.</p> <code>None</code> <code>properties</code> <code>list[TaskPropertyCreate]</code> <p>A list of TaskPropertyCreate objects representing the properties to update or create.</p> required <p>Returns:</p> Type Description <code>list[TaskPropertyData]</code> <p>The updated or newly created task properties.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef update_or_create_task_properties(\n    self,\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n    properties: list[TaskPropertyCreate],\n) -&gt; list[TaskPropertyData]:\n    \"\"\"\n    Update or create task properties for a given task.\n\n    If a trial number is provided in the TaskPropertyCreate, it must relate to an existing trial.\n    New trials must be added with no trial number provided. Do not try to create multiple new trials\n    in one call as this will lead to unexpected behavior. Build out new trials in a loop if many new\n    trials are needed.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory.\n    task_id : TaskId\n        The ID of the task.\n    block_id : BlockId\n        The ID of the block.\n    lot_id : LotId, optional\n        The ID of the lot, by default None.\n    properties : list[TaskPropertyCreate]\n        A list of TaskPropertyCreate objects representing the properties to update or create.\n\n    Returns\n    -------\n    list[TaskPropertyData]\n        The updated or newly created task properties.\n\n    \"\"\"\n    existing_data_rows = self.get_task_block_properties(\n        inventory_id=inventory_id, task_id=task_id, block_id=block_id, lot_id=lot_id\n    )\n    update_patches, new_values = self._form_existing_row_value_patches(\n        existing_data_rows=existing_data_rows, properties=properties\n    )\n\n    calculated_patches = self._form_calculated_task_property_patches(\n        existing_data_rows=existing_data_rows, properties=properties\n    )\n    all_patches = update_patches + calculated_patches\n    if len(new_values) &gt; 0:\n        self.update_property_on_task(task_id=task_id, patch_payload=all_patches)\n        return self.add_properties_to_task(\n            inventory_id=inventory_id,\n            task_id=task_id,\n            block_id=block_id,\n            lot_id=lot_id,\n            properties=new_values,\n        )\n    else:\n        return self.update_property_on_task(task_id=task_id, patch_payload=all_patches)\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.update_property_on_inventory","title":"update_property_on_inventory","text":"<pre><code>update_property_on_inventory(\n    *,\n    inventory_id: InventoryId,\n    property_data: InventoryDataColumn,\n) -&gt; InventoryPropertyData\n</code></pre> <p>Update a property on an inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory item to update the property on.</p> required <code>property_data</code> <code>InventoryDataColumn</code> <p>The updated property data.</p> required <p>Returns:</p> Type Description <code>InventoryPropertyData</code> <p>The updated property data as returned by the server.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef update_property_on_inventory(\n    self, *, inventory_id: InventoryId, property_data: InventoryDataColumn\n) -&gt; InventoryPropertyData:\n    \"\"\"Update a property on an inventory item.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory item to update the property on.\n    property_data : InventoryDataColumn\n        The updated property data.\n\n    Returns\n    -------\n    InventoryPropertyData\n        The updated property data as returned by the server.\n    \"\"\"\n    existing_properties = self.get_properties_on_inventory(inventory_id=inventory_id)\n    existing_value = None\n    for p in existing_properties.custom_property_data:\n        if p.data_column.data_column_id == property_data.data_column_id:\n            existing_value = (\n                p.data_column.property_data.value\n                if p.data_column.property_data.value is not None\n                else p.data_column.property_data.string_value\n                if p.data_column.property_data.string_value is not None\n                else str(p.data_column.property_data.numeric_value)\n                if p.data_column.property_data.numeric_value is not None\n                else None\n            )\n            existing_id = p.data_column.property_data.id\n            break\n    if existing_value is not None:\n        payload = [\n            PropertyDataPatchDatum(\n                operation=PatchOperation.UPDATE,\n                id=existing_id,\n                attribute=\"value\",\n                new_value=property_data.value,\n                old_value=existing_value,\n            )\n        ]\n    else:\n        payload = [\n            PropertyDataPatchDatum(\n                operation=PatchOperation.ADD,\n                id=existing_id,\n                attribute=\"value\",\n                new_value=property_data.value,\n            )\n        ]\n\n    self.session.patch(\n        url=f\"{self.base_path}/{inventory_id}\",\n        json=[x.model_dump(exclude_none=True, by_alias=True, mode=\"json\") for x in payload],\n    )\n    return self.get_properties_on_inventory(inventory_id=inventory_id)\n</code></pre>"},{"location":"albert/#albert.albert.PropertyDataCollection.update_property_on_task","title":"update_property_on_task","text":"<pre><code>update_property_on_task(\n    *,\n    task_id: TaskId,\n    patch_payload: list[PropertyDataPatchDatum],\n) -&gt; list[TaskPropertyData]\n</code></pre> <p>Updates a specific property on a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>patch_payload</code> <code>list[PropertyDataPatchDatum]</code> <p>The specific patch to make to update the property.</p> required <p>Returns:</p> Type Description <code>list[TaskPropertyData]</code> <p>A list of TaskPropertyData objects representing the properties within the task.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef update_property_on_task(\n    self, *, task_id: TaskId, patch_payload: list[PropertyDataPatchDatum]\n) -&gt; list[TaskPropertyData]:\n    \"\"\"Updates a specific property on a task.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task.\n    patch_payload : list[PropertyDataPatchDatum]\n        The specific patch to make to update the property.\n\n    Returns\n    -------\n    list[TaskPropertyData]\n        A list of TaskPropertyData objects representing the properties within the task.\n    \"\"\"\n    if len(patch_payload) &gt; 0:\n        self.session.patch(\n            url=f\"{self.base_path}/{task_id}\",\n            json=[\n                x.model_dump(exclude_none=True, by_alias=True, mode=\"json\")\n                for x in patch_payload\n            ],\n        )\n    return self.get_all_task_properties(task_id=task_id)\n</code></pre>"},{"location":"albert/#albert.albert.ReportCollection","title":"ReportCollection","text":"<pre><code>ReportCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ReportCollection is a collection class for managing Report entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>get_datascience_report</code> <p>Get a datascience report by its report type ID.</p> Source code in <code>src/albert/collections/reports.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the ReportCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ReportCollection._api_version}/reports\"\n</code></pre>"},{"location":"albert/#albert.albert.ReportCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/reports'\n</code></pre>"},{"location":"albert/#albert.albert.ReportCollection.get_datascience_report","title":"get_datascience_report","text":"<pre><code>get_datascience_report(\n    *,\n    report_type_id: str,\n    input_data: dict[str, Any] | None = None,\n) -&gt; ReportInfo\n</code></pre> <p>Get a datascience report by its report type ID.</p> <p>Parameters:</p> Name Type Description Default <code>report_type_id</code> <code>str</code> <p>The report type ID for the report.</p> required <code>input_data</code> <code>dict[str, Any] | None</code> <p>Additional input data for generating the report (e.g., project IDs and unique IDs).</p> <code>None</code> <p>Returns:</p> Type Description <code>ReportInfo</code> <p>The info for the report.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; report = client.reports.get_datascience_report(\n...     report_type_id=\"RET51\",\n...     input_data={\n...         \"projectId\": [\"PRO123\"],\n...         \"uniqueId\": [\"DAT123_DAC123\"]\n...     }\n... )\n</code></pre> Source code in <code>src/albert/collections/reports.py</code> <pre><code>def get_datascience_report(\n    self,\n    *,\n    report_type_id: str,\n    input_data: dict[str, Any] | None = None,\n) -&gt; ReportInfo:\n    \"\"\"Get a datascience report by its report type ID.\n\n    Parameters\n    ----------\n    report_type_id : str\n        The report type ID for the report.\n    input_data : dict[str, Any] | None\n        Additional input data for generating the report\n        (e.g., project IDs and unique IDs).\n\n    Returns\n    -------\n    ReportInfo\n        The info for the report.\n\n    Examples\n    --------\n    &gt;&gt;&gt; report = client.reports.get_datascience_report(\n    ...     report_type_id=\"RET51\",\n    ...     input_data={\n    ...         \"projectId\": [\"PRO123\"],\n    ...         \"uniqueId\": [\"DAT123_DAC123\"]\n    ...     }\n    ... )\n    \"\"\"\n    path = f\"{self.base_path}/datascience/{report_type_id}\"\n\n    params = {}\n    input_data = input_data or {}\n    for key, value in input_data.items():\n        params[f\"inputData[{key}]\"] = value\n\n    response = self.session.get(path, params=params)\n    return ReportInfo(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.RoleCollection","title":"RoleCollection","text":"<pre><code>RoleCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>RoleCollection is a collection class for managing Role entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>list</code> <p>Lists the available Roles</p> Source code in <code>src/albert/collections/roles.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the RoleCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{RoleCollection._api_version}/acl/roles\"\n</code></pre>"},{"location":"albert/#albert.albert.RoleCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/acl/roles'\n</code></pre>"},{"location":"albert/#albert.albert.RoleCollection.list","title":"list","text":"<pre><code>list(*, params: dict | None = None) -&gt; list[Role]\n</code></pre> <p>Lists the available Roles</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>description, by default {}</p> <code>None</code> <p>Returns:</p> Type Description <code>List</code> <p>List of available Roles</p> Source code in <code>src/albert/collections/roles.py</code> <pre><code>def list(self, *, params: dict | None = None) -&gt; list[Role]:\n    \"\"\"Lists the available Roles\n\n    Parameters\n    ----------\n    params : dict, optional\n        _description_, by default {}\n\n    Returns\n    -------\n    List\n        List of available Roles\n    \"\"\"\n    if params is None:\n        params = {}\n    response = self.session.get(self.base_path, params=params)\n    role_data = response.json().get(\"Items\", [])\n    return [Role(**r) for r in role_data]\n</code></pre>"},{"location":"albert/#albert.albert.StorageLocationsCollection","title":"StorageLocationsCollection","text":"<pre><code>StorageLocationsCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>StorageLocationsCollection is a collection class for managing StorageLoction entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert Session information</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new storage location.</p> <code>delete</code> <p>Delete a storage location by its ID.</p> <code>get_by_id</code> <p>Get a storage location by its ID.</p> <code>list</code> <p>List storage locations with optional filtering.</p> <code>update</code> <p>Update a storage location.</p> Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initialize the StorageLocationsCollection.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert Session information\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{StorageLocationsCollection._api_version}/storagelocations\"\n</code></pre>"},{"location":"albert/#albert.albert.StorageLocationsCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/storagelocations'\n</code></pre>"},{"location":"albert/#albert.albert.StorageLocationsCollection.create","title":"create","text":"<pre><code>create(\n    *, storage_location: StorageLocation\n) -&gt; StorageLocation\n</code></pre> <p>Create a new storage location.</p> <p>Parameters:</p> Name Type Description Default <code>storage_location</code> <code>StorageLocation</code> <p>The storage location to create.</p> required <p>Returns:</p> Type Description <code>StorageLocation</code> <p>The created storage location.</p> Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def create(self, *, storage_location: StorageLocation) -&gt; StorageLocation:\n    \"\"\"Create a new storage location.\n\n    Parameters\n    ----------\n    storage_location : StorageLocation\n        The storage location to create.\n\n    Returns\n    -------\n    StorageLocation\n        The created storage location.\n    \"\"\"\n    matching = self.list(\n        name=storage_location.name, location=storage_location.location, exact_match=True\n    )\n    for m in matching:\n        if m.name.lower() == storage_location.name.lower():\n            logging.warning(\n                f\"Storage location with name {storage_location.name} already exists, returning existing.\"\n            )\n            return m\n\n    path = self.base_path\n    response = self.session.post(\n        path, json=storage_location.model_dump(by_alias=True, exclude_none=True, mode=\"json\")\n    )\n    return StorageLocation(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.StorageLocationsCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a storage location by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the storage location to delete.</p> required Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a storage location by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the storage location to delete.\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    self.session.delete(path)\n</code></pre>"},{"location":"albert/#albert.albert.StorageLocationsCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; StorageLocation\n</code></pre> <p>Get a storage location by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the storage location to retrieve.</p> required <p>Returns:</p> Type Description <code>StorageLocation</code> <p>The retrieved storage location with the given ID.</p> Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; StorageLocation:\n    \"\"\"Get a storage location by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the storage location to retrieve.\n\n    Returns\n    -------\n    StorageLocation\n        The retrieved storage location with the given ID.\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    response = self.session.get(path)\n    return StorageLocation(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.StorageLocationsCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    name: str | list[str] | None = None,\n    exact_match: bool = False,\n    location: str | Location | None = None,\n    start_key: str | None = None,\n    limit: int = 50,\n) -&gt; Generator[StorageLocation, None, None]\n</code></pre> <p>List storage locations with optional filtering.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | list[str] | None</code> <p>The name or names of the storage locations to filter by, by default None</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to perform an exact match on the name, by default False</p> <code>False</code> <code>location</code> <code>str | Location | None</code> <p>The location ID or Location object to filter by, by default None</p> <code>None</code> <p>Yields:</p> Type Description <code>Generator[StorageLocation, None, None]</code> <p>description</p> Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def list(\n    self,\n    *,\n    name: str | list[str] | None = None,\n    exact_match: bool = False,\n    location: str | Location | None = None,\n    start_key: str | None = None,\n    limit: int = 50,\n) -&gt; Generator[StorageLocation, None, None]:\n    \"\"\"List storage locations with optional filtering.\n\n    Parameters\n    ----------\n    name : str | list[str] | None, optional\n        The name or names of the storage locations to filter by, by default None\n    exact_match : bool, optional\n        Whether to perform an exact match on the name, by default False\n    location : str | Location | None, optional\n        The location ID or Location object to filter by, by default None\n\n    Yields\n    ------\n    Generator[StorageLocation, None, None]\n        _description_\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[StorageLocation]:\n        for x in items:\n            id = x[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching storage location {id}: {e}\")\n\n    params = {\n        \"limit\": limit,\n        \"locationId\": location.id if isinstance(location, Location | EntityLink) else location,\n        \"startKey\": start_key,\n    }\n    if name:\n        params[\"name\"] = [name] if isinstance(name, str) else name\n        params[\"exactMatch\"] = json.dumps(exact_match)\n\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.StorageLocationsCollection.update","title":"update","text":"<pre><code>update(\n    *, storage_location: StorageLocation\n) -&gt; StorageLocation\n</code></pre> <p>Update a storage location.</p> <p>Parameters:</p> Name Type Description Default <code>storage_location</code> <code>StorageLocation</code> <p>The storage location to update.</p> required <p>Returns:</p> Type Description <code>StorageLocation</code> <p>The updated storage location as returned by the server.</p> Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def update(self, *, storage_location: StorageLocation) -&gt; StorageLocation:\n    \"\"\"Update a storage location.\n\n    Parameters\n    ----------\n    storage_location : StorageLocation\n        The storage location to update.\n\n    Returns\n    -------\n    StorageLocation\n        The updated storage location as returned by the server.\n    \"\"\"\n    path = f\"{self.base_path}/{storage_location.id}\"\n    payload = self._generate_patch_payload(\n        existing=self.get_by_id(id=storage_location.id),\n        updated=storage_location,\n    )\n    self.session.patch(path, json=payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=storage_location.id)\n</code></pre>"},{"location":"albert/#albert.albert.SubstanceCollection","title":"SubstanceCollection","text":"<pre><code>SubstanceCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>SubstanceCollection is a collection class for managing Substance entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>An instance of the Albert session used for API interactions.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base URL for making API requests related to substances.</p> <p>Methods:</p> Name Description <code>get_by_ids</code> <p>Retrieves a list of substances by their CAS IDs and optional region.</p> <code>get_by_id</code> <p>Retrieves a single substance by its CAS ID and optional region.</p> Source code in <code>src/albert/collections/substance.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{SubstanceCollection._api_version}/substances\"\n</code></pre>"},{"location":"albert/#albert.albert.SubstanceCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/substances'\n</code></pre>"},{"location":"albert/#albert.albert.SubstanceCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(\n    *, cas_id: str, region: str = \"US\"\n) -&gt; SubstanceInfo\n</code></pre> <p>Get a substance by its CAS ID.</p> <p>Parameters:</p> Name Type Description Default <code>cas_id</code> <code>str</code> <p>The CAS ID of the substance to retrieve.</p> required <p>Returns:</p> Type Description <code>SubstanceInfo</code> <p>The retrieved substance or raises an error if not found.</p> Source code in <code>src/albert/collections/substance.py</code> <pre><code>def get_by_id(self, *, cas_id: str, region: str = \"US\") -&gt; SubstanceInfo:\n    \"\"\"\n    Get a substance by its CAS ID.\n\n    Parameters\n    ----------\n    cas_id : str\n        The CAS ID of the substance to retrieve.\n\n    Returns\n    -------\n    SubstanceInfo\n        The retrieved substance or raises an error if not found.\n    \"\"\"\n    return self.get_by_ids(cas_ids=[cas_id], region=region)[0]\n</code></pre>"},{"location":"albert/#albert.albert.SubstanceCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(\n    *, cas_ids: list[str], region: str = \"US\"\n) -&gt; list[SubstanceInfo]\n</code></pre> <p>Get substances by their CAS IDs.</p> <p>Parameters:</p> Name Type Description Default <code>cas_ids</code> <code>list[str]</code> <p>A list of CAS IDs to retrieve substances for.</p> required <code>region</code> <code>str</code> <p>The region to filter the subastance by, by default \"US\"</p> <code>'US'</code> <p>Returns:</p> Type Description <code>list[SubstanceInfo]</code> <p>A list of substances with the given CAS IDs.</p> Source code in <code>src/albert/collections/substance.py</code> <pre><code>def get_by_ids(self, *, cas_ids: list[str], region: str = \"US\") -&gt; list[SubstanceInfo]:\n    \"\"\"Get substances by their CAS IDs.\n\n    Parameters\n    ----------\n    cas_ids : list[str]\n        A list of CAS IDs to retrieve substances for.\n    region : str, optional\n        The region to filter the subastance by, by default \"US\"\n\n    Returns\n    -------\n    list[SubstanceInfo]\n        A list of substances with the given CAS IDs.\n    \"\"\"\n    url = f\"{self.base_path}\"\n    response = self.session.get(url, params={\"casIDs\": \",\".join(cas_ids), \"region\": region})\n    return SubstanceResponse.model_validate(response.json()).substances\n</code></pre>"},{"location":"albert/#albert.albert.TagCollection","title":"TagCollection","text":"<pre><code>TagCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>TagCollection is a collection class for managing Tag entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base URL for tag API requests.</p> <p>Methods:</p> Name Description <code>list</code> <p>Lists tag entities with optional filters.</p> <code>tag_exists</code> <p>Checks if a tag exists by its name.</p> <code>create</code> <p>Creates a new tag entity.</p> <code>get_by_id</code> <p>Retrieves a tag by its ID.</p> <code>get_by_ids</code> <p>Retrieve a list of tags by their IDs.</p> <code>get_by_tag</code> <p>Retrieves a tag by its name.</p> <code>delete</code> <p>Deletes a tag by its ID.</p> <code>rename</code> <p>Renames an existing tag entity.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required Source code in <code>src/albert/collections/tags.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the TagCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{TagCollection._api_version}/tags\"\n</code></pre>"},{"location":"albert/#albert.albert.TagCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/tags'\n</code></pre>"},{"location":"albert/#albert.albert.TagCollection.create","title":"create","text":"<pre><code>create(*, tag: str | Tag) -&gt; Tag\n</code></pre> <p>Creates a new tag entity if the given tag does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Union[str, Tag]</code> <p>The tag name or Tag object to create.</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>The created Tag object or the existing Tag object of it already exists.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def create(self, *, tag: str | Tag) -&gt; Tag:\n    \"\"\"\n    Creates a new tag entity if the given tag does not exist.\n\n    Parameters\n    ----------\n    tag : Union[str, Tag]\n        The tag name or Tag object to create.\n\n    Returns\n    -------\n    Tag\n        The created Tag object or the existing Tag object of it already exists.\n    \"\"\"\n    if isinstance(tag, str):\n        tag = Tag(tag=tag)\n    hit = self.get_by_tag(tag=tag.tag, exact_match=True)\n    if hit is not None:\n        logging.warning(f\"Tag {hit.tag} already exists with id {hit.id}\")\n        return hit\n    payload = {\"name\": tag.tag}\n    response = self.session.post(self.base_path, json=payload)\n    tag = Tag(**response.json())\n    return tag\n</code></pre>"},{"location":"albert/#albert.albert.TagCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a tag by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the tag to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a tag by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the tag to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.TagCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Tag\n</code></pre> <p>Get a tag by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the tag to get.</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>The Tag object.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Tag:\n    \"\"\"\n    Get a tag by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the tag to get.\n\n    Returns\n    -------\n    Tag\n        The Tag object.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return Tag(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.TagCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(*, ids: list[str]) -&gt; list[Tag]\n</code></pre> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def get_by_ids(self, *, ids: list[str]) -&gt; list[Tag]:\n    url = f\"{self.base_path}/ids\"\n    batches = [ids[i : i + 100] for i in range(0, len(ids), 100)]\n    return [\n        Tag(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()\n    ]\n</code></pre>"},{"location":"albert/#albert.albert.TagCollection.get_by_tag","title":"get_by_tag","text":"<pre><code>get_by_tag(\n    *, tag: str, exact_match: bool = True\n) -&gt; Tag | None\n</code></pre> <p>Retrieves a tag by its name of None if not found.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The name of the tag to retrieve.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tag</code> <p>The Tag object if found, None otherwise.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def get_by_tag(self, *, tag: str, exact_match: bool = True) -&gt; Tag | None:\n    \"\"\"\n    Retrieves a tag by its name of None if not found.\n\n    Parameters\n    ----------\n    tag : str\n        The name of the tag to retrieve.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    Tag\n        The Tag object if found, None otherwise.\n    \"\"\"\n    found = self.list(name=tag, exact_match=exact_match)\n    return next(found, None)\n</code></pre>"},{"location":"albert/#albert.albert.TagCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 50,\n    order_by: OrderBy = DESCENDING,\n    name: str | list[str] | None = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Tag]\n</code></pre> <p>Lists Tag entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of tags to return, by default 50.</p> <code>50</code> <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <code>name</code> <code>Union[str, None]</code> <p>The name of the tag to filter by, by default None.</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <code>start_key</code> <code>Optional[str]</code> <p>The starting point for the next set of results, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Tag]</code> <p>An iterator of Tag objects.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 50,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    name: str | list[str] | None = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Tag]:\n    \"\"\"\n    Lists Tag entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of tags to return, by default 50.\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING.\n    name : Union[str, None], optional\n        The name of the tag to filter by, by default None.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n    start_key : Optional[str], optional\n        The starting point for the next set of results, by default None.\n\n    Returns\n    -------\n    Iterator[Tag]\n        An iterator of Tag objects.\n    \"\"\"\n    params = {\"limit\": limit, \"orderBy\": order_by.value, \"startKey\": start_key}\n    if name:\n        params[\"name\"] = [name] if isinstance(name, str) else name\n        params[\"exactMatch\"] = json.dumps(exact_match)\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Tag(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.TagCollection.rename","title":"rename","text":"<pre><code>rename(*, old_name: str, new_name: str) -&gt; Tag\n</code></pre> <p>Renames an existing tag entity.</p> <p>Parameters:</p> Name Type Description Default <code>old_name</code> <code>str</code> <p>The current name of the tag.</p> required <code>new_name</code> <code>str</code> <p>The new name of the tag.</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>The renamed Tag.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def rename(self, *, old_name: str, new_name: str) -&gt; Tag:\n    \"\"\"\n    Renames an existing tag entity.\n\n    Parameters\n    ----------\n    old_name : str\n        The current name of the tag.\n    new_name : str\n        The new name of the tag.\n\n    Returns\n    -------\n    Tag\n        The renamed Tag.\n    \"\"\"\n    found_tag = self.get_by_tag(tag=old_name, exact_match=True)\n    if not found_tag:\n        msg = f'Tag \"{old_name}\" not found.'\n        logger.error(msg)\n        raise AlbertException(msg)\n    tag_id = found_tag.id\n    payload = [\n        {\n            \"data\": [\n                {\n                    \"operation\": \"update\",\n                    \"attribute\": \"name\",\n                    \"oldValue\": old_name,\n                    \"newValue\": new_name,\n                }\n            ],\n            \"id\": tag_id,\n        }\n    ]\n    self.session.patch(self.base_path, json=payload)\n    return self.get_by_id(id=tag_id)\n</code></pre>"},{"location":"albert/#albert.albert.TagCollection.tag_exists","title":"tag_exists","text":"<pre><code>tag_exists(*, tag: str, exact_match: bool = True) -&gt; bool\n</code></pre> <p>Checks if a tag exists by its name.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The name of the tag to check.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the tag exists, False otherwise.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def tag_exists(self, *, tag: str, exact_match: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if a tag exists by its name.\n\n    Parameters\n    ----------\n    tag : str\n        The name of the tag to check.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    bool\n        True if the tag exists, False otherwise.\n    \"\"\"\n\n    return self.get_by_tag(tag=tag, exact_match=exact_match) is not None\n</code></pre>"},{"location":"albert/#albert.albert.TaskCollection","title":"TaskCollection","text":"<pre><code>TaskCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>TaskCollection is a collection class for managing Task entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert Session information</p> required <p>Methods:</p> Name Description <code>add_block</code> <p>Add a block to a Property task.</p> <code>create</code> <p>Create a new task. Tasks can be of different types, such as PropertyTask, and are created using the provided task object.</p> <code>delete</code> <p>Delete a task.</p> <code>get_by_id</code> <p>Retrieve a task by its ID.</p> <code>get_history</code> <code>list</code> <p>Search for tasks matching the given criteria.</p> <code>remove_block</code> <p>Remove a block from a Property task.</p> <code>update</code> <p>Update a task.</p> <code>update_block_workflow</code> <p>Update the workflow of a specific block within a task.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initialize the TaskCollection.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert Session information\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{TaskCollection._api_version}/tasks\"\n</code></pre>"},{"location":"albert/#albert.albert.TaskCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/tasks'\n</code></pre>"},{"location":"albert/#albert.albert.TaskCollection.add_block","title":"add_block","text":"<pre><code>add_block(\n    *,\n    task_id: TaskId,\n    data_template_id: DataTemplateId,\n    workflow_id: WorkflowId,\n) -&gt; None\n</code></pre> <p>Add a block to a Property task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task to add the block to.</p> required <code>data_template_id</code> <code>DataTemplateId</code> <p>The ID of the data template to use for the block.</p> required <code>workflow_id</code> <code>WorkflowId</code> <p>The ID of the workflow to assign to the block.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This method does not return any value.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef add_block(\n    self, *, task_id: TaskId, data_template_id: DataTemplateId, workflow_id: WorkflowId\n) -&gt; None:\n    \"\"\"Add a block to a Property task.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task to add the block to.\n    data_template_id : DataTemplateId\n        The ID of the data template to use for the block.\n    workflow_id : WorkflowId\n        The ID of the workflow to assign to the block.\n\n    Returns\n    -------\n    None\n        This method does not return any value.\n\n    \"\"\"\n    url = f\"{self.base_path}/{task_id}\"\n    payload = [\n        {\n            \"id\": task_id,\n            \"data\": [\n                {\n                    \"operation\": \"add\",\n                    \"attribute\": \"Block\",\n                    \"newValue\": [{\"datId\": data_template_id, \"Workflow\": {\"id\": workflow_id}}],\n                }\n            ],\n        }\n    ]\n    self.session.patch(url=url, json=payload)\n    return None\n</code></pre>"},{"location":"albert/#albert.albert.TaskCollection.create","title":"create","text":"<pre><code>create(*, task: BaseTask) -&gt; BaseTask\n</code></pre> <p>Create a new task. Tasks can be of different types, such as PropertyTask, and are created using the provided task object.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>BaseTask</code> <p>The task object to create.</p> required <p>Returns:</p> Type Description <code>BaseTask</code> <p>The registered task object.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def create(self, *, task: BaseTask) -&gt; BaseTask:\n    \"\"\"Create a new task. Tasks can be of different types, such as PropertyTask, and are created using the provided task object.\n\n    Parameters\n    ----------\n    task : BaseTask\n        The task object to create.\n\n    Returns\n    -------\n    BaseTask\n        The registered task object.\n    \"\"\"\n    payload = [task.model_dump(mode=\"json\", by_alias=True, exclude_none=True)]\n    url = f\"{self.base_path}/multi?category={task.category.value}\"\n    if task.parent_id is not None:\n        url = f\"{url}&amp;parentId={task.parent_id}\"\n    response = self.session.post(url=url, json=payload)\n    task_data = response.json()[0]\n    return TaskAdapter.validate_python(task_data)\n</code></pre>"},{"location":"albert/#albert.albert.TaskCollection.delete","title":"delete","text":"<pre><code>delete(*, id: TaskId) -&gt; None\n</code></pre> <p>Delete a task.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TaskId</code> <p>The ID of the task to delete.</p> required Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef delete(self, *, id: TaskId) -&gt; None:\n    \"\"\"Delete a task.\n\n    Parameters\n    ----------\n    id : TaskId\n        The ID of the task to delete.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.TaskCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: TaskId) -&gt; BaseTask\n</code></pre> <p>Retrieve a task by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TaskId</code> <p>The ID of the task to retrieve.</p> required <p>Returns:</p> Type Description <code>BaseTask</code> <p>The task object with the provided ID.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef get_by_id(self, *, id: TaskId) -&gt; BaseTask:\n    \"\"\"Retrieve a task by its ID.\n\n    Parameters\n    ----------\n    id : TaskId\n        The ID of the task to retrieve.\n\n    Returns\n    -------\n    BaseTask\n        The task object with the provided ID.\n    \"\"\"\n    url = f\"{self.base_path}/multi/{id}\"\n    response = self.session.get(url)\n    return TaskAdapter.validate_python(response.json())\n</code></pre>"},{"location":"albert/#albert.albert.TaskCollection.get_history","title":"get_history","text":"<pre><code>get_history(\n    *,\n    id: TaskId,\n    order: OrderBy = DESCENDING,\n    limit: int = 1000,\n    entity: HistoryEntity | None = None,\n    blockId: str | None = None,\n    startKey: str | None = None,\n) -&gt; TaskHistory\n</code></pre> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def get_history(\n    self,\n    *,\n    id: TaskId,\n    order: OrderBy = OrderBy.DESCENDING,\n    limit: int = 1000,\n    entity: HistoryEntity | None = None,\n    blockId: str | None = None,\n    startKey: str | None = None,\n) -&gt; TaskHistory:\n    params = {\n        \"limit\": limit,\n        \"orderBy\": OrderBy(order).value if order else None,\n        \"entity\": entity,\n        \"blockId\": blockId,\n        \"startKey\": startKey,\n    }\n    url = f\"{self.base_path}/{id}/history\"\n    response = self.session.get(url, params=params)\n    return TaskHistory(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.TaskCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    order: OrderBy = DESCENDING,\n    text: str | None = None,\n    sort_by: str | None = None,\n    tags: list[str] | None = None,\n    task_id: list[str] | None = None,\n    linked_task: list[str] | None = None,\n    category: TaskCategory | None = None,\n    albert_id: list[str] | None = None,\n    data_template: list[str] | None = None,\n    assigned_to: list[str] | None = None,\n    location: list[str] | None = None,\n    priority: list[str] | None = None,\n    status: list[str] | None = None,\n    parameter_group: list[str] | None = None,\n    created_by: list[str] | None = None,\n    project_id: str | None = None,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; Iterator[BaseTask]\n</code></pre> <p>Search for tasks matching the given criteria.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>OrderBy</code> <p>The order in which to return results, by default OrderBy.DESCENDING</p> <code>DESCENDING</code> <code>text</code> <code>str | None</code> <p>The text to search for, by default None</p> <code>None</code> <code>sort_by</code> <code>str | None</code> <p>The attribute to sort by, by default None</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>The tags to search for, by default None</p> <code>None</code> <code>task_id</code> <code>list[str] | None</code> <p>The related task IDs to search for, by default None</p> <code>None</code> <code>linked_task</code> <code>list[str] | None</code> <p>The Linked Task IDs to search for, by default None</p> <code>None</code> <code>category</code> <code>TaskCategory | None</code> <p>The category of the task to search for, by default None</p> <code>None</code> <code>albert_id</code> <code>list[str] | None</code> <p>The Albert IDs to search for, by default None</p> <code>None</code> <code>data_template</code> <code>list[str] | None</code> <p>The data template IDs to search for, by default None</p> <code>None</code> <code>assigned_to</code> <code>list[str] | None</code> <p>The User IDs to search for, by default None</p> <code>None</code> <code>location</code> <code>list[str] | None</code> <p>The Locations names to search for, by default None</p> <code>None</code> <code>priority</code> <code>list[str] | None</code> <p>The Priority levels to search for, by default None</p> <code>None</code> <code>status</code> <code>list[str] | None</code> <p>The Task Statuses to search for, by default None</p> <code>None</code> <code>parameter_group</code> <code>list[str] | None</code> <p>The related Parameter Group IDs to search for, by default None</p> <code>None</code> <code>created_by</code> <code>list[str] | None</code> <p>The User IDs of the task creators to search for, by default None</p> <code>None</code> <code>project_id</code> <code>str | None</code> <p>The Project ID to search for, by default None</p> <code>None</code> <p>Yields:</p> Type Description <code>Iterator[BaseTask]</code> <p>An iterator of matching Task objects.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def list(\n    self,\n    *,\n    order: OrderBy = OrderBy.DESCENDING,\n    text: str | None = None,\n    sort_by: str | None = None,\n    tags: list[str] | None = None,\n    task_id: list[str] | None = None,\n    linked_task: list[str] | None = None,\n    category: TaskCategory | None = None,\n    albert_id: list[str] | None = None,\n    data_template: list[str] | None = None,\n    assigned_to: list[str] | None = None,\n    location: list[str] | None = None,\n    priority: list[str] | None = None,\n    status: list[str] | None = None,\n    parameter_group: list[str] | None = None,\n    created_by: list[str] | None = None,\n    project_id: str | None = None,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; Iterator[BaseTask]:\n    \"\"\"Search for tasks matching the given criteria.\n\n    Parameters\n    ----------\n    order : OrderBy, optional\n        The order in which to return results, by default OrderBy.DESCENDING\n    text : str | None, optional\n        The text to search for, by default None\n    sort_by : str | None, optional\n        The attribute to sort by, by default None\n    tags : list[str] | None, optional\n        The tags to search for, by default None\n    task_id : list[str] | None, optional\n        The related task IDs to search for, by default None\n    linked_task : list[str] | None, optional\n        The Linked Task IDs to search for, by default None\n    category : TaskCategory | None, optional\n        The category of the task to search for, by default None\n    albert_id : list[str] | None, optional\n        The Albert IDs to search for, by default None\n    data_template : list[str] | None, optional\n        The data template IDs to search for, by default None\n    assigned_to : list[str] | None, optional\n        The User IDs to search for, by default None\n    location : list[str] | None, optional\n        The Locations names to search for, by default None\n    priority : list[str] | None, optional\n        The Priority levels to search for, by default None\n    status : list[str] | None, optional\n        The Task Statuses to search for, by default None\n    parameter_group : list[str] | None, optional\n        The related Parameter Group IDs to search for, by default None\n    created_by : list[str] | None, optional\n        The User IDs of the task creators to search for, by default None\n    project_id : str | None, optional\n        The Project ID to search for, by default None\n\n    Yields\n    ------\n    Iterator[BaseTask]\n        An iterator of matching Task objects.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[BaseTask]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except (\n                AlbertHTTPError,\n                RetryError,\n            ) as e:  # some legacy poorly formed Tasks raise 500s. The allowance on Retry error to also ignore these.\n                logger.warning(f\"Error fetching task '{id}': {e}\")\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"order\": OrderBy(order).value if order else None,\n        \"text\": text,\n        \"sortBy\": sort_by,\n        \"tags\": tags,\n        \"taskId\": task_id,\n        \"linkedTask\": linked_task,\n        \"category\": category,\n        \"albertId\": albert_id,\n        \"dataTemplate\": data_template,\n        \"assignedTo\": assigned_to,\n        \"location\": location,\n        \"priority\": priority,\n        \"status\": status,\n        \"parameterGroup\": parameter_group,\n        \"createdBy\": created_by,\n        \"projectId\": project_id,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        deserialize=deserialize,\n        params=params,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.TaskCollection.remove_block","title":"remove_block","text":"<pre><code>remove_block(*, task_id: TaskId, block_id: BlockId) -&gt; None\n</code></pre> <p>Remove a block from a Property task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>ID of the Task to remove the block from (e.g., TASFOR1234)</p> required <code>block_id</code> <code>str</code> <p>ID of the Block to remove (e.g., BLK1)</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef remove_block(self, *, task_id: TaskId, block_id: BlockId) -&gt; None:\n    \"\"\"Remove a block from a Property task.\n\n    Parameters\n    ----------\n    task_id : str\n        ID of the Task to remove the block from (e.g., TASFOR1234)\n    block_id : str\n        ID of the Block to remove (e.g., BLK1)\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{task_id}\"\n    payload = [\n        {\n            \"id\": task_id,\n            \"data\": [\n                {\n                    \"operation\": \"delete\",\n                    \"attribute\": \"Block\",\n                    \"oldValue\": [block_id],\n                }\n            ],\n        }\n    ]\n    self.session.patch(url=url, json=payload)\n    return None\n</code></pre>"},{"location":"albert/#albert.albert.TaskCollection.update","title":"update","text":"<pre><code>update(*, task: BaseTask) -&gt; BaseTask\n</code></pre> <p>Update a task.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>BaseTask</code> <p>The updated Task object.</p> required <p>Returns:</p> Type Description <code>BaseTask</code> <p>The updated Task object as it exists in the Albert platform.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def update(self, *, task: BaseTask) -&gt; BaseTask:\n    \"\"\"Update a task.\n\n    Parameters\n    ----------\n    task : BaseTask\n        The updated Task object.\n\n    Returns\n    -------\n    BaseTask\n        The updated Task object as it exists in the Albert platform.\n    \"\"\"\n    patch_payload = self._generate_adv_patch_payload(updated=task)\n    if len(patch_payload[0][\"data\"]) == 0:\n        logger.info(f\"Task {task.id} is already up to date\")\n        return task\n    self.session.patch(\n        url=f\"{self.base_path}/{task.id}\",\n        json=patch_payload,\n    )\n    return self.get_by_id(id=task.id)\n</code></pre>"},{"location":"albert/#albert.albert.TaskCollection.update_block_workflow","title":"update_block_workflow","text":"<pre><code>update_block_workflow(\n    *,\n    task_id: TaskId,\n    block_id: BlockId,\n    workflow_id: WorkflowId,\n) -&gt; None\n</code></pre> <p>Update the workflow of a specific block within a task.</p> <p>This method updates the workflow of a specified block within a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task.</p> required <code>block_id</code> <code>str</code> <p>The ID of the block within the task.</p> required <code>workflow_id</code> <code>str</code> <p>The ID of the new workflow to be assigned to the block.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This method does not return any value.</p> Notes <ul> <li>The method asserts that the retrieved task is an instance of <code>PropertyTask</code>.</li> <li>If the block's current workflow matches the new workflow ID, no update is performed.</li> <li>The method handles the case where the block has a default workflow named \"No Parameter Group\".</li> </ul> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef update_block_workflow(\n    self, *, task_id: TaskId, block_id: BlockId, workflow_id: WorkflowId\n) -&gt; None:\n    \"\"\"\n    Update the workflow of a specific block within a task.\n\n    This method updates the workflow of a specified block within a task.\n    Parameters\n    ----------\n    task_id : str\n        The ID of the task.\n    block_id : str\n        The ID of the block within the task.\n    workflow_id : str\n        The ID of the new workflow to be assigned to the block.\n\n    Returns\n    -------\n    None\n        This method does not return any value.\n\n    Notes\n    -----\n    - The method asserts that the retrieved task is an instance of `PropertyTask`.\n    - If the block's current workflow matches the new workflow ID, no update is performed.\n    - The method handles the case where the block has a default workflow named \"No Parameter Group\".\n    \"\"\"\n    url = f\"{self.base_path}/{task_id}\"\n    task = self.get_by_id(id=task_id)\n    if not isinstance(task, PropertyTask):\n        logger.error(f\"Task {task_id} is not an instance of PropertyTask\")\n        raise TypeError(f\"Task {task_id} is not an instance of PropertyTask\")\n    for b in task.blocks:\n        if b.id != block_id:\n            continue\n        for w in b.workflow:\n            if w.name == \"No Parameter Group\" and len(b.workflow) &gt; 1:\n                # hardcoded default workflow\n                continue\n            existing_workflow_id = w.id\n    if existing_workflow_id == workflow_id:\n        logger.info(f\"Block {block_id} already has workflow {workflow_id}\")\n        return None\n    patch = [\n        {\n            \"data\": [\n                {\n                    \"operation\": \"update\",\n                    \"attribute\": \"workflow\",\n                    \"oldValue\": existing_workflow_id,\n                    \"newValue\": workflow_id,\n                    \"blockId\": block_id,\n                }\n            ],\n            \"id\": task_id,\n        }\n    ]\n    self.session.patch(url=url, json=patch)\n    return None\n</code></pre>"},{"location":"albert/#albert.albert.UnNumberCollection","title":"UnNumberCollection","text":"<pre><code>UnNumberCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>UnNumberCollection is a collection class for managing UnNumber entities in the Albert platform.</p> Note <p>Creating UN Numbers is not supported via the SDK, as UN Numbers are highly controlled by Albert.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>This method is not implemented as UN Numbers cannot be created through the SDK.</p> <code>get_by_id</code> <p>Retrieve a UN Number by its ID.</p> <code>get_by_name</code> <p>Retrieve a UN Number by its name.</p> <code>list</code> <p>List UN Numbers matching the provided criteria.</p> Source code in <code>src/albert/collections/un_numbers.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initializes the UnNumberCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{UnNumberCollection._api_version}/unnumbers\"\n</code></pre>"},{"location":"albert/#albert.albert.UnNumberCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/unnumbers'\n</code></pre>"},{"location":"albert/#albert.albert.UnNumberCollection.create","title":"create","text":"<pre><code>create() -&gt; None\n</code></pre> <p>This method is not implemented as UN Numbers cannot be created through the SDK.</p> Source code in <code>src/albert/collections/un_numbers.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"\n    This method is not implemented as UN Numbers cannot be created through the SDK.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"albert/#albert.albert.UnNumberCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; UnNumber\n</code></pre> <p>Retrieve a UN Number by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the UN Number to retrieve.</p> required <p>Returns:</p> Type Description <code>UnNumber</code> <p>The corresponding UN Number</p> Source code in <code>src/albert/collections/un_numbers.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; UnNumber:\n    \"\"\"Retrieve a UN Number by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the UN Number to retrieve.\n\n    Returns\n    -------\n    UnNumber\n        The corresponding UN Number\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return UnNumber(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.UnNumberCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(*, name: str) -&gt; UnNumber | None\n</code></pre> <p>Retrieve a UN Number by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the UN Number to retrieve</p> required <p>Returns:</p> Type Description <code>UnNumber | None</code> <p>The corresponding UN Number or None if not found</p> Source code in <code>src/albert/collections/un_numbers.py</code> <pre><code>def get_by_name(self, *, name: str) -&gt; UnNumber | None:\n    \"\"\"Retrieve a UN Number by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the UN Number to retrieve\n\n    Returns\n    -------\n    UnNumber | None\n        The corresponding UN Number or None if not found\n    \"\"\"\n    found = self.list(exact_match=True, name=name)\n    return next(found, None)\n</code></pre>"},{"location":"albert/#albert.albert.UnNumberCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    name: str | None = None,\n    exact_match: bool = False,\n    limit: int = 50,\n    start_key: str | None = None,\n) -&gt; Iterator[UnNumber]\n</code></pre> <p>List UN Numbers matching the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the UN Number to search for, by default None</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Weather to return exact matches only, by default False</p> <code>False</code> <p>Yields:</p> Type Description <code>Iterator[UnNumber]</code> <p>The UN Numbers matching the search criteria</p> Source code in <code>src/albert/collections/un_numbers.py</code> <pre><code>def list(\n    self,\n    *,\n    name: str | None = None,\n    exact_match: bool = False,\n    limit: int = 50,\n    start_key: str | None = None,\n) -&gt; Iterator[UnNumber]:\n    \"\"\"List UN Numbers matching the provided criteria.\n\n    Parameters\n    ----------\n    name : str | None, optional\n        The name of the UN Number to search for, by default None\n    exact_match : bool, optional\n        Weather to return exact matches only, by default False\n\n    Yields\n    ------\n    Iterator[UnNumber]\n        The UN Numbers matching the search criteria\n    \"\"\"\n    params = {\"limit\": limit, \"startKey\": start_key}\n    if name:\n        params[\"name\"] = name\n        params[\"exactMatch\"] = json.dumps(exact_match)\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [UnNumber(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.UnitCollection","title":"UnitCollection","text":"<pre><code>UnitCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>UnitCollection is a collection class for managing Unit entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Creates a new unit entity.</p> <code>delete</code> <p>Deletes a unit by its ID.</p> <code>get_by_id</code> <p>Retrieves a unit by its ID.</p> <code>get_by_name</code> <p>Retrieves a unit by its name.</p> <code>list</code> <p>Lists unit entities with optional filters.</p> <code>unit_exists</code> <p>Checks if a unit exists by its name.</p> <code>update</code> <p>Updates a unit entity by its ID.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the UnitCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{UnitCollection._api_version}/units\"\n</code></pre>"},{"location":"albert/#albert.albert.UnitCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/units'\n</code></pre>"},{"location":"albert/#albert.albert.UnitCollection.create","title":"create","text":"<pre><code>create(*, unit: Unit) -&gt; Unit\n</code></pre> <p>Creates a new unit entity.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit</code> <p>The unit object to create.</p> required <p>Returns:</p> Type Description <code>Unit</code> <p>The created Unit object.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def create(self, *, unit: Unit) -&gt; Unit:\n    \"\"\"\n    Creates a new unit entity.\n\n    Parameters\n    ----------\n    unit : Unit\n        The unit object to create.\n\n    Returns\n    -------\n    Unit\n        The created Unit object.\n    \"\"\"\n    hit = self.get_by_name(name=unit.name, exact_match=True)\n    if hit is not None:\n        logging.warning(\n            f\"Unit with the name {hit.name} already exists. Returning the existing unit.\"\n        )\n        return hit\n    response = self.session.post(\n        self.base_path, json=unit.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    )\n    this_unit = Unit(**response.json())\n    return this_unit\n</code></pre>"},{"location":"albert/#albert.albert.UnitCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a unit by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the unit to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/units.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a unit by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the unit to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"albert/#albert.albert.UnitCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Unit\n</code></pre> <p>Retrieves a unit by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the unit to retrieve.</p> required <p>Returns:</p> Type Description <code>Unit</code> <p>The Unit object if found.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Unit:\n    \"\"\"\n    Retrieves a unit by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the unit to retrieve.\n\n    Returns\n    -------\n    Unit\n        The Unit object if found.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    this_unit = Unit(**response.json())\n    return this_unit\n</code></pre>"},{"location":"albert/#albert.albert.UnitCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(\n    *, name: str, exact_match: bool = False\n) -&gt; Unit | None\n</code></pre> <p>Retrieves a unit by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the unit to retrieve.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[Unit]</code> <p>The Unit object if found, None otherwise.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def get_by_name(self, *, name: str, exact_match: bool = False) -&gt; Unit | None:\n    \"\"\"\n    Retrieves a unit by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the unit to retrieve.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default False.\n\n    Returns\n    -------\n    Optional[Unit]\n        The Unit object if found, None otherwise.\n    \"\"\"\n    found = self.list(name=name, exact_match=exact_match)\n    return next(found, None)\n</code></pre>"},{"location":"albert/#albert.albert.UnitCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    name: str | list[str] | None = None,\n    category: UnitCategory | None = None,\n    order_by: OrderBy = DESCENDING,\n    exact_match: bool = False,\n    start_key: str | None = None,\n    verified: bool | None = None,\n) -&gt; Iterator[Unit]\n</code></pre> <p>Lists unit entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of units to return, by default 50.</p> <code>100</code> <code>name</code> <code>Optional[str]</code> <p>The name of the unit to filter by, by default None.</p> <code>None</code> <code>category</code> <code>Optional[UnitCategory]</code> <p>The category of the unit to filter by, by default None.</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default False.</p> <code>False</code> <code>start_key</code> <code>Optional[str]</code> <p>The starting point for the next set of results, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Unit]</code> <p>An iterator of Unit objects.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    name: str | list[str] | None = None,\n    category: UnitCategory | None = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    exact_match: bool = False,\n    start_key: str | None = None,\n    verified: bool | None = None,\n) -&gt; Iterator[Unit]:\n    \"\"\"\n    Lists unit entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of units to return, by default 50.\n    name : Optional[str], optional\n        The name of the unit to filter by, by default None.\n    category : Optional[UnitCategory], optional\n        The category of the unit to filter by, by default None.\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default False.\n    start_key : Optional[str], optional\n        The starting point for the next set of results, by default None.\n\n    Returns\n    -------\n    Iterator[Unit]\n        An iterator of Unit objects.\n    \"\"\"\n    params = {\n        \"limit\": limit,\n        \"startKey\": start_key,\n        \"orderBy\": order_by.value,\n        \"name\": [name] if isinstance(name, str) else name,\n        \"exactMatch\": json.dumps(exact_match),\n        \"verified\": json.dumps(verified) if verified is not None else None,\n        \"category\": category.value if isinstance(category, UnitCategory) else category,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Unit(**item) for item in items],\n    )\n</code></pre>"},{"location":"albert/#albert.albert.UnitCollection.unit_exists","title":"unit_exists","text":"<pre><code>unit_exists(*, name: str, exact_match: bool = True) -&gt; bool\n</code></pre> <p>Checks if a unit exists by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the unit to check.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the unit exists, False otherwise.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def unit_exists(self, *, name: str, exact_match: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if a unit exists by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the unit to check.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    bool\n        True if the unit exists, False otherwise.\n    \"\"\"\n    return self.get_by_name(name=name, exact_match=exact_match) is not None\n</code></pre>"},{"location":"albert/#albert.albert.UnitCollection.update","title":"update","text":"<pre><code>update(*, unit: Unit) -&gt; Unit\n</code></pre> <p>Updates a unit entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit</code> <p>The updated Unit object.</p> required <p>Returns:</p> Type Description <code>Unit</code> <p>The updated Unit</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def update(self, *, unit: Unit) -&gt; Unit:\n    \"\"\"\n    Updates a unit entity by its ID.\n\n    Parameters\n    ----------\n    unit : Unit\n        The updated Unit object.\n\n    Returns\n    -------\n    Unit\n        The updated Unit\n    \"\"\"\n    unit_id = unit.id\n    original_unit = self.get_by_id(id=unit_id)\n    payload = self._generate_patch_payload(existing=original_unit, updated=unit)\n    url = f\"{self.base_path}/{unit_id}\"\n    self.session.patch(url, json=payload.model_dump(mode=\"json\", by_alias=True))\n    unit = self.get_by_id(id=unit_id)\n    return unit\n</code></pre>"},{"location":"albert/#albert.albert.UserCollection","title":"UserCollection","text":"<pre><code>UserCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>UserCollection is a collection class for managing User entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new User</p> <code>get_by_id</code> <p>Retrieves a User by its ID.</p> <code>get_current_user</code> <p>Retrieves the current authenticated user.</p> <code>list</code> <p>Lists Users based on criteria</p> <code>update</code> <p>Update a User entity.</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the UserCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{UserCollection._api_version}/users\"\n</code></pre>"},{"location":"albert/#albert.albert.UserCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/users'\n</code></pre>"},{"location":"albert/#albert.albert.UserCollection.create","title":"create","text":"<pre><code>create(*, user: User) -&gt; User\n</code></pre> <p>Create a new User</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to create</p> required <p>Returns:</p> Type Description <code>User</code> <p>The created User</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def create(self, *, user: User) -&gt; User:  # pragma: no cover\n    \"\"\"Create a new User\n\n    Parameters\n    ----------\n    user : User\n        The user to create\n\n    Returns\n    -------\n    User\n        The created User\n    \"\"\"\n\n    hits = self.list(text=user.email)\n    for u in hits:\n        if u.email == user.email:\n            logging.warning(\n                f\"User with email {user.email} already exists. Returning existing user.\"\n            )\n            return u\n\n    response = self.session.post(\n        self.base_path,\n        json=user.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return User(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.UserCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; User\n</code></pre> <p>Retrieves a User by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the user to retrieve.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The User object.</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; User:\n    \"\"\"\n    Retrieves a User by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the user to retrieve.\n\n    Returns\n    -------\n    User\n        The User object.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return User(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.UserCollection.get_current_user","title":"get_current_user","text":"<pre><code>get_current_user() -&gt; User\n</code></pre> <p>Retrieves the current authenticated user.</p> <p>Returns:</p> Type Description <code>User</code> <p>The current User object.</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def get_current_user(self) -&gt; User:\n    \"\"\"\n    Retrieves the current authenticated user.\n\n    Returns\n    -------\n    User\n        The current User object.\n    \"\"\"\n    claims = jwt.decode(self.session._access_token, options={\"verify_signature\": False})\n    return self.get_by_id(id=claims[\"id\"])\n</code></pre>"},{"location":"albert/#albert.albert.UserCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 50,\n    offset: int | None = None,\n    text: str | None = None,\n    status: Status | None = None,\n    search_fields: str | None = None,\n) -&gt; Iterator[User]\n</code></pre> <p>Lists Users based on criteria</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Optional[str]</code> <p>text to search against, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Generator</code> <p>Generator of matching Users or None</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 50,\n    offset: int | None = None,\n    text: str | None = None,\n    status: Status | None = None,\n    search_fields: str | None = None,\n) -&gt; Iterator[User]:\n    \"\"\"Lists Users based on criteria\n\n    Parameters\n    ----------\n    text : Optional[str], optional\n        text to search against, by default None\n\n    Returns\n    -------\n    Generator\n        Generator of matching Users or None\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[User]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching user '{id}': {e}\")\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"status\": status,\n        \"text\": text,\n        \"searchFields\": search_fields,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.UserCollection.update","title":"update","text":"<pre><code>update(*, user: User) -&gt; User\n</code></pre> <p>Update a User entity.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The updated User entity.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The updated User entity as returned by the server.</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def update(self, *, user: User) -&gt; User:\n    \"\"\"Update a User entity.\n\n    Parameters\n    ----------\n    user : User\n        The updated User entity.\n\n    Returns\n    -------\n    User\n        The updated User entity as returned by the server.\n    \"\"\"\n    # Fetch the current object state from the server or database\n    current_object = self.get_by_id(id=user.id)\n\n    # Generate the PATCH payload\n    payload = self._generate_patch_payload(existing=current_object, updated=user)\n\n    url = f\"{self.base_path}/{user.id}\"\n    self.session.patch(url, json=payload.model_dump(mode=\"json\", by_alias=True))\n\n    updated_user = self.get_by_id(id=user.id)\n    return updated_user\n</code></pre>"},{"location":"albert/#albert.albert.WorkflowCollection","title":"WorkflowCollection","text":"<pre><code>WorkflowCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>WorkflowCollection is a collection class for managing Workflow entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create or return matching workflows for the provided list of workflows.</p> <code>get_by_id</code> <p>Retrieve a Workflow by its ID.</p> <code>get_by_ids</code> <p>Returns a list of Workflow objects by their IDs.</p> <code>list</code> <p>List all workflows. Unlikly to be used in production.</p> Source code in <code>src/albert/collections/workflows.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the WorkflowCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{WorkflowCollection._api_version}/workflows\"\n</code></pre>"},{"location":"albert/#albert.albert.WorkflowCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/workflows'\n</code></pre>"},{"location":"albert/#albert.albert.WorkflowCollection.create","title":"create","text":"<pre><code>create(*, workflows: list[Workflow]) -&gt; list[Workflow]\n</code></pre> <p>Create or return matching workflows for the provided list of workflows. This endpoint automatically tries to find an existing workflow with the same parameter setpoints, and will either return the existing workflow or create a new one.</p> <p>Parameters:</p> Name Type Description Default <code>workflows</code> <code>list[Workflow]</code> <p>A list of Workflow objects to find or create.</p> required <p>Returns:</p> Type Description <code>list[Workflow]</code> <p>A list of created or found Workflow objects.</p> Source code in <code>src/albert/collections/workflows.py</code> <pre><code>def create(self, *, workflows: list[Workflow]) -&gt; list[Workflow]:\n    \"\"\"Create or return matching workflows for the provided list of workflows.\n    This endpoint automatically tries to find an existing workflow with the same parameter setpoints, and will either return the existing workflow or create a new one.\n\n    Parameters\n    ----------\n    workflows : list[Workflow]\n        A list of Workflow objects to find or create.\n\n    Returns\n    -------\n    list[Workflow]\n        A list of created or found Workflow objects.\n    \"\"\"\n    if isinstance(workflows, Workflow):\n        # in case the user forgets this should be a list\n        workflows = [workflows]\n    response = self.session.post(\n        url=f\"{self.base_path}/bulk\",\n        json=[x.model_dump(mode=\"json\", by_alias=True, exclude_none=True) for x in workflows],\n    )\n    return [Workflow(**x) for x in response.json()]\n</code></pre>"},{"location":"albert/#albert.albert.WorkflowCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Workflow\n</code></pre> <p>Retrieve a Workflow by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the Workflow to retrieve.</p> required <p>Returns:</p> Type Description <code>Workflow</code> <p>The Workflow object.</p> Source code in <code>src/albert/collections/workflows.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Workflow:\n    \"\"\"Retrieve a Workflow by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the Workflow to retrieve.\n\n    Returns\n    -------\n    Workflow\n        The Workflow object.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return Workflow(**response.json())\n</code></pre>"},{"location":"albert/#albert.albert.WorkflowCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(*, ids: list[str]) -&gt; list[Workflow]\n</code></pre> <p>Returns a list of Workflow objects by their IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>The list of Workflow IDs to retrieve.</p> required <p>Returns:</p> Type Description <code>list[Workflow]</code> <p>The list of Workflow objects matching the provided IDs.</p> Source code in <code>src/albert/collections/workflows.py</code> <pre><code>def get_by_ids(self, *, ids: list[str]) -&gt; list[Workflow]:\n    \"\"\"Returns a list of Workflow objects by their IDs.\n\n    Parameters\n    ----------\n    ids : list[str]\n        The list of Workflow IDs to retrieve.\n\n    Returns\n    -------\n    list[Workflow]\n        The list of Workflow objects matching the provided IDs.\n    \"\"\"\n    url = f\"{self.base_path}/ids\"\n    batches = [ids[i : i + 100] for i in range(0, len(ids), 100)]\n    return [\n        Workflow(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()[\"Items\"]\n    ]\n</code></pre>"},{"location":"albert/#albert.albert.WorkflowCollection.list","title":"list","text":"<pre><code>list(limit: int = 50) -&gt; Iterator[Workflow]\n</code></pre> <p>List all workflows. Unlikly to be used in production.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The number of workflows to return, by default 50.</p> <code>50</code> <p>Yields:</p> Type Description <code>Iterator[Workflow]</code> <p>An iterator of Workflow objects.</p> Source code in <code>src/albert/collections/workflows.py</code> <pre><code>def list(self, limit: int = 50) -&gt; Iterator[Workflow]:\n    \"\"\"List all workflows. Unlikly to be used in production.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The number of workflows to return, by default 50.\n\n    Yields\n    ------\n    Iterator[Workflow]\n        An iterator of Workflow objects.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; list[Workflow]:\n        return self.get_by_ids(ids=[x[\"albertId\"] for x in items])\n\n    params = {\"limit\": limit}\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        params=params,\n        session=self.session,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"albert/#albert.albert.WorksheetCollection","title":"WorksheetCollection","text":"<pre><code>WorksheetCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>WorksheetCollection is a collection class for managing Worksheet entities in the Albert platform.</p> <p>Methods:</p> Name Description <code>add_sheet</code> <p>Create a new blank sheet in the Worksheet with the specified name.</p> <code>get_by_project_id</code> <p>Retrieve a worksheet by its project ID. Projects and Worksheets are 1:1 in the Albert platform.</p> <code>setup_new_sheet_from_template</code> <p>Create a new sheet in the Worksheet related to the specified Project from a template.</p> <code>setup_worksheet</code> <p>Setup a new worksheet for a project.</p> Source code in <code>src/albert/collections/worksheets.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{WorksheetCollection._api_version}/worksheet\"\n</code></pre>"},{"location":"albert/#albert.albert.WorksheetCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/worksheet'\n</code></pre>"},{"location":"albert/#albert.albert.WorksheetCollection.add_sheet","title":"add_sheet","text":"<pre><code>add_sheet(\n    *, project_id: ProjectId, sheet_name: str\n) -&gt; Worksheet\n</code></pre> <p>Create a new blank sheet in the Worksheet with the specified name.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The project ID for the Worksheet to add the sheet to.</p> required <code>sheet_name</code> <code>str</code> <p>The name of the new sheet.</p> required <p>Returns:</p> Type Description <code>Worksheet</code> <p>The Worksheet object for the project.</p> Source code in <code>src/albert/collections/worksheets.py</code> <pre><code>def add_sheet(self, *, project_id: ProjectId, sheet_name: str) -&gt; Worksheet:\n    \"\"\"Create a new blank sheet in the Worksheet with the specified name.\n\n    Parameters\n    ----------\n    project_id : str\n        The project ID for the Worksheet to add the sheet to.\n    sheet_name : str\n        The name of the new sheet.\n\n    Returns\n    -------\n    Worksheet\n        The Worksheet object for the project.\n    \"\"\"\n    payload = {\"name\": sheet_name}\n    url = f\"{self.base_path}/project/{project_id}/sheets\"\n    self.session.put(url=url, json=payload)\n    return self.get_by_project_id(project_id=project_id)\n</code></pre>"},{"location":"albert/#albert.albert.WorksheetCollection.get_by_project_id","title":"get_by_project_id","text":"<pre><code>get_by_project_id(*, project_id: ProjectId) -&gt; Worksheet\n</code></pre> <p>Retrieve a worksheet by its project ID. Projects and Worksheets are 1:1 in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The project ID to retrieve the worksheet for.</p> required <p>Returns:</p> Type Description <code>Worksheet</code> <p>The Worksheet object for that project.</p> Source code in <code>src/albert/collections/worksheets.py</code> <pre><code>def get_by_project_id(self, *, project_id: ProjectId) -&gt; Worksheet:\n    \"\"\"Retrieve a worksheet by its project ID. Projects and Worksheets are 1:1 in the Albert platform.\n\n    Parameters\n    ----------\n    project_id : str\n        The project ID to retrieve the worksheet for.\n\n    Returns\n    -------\n    Worksheet\n        The Worksheet object for that project.\n    \"\"\"\n\n    params = {\"type\": \"project\", \"id\": project_id}\n    response = self.session.get(self.base_path, params=params)\n\n    response_json = response.json()\n\n    # Sheets are themselves collections, and therefore need access to the session\n    response_json = self._add_session_to_sheets(response_json)\n\n    return Worksheet(**response_json)\n</code></pre>"},{"location":"albert/#albert.albert.WorksheetCollection.setup_new_sheet_from_template","title":"setup_new_sheet_from_template","text":"<pre><code>setup_new_sheet_from_template(\n    *,\n    project_id: ProjectId,\n    sheet_template_id: str,\n    sheet_name: str,\n) -&gt; Worksheet\n</code></pre> <p>Create a new sheet in the Worksheet related to the specified Project from a template.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>description</p> required <code>sheet_template_id</code> <code>str</code> <p>description</p> required <code>sheet_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Type Description <code>Worksheet</code> <p>The Worksheet object for the project.</p> Source code in <code>src/albert/collections/worksheets.py</code> <pre><code>def setup_new_sheet_from_template(\n    self, *, project_id: ProjectId, sheet_template_id: str, sheet_name: str\n) -&gt; Worksheet:\n    \"\"\"Create a new sheet in the Worksheet related to the specified Project from a template.\n\n    Parameters\n    ----------\n    project_id : str\n        _description_\n    sheet_template_id : str\n        _description_\n    sheet_name : str\n        _description_\n\n    Returns\n    -------\n    Worksheet\n        The Worksheet object for the project.\n    \"\"\"\n    payload = {\"name\": sheet_name}\n    params = {\"templateId\": sheet_template_id}\n    path = f\"{self.base_path}/project/{project_id}/sheets\"\n    self.session.post(path, json=payload, params=params)\n    return self.get_by_project_id(project_id=project_id)\n</code></pre>"},{"location":"albert/#albert.albert.WorksheetCollection.setup_worksheet","title":"setup_worksheet","text":"<pre><code>setup_worksheet(\n    *, project_id: ProjectId, add_sheet=False\n) -&gt; Worksheet\n</code></pre> <p>Setup a new worksheet for a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The project ID to setup the worksheet for.</p> required <code>add_sheet</code> <code>bool</code> <p>Whether to add a blank sheet to the worksheet, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>Worksheet</code> <p>The Worksheet object for the project.</p> Source code in <code>src/albert/collections/worksheets.py</code> <pre><code>def setup_worksheet(self, *, project_id: ProjectId, add_sheet=False) -&gt; Worksheet:\n    \"\"\"Setup a new worksheet for a project.\n\n    Parameters\n    ----------\n    project_id : str\n        The project ID to setup the worksheet for.\n    add_sheet : bool, optional\n        Whether to add a blank sheet to the worksheet, by default False\n\n    Returns\n    -------\n    Worksheet\n        The Worksheet object for the project.\n    \"\"\"\n\n    params = {\"sheets\": str(add_sheet).lower()}\n    path = f\"{self.base_path}/{project_id}/setup\"\n    self.session.post(path, json=params)\n    return self.get_by_project_id(project_id=project_id)\n</code></pre>"},{"location":"attachments/","title":"Attachments","text":""},{"location":"attachments/#albert.collections.attachments.Attachment","title":"Attachment","text":"<p>               Bases: <code>BaseResource</code></p> <p>Used for attching files to Notes on Tasks, Projects, Inventory, etc. Key should match File.name</p>"},{"location":"attachments/#albert.collections.attachments.Attachment.category","title":"category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category: Literal[OTHER] | None = None\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Attachment.file_size","title":"file_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_size: int | None = Field(\n    default=None,\n    alias=\"fileSize\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Attachment.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Attachment.key","title":"key  <code>instance-attribute</code>","text":"<pre><code>key: str\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Attachment.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, str] | None = Field(\n    default=None,\n    alias=\"Metadata\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Attachment.mime_type","title":"mime_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mime_type: str | None = Field(\n    default=None,\n    alias=\"mimeType\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Attachment.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Attachment.namespace","title":"namespace  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>namespace: str = Field(default='result', alias='nameSpace')\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Attachment.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: str = Field(..., alias='parentId')\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Attachment.signed_url","title":"signed_url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>signed_url: str | None = Field(\n    default=None,\n    alias=\"signedURL\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Attachment.signed_url_v2","title":"signed_url_v2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>signed_url_v2: str | None = Field(\n    default=None,\n    alias=\"signedURLV2\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.AttachmentCollection","title":"AttachmentCollection","text":"<pre><code>AttachmentCollection(*, session)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>AttachmentCollection is a collection class for managing Attachment entities in the Albert platform.</p> <p>Methods:</p> Name Description <code>attach_file_to_note</code> <p>Attaches an already uploaded file to a note.</p> <code>delete</code> <p>Deletes an attachment by ID.</p> <code>upload_and_attach_file_as_note</code> <p>Uploads a file and attaches it to a new note. A user can be tagged in the note_text string by using f-string and the User.to_note_mention() method.</p> Source code in <code>src/albert/collections/attachments.py</code> <pre><code>def __init__(self, *, session):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{AttachmentCollection._api_version}/attachments\"\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.AttachmentCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/attachments'\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.AttachmentCollection.attach_file_to_note","title":"attach_file_to_note","text":"<pre><code>attach_file_to_note(\n    *,\n    note_id: str,\n    file_name: str,\n    file_key: str,\n    category: FileCategory = OTHER,\n) -&gt; Attachment\n</code></pre> <p>Attaches an already uploaded file to a note.</p> <p>Parameters:</p> Name Type Description Default <code>note_id</code> <code>str</code> <p>The ID of the note to attach the file to.</p> required <code>file_name</code> <code>str</code> <p>The name of the file to attach.</p> required <code>file_key</code> <code>str</code> <p>The unique key of the file to attach (the returned upload name).</p> required <code>category</code> <code>FileCategory</code> <p>The type of file, by default FileCategory.OTHER</p> <code>OTHER</code> <p>Returns:</p> Type Description <code>Attachment</code> <p>The related attachment object.</p> Source code in <code>src/albert/collections/attachments.py</code> <pre><code>def attach_file_to_note(\n    self,\n    *,\n    note_id: str,\n    file_name: str,\n    file_key: str,\n    category: FileCategory = FileCategory.OTHER,\n) -&gt; Attachment:\n    \"\"\"Attaches an already uploaded file to a note.\n\n    Parameters\n    ----------\n    note_id : str\n        The ID of the note to attach the file to.\n    file_name : str\n        The name of the file to attach.\n    file_key : str\n        The unique key of the file to attach (the returned upload name).\n    category : FileCategory, optional\n        The type of file, by default FileCategory.OTHER\n\n    Returns\n    -------\n    Attachment\n        The related attachment object.\n    \"\"\"\n    attachment = Attachment(\n        parent_id=note_id, name=file_name, key=file_key, namespace=\"result\", category=category\n    )\n    response = self.session.post(\n        url=self.base_path,\n        json=attachment.model_dump(by_alias=True, mode=\"json\", exclude_unset=True),\n    )\n    return Attachment(**response.json())\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.AttachmentCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes an attachment by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the attachment to delete.</p> required Source code in <code>src/albert/collections/attachments.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Deletes an attachment by ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the attachment to delete.\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.AttachmentCollection.upload_and_attach_file_as_note","title":"upload_and_attach_file_as_note","text":"<pre><code>upload_and_attach_file_as_note(\n    parent_id: str,\n    file_data: IO,\n    note_text: str = \"\",\n    file_name: str = \"\",\n) -&gt; Note\n</code></pre> <p>Uploads a file and attaches it to a new note. A user can be tagged in the note_text string by using f-string and the User.to_note_mention() method. This allows for easy tagging and referencing of users within notes. example: f\"Hello {tagged_user.to_note_mention()}!\"</p> <pre><code>Parameters\n</code></pre> <pre><code>parent_id : str\n    The ID of the parent entity onto which the note will be attached.\nfile_data : IO\n    The file data to upload.\nnote_text : str, optional\n    Any additional text to add to the note, by default \"\"\nfile_name : str, optional\n    The name of the file, by default \"\"\n</code></pre> <pre><code>Returns\n</code></pre> <pre><code>Note\n    The created note.\n</code></pre> Source code in <code>src/albert/collections/attachments.py</code> <pre><code>def upload_and_attach_file_as_note(\n    self, parent_id: str, file_data: IO, note_text: str = \"\", file_name: str = \"\"\n) -&gt; Note:\n    \"\"\"Uploads a file and attaches it to a new note. A user can be tagged in the note_text string by using f-string and the User.to_note_mention() method.\n    This allows for easy tagging and referencing of users within notes. example: f\"Hello {tagged_user.to_note_mention()}!\"\n\n        Parameters\n        ----------\n        parent_id : str\n            The ID of the parent entity onto which the note will be attached.\n        file_data : IO\n            The file data to upload.\n        note_text : str, optional\n            Any additional text to add to the note, by default \"\"\n        file_name : str, optional\n            The name of the file, by default \"\"\n\n        Returns\n        -------\n        Note\n            The created note.\n    \"\"\"\n    file_type = mimetypes.guess_type(file_name)[0]\n    file_collection = self._get_file_collection()\n    note_collection = self._get_note_collection()\n\n    file_collection.sign_and_upload_file(\n        data=file_data,\n        name=file_name,\n        namespace=FileNamespace.RESULT.value,\n        content_type=file_type,\n    )\n    file_info = file_collection.get_by_name(\n        name=file_name, namespace=FileNamespace.RESULT.value\n    )\n    note = Note(\n        parent_id=parent_id,\n        note=note_text,\n    )\n    registered_note = note_collection.create(note=note)\n    self.attach_file_to_note(\n        note_id=registered_note.id,\n        file_name=file_name,\n        file_key=file_info.name,\n    )\n    return note_collection.get_by_id(id=registered_note.id)\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileCategory","title":"FileCategory","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"attachments/#albert.collections.attachments.FileCategory.OTHER","title":"OTHER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTHER = 'Other'\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileCategory.SDS","title":"SDS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SDS = 'SDS'\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileCollection","title":"FileCollection","text":"<pre><code>FileCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>FileCollection is a collection class for managing File entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>get_by_name</code> <p>Gets a file by name and namespace.</p> <code>get_signed_download_url</code> <p>Get a signed download URL for a file.</p> <code>get_signed_upload_url</code> <p>Get a signed upload URL for a file.</p> <code>sign_and_upload_file</code> <p>Sign and upload a file to Albert.</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initialize the FileCllection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{FileCollection._api_version}/files\"\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/files'\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(\n    *,\n    name: str,\n    namespace: FileNamespace,\n    generic: bool = False,\n) -&gt; FileInfo\n</code></pre> <p>Gets a file by name and namespace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The Name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>generic</code> <code>bool</code> <p>description, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>FileInfo</code> <p>The file information related to the matching file.</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def get_by_name(\n    self,\n    *,\n    name: str,\n    namespace: FileNamespace,\n    generic: bool = False,\n) -&gt; FileInfo:\n    \"\"\"Gets a file by name and namespace.\n\n    Parameters\n    ----------\n    name : str\n        The Name of the file\n    namespace : FileNamespace\n        The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    generic : bool, optional\n        _description_, by default False\n\n    Returns\n    -------\n    FileInfo\n        The file information related to the matching file.\n    \"\"\"\n    params = {\n        \"name\": name,\n        \"namespace\": namespace,\n        \"generic\": json.dumps(generic),\n    }\n    response = self.session.get(f\"{self.base_path}/info\", params=params)\n    return FileInfo(**response.json())\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileCollection.get_signed_download_url","title":"get_signed_download_url","text":"<pre><code>get_signed_download_url(\n    *,\n    name: str,\n    namespace: FileNamespace,\n    version_id: str | None = None,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str\n</code></pre> <p>Get a signed download URL for a file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The Name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>version_id</code> <code>str | None</code> <p>The version of the file, by default None</p> <code>None</code> <code>category</code> <code>FileCategory | None</code> <p>The file category (E.g., SDS, OTHER), by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>description</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def get_signed_download_url(\n    self,\n    *,\n    name: str,\n    namespace: FileNamespace,\n    version_id: str | None = None,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str:\n    \"\"\"Get a signed download URL for a file.\n\n    Parameters\n    ----------\n    name : str\n        The Name of the file\n    namespace : FileNamespace\n        The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    version_id : str | None, optional\n        The version of the file, by default None\n    category : FileCategory | None, optional\n        The file category (E.g., SDS, OTHER), by default None\n\n    Returns\n    -------\n    str\n        _description_\n    \"\"\"\n    params = {\n        \"name\": name,\n        \"namespace\": namespace,\n        \"versionId\": version_id,\n        \"generic\": json.dumps(generic),\n        \"category\": category,\n    }\n    response = self.session.get(\n        f\"{self.base_path}/sign\",\n        params={k: v for k, v in params.items() if v is not None},\n    )\n    return response.json()[\"URL\"]\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileCollection.get_signed_upload_url","title":"get_signed_upload_url","text":"<pre><code>get_signed_upload_url(\n    *,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str\n</code></pre> <p>Get a signed upload URL for a file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The Name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>content_type</code> <code>str</code> <p>The content type of the file</p> required <code>category</code> <code>FileCategory | None</code> <p>The File category (E.g., SDS, OTHER), by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>description</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def get_signed_upload_url(\n    self,\n    *,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str:\n    \"\"\"Get a signed upload URL for a file.\n\n    Parameters\n    ----------\n    name : str\n        The Name of the file\n    namespace : FileNamespace\n        The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    content_type : str\n        The content type of the file\n    category : FileCategory | None, optional\n        The File category (E.g., SDS, OTHER), by default None\n\n    Returns\n    -------\n    str\n        _description_\n    \"\"\"\n    params = {\"generic\": json.dumps(generic)}\n\n    post_body = SignURLPOST(\n        files=[\n            SignURLPOSTFile(\n                name=name,\n                namespace=namespace,\n                content_type=content_type,\n                category=category,\n            )\n        ]\n    )\n\n    response = self.session.post(\n        f\"{self.base_path}/sign\",\n        json=post_body.model_dump(by_alias=True, exclude_unset=True, mode=\"json\"),\n        params=params,\n    )\n    return response.json()[0][\"URL\"]\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileCollection.sign_and_upload_file","title":"sign_and_upload_file","text":"<pre><code>sign_and_upload_file(\n    data: IO,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; None\n</code></pre> <p>Sign and upload a file to Albert.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>IO</code> <p>The file data</p> required <code>name</code> <code>str</code> <p>The name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The File Namespace (e.g., AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>content_type</code> <code>str</code> <p>The content type of the file</p> required <code>category</code> <code>FileCategory | None</code> <p>The category of the file (E.g., SDS, OTHER), by default None</p> <code>None</code> Source code in <code>src/albert/collections/files.py</code> <pre><code>def sign_and_upload_file(\n    self,\n    data: IO,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; None:\n    \"\"\"Sign and upload a file to Albert.\n\n    Parameters\n    ----------\n    data : IO\n        The file data\n    name : str\n        The name of the file\n    namespace : FileNamespace\n        The File Namespace (e.g., AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    content_type : str\n        The content type of the file\n    category : FileCategory | None, optional\n        The category of the file (E.g., SDS, OTHER), by default None\n    \"\"\"\n    upload_url = self.get_signed_upload_url(\n        name=name,\n        namespace=namespace,\n        content_type=content_type,\n        generic=generic,\n        category=category,\n    )\n    requests.put(upload_url, data=data, headers={\"Content-Type\": content_type})\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileNamespace","title":"FileNamespace","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"attachments/#albert.collections.attachments.FileNamespace.AGENT","title":"AGENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AGENT = 'agent'\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileNamespace.BREAKTHROUGH","title":"BREAKTHROUGH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BREAKTHROUGH = 'breakthrough'\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileNamespace.PIPELINE","title":"PIPELINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PIPELINE = 'pipeline'\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileNamespace.PUBLIC","title":"PUBLIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PUBLIC = 'public'\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileNamespace.RESULT","title":"RESULT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESULT = 'result'\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.FileNamespace.SDS","title":"SDS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SDS = 'sds'\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Note","title":"Note","text":"<p>               Bases: <code>BaseResource</code></p> <p>Represents a Note on the Albert Platform. Users can be mentioned in notes by using f-string and the User.to_note_mention() method. This allows for easy tagging and referencing of users within notes. example: f\"Hello {tagged_user.to_note_mention()}!\"</p>"},{"location":"attachments/#albert.collections.attachments.Note.attachments","title":"attachments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attachments: list[EntityLink] | None = Field(\n    default=None,\n    exclude=True,\n    frozen=True,\n    alias=\"Attachments\",\n)\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Note.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Note.note","title":"note  <code>instance-attribute</code>","text":"<pre><code>note: str\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.Note.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: str = Field(..., alias='parentId')\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.NotesCollection","title":"NotesCollection","text":"<pre><code>NotesCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>NotesCollection is a collection class for managing Note entities in the Albert platform.</p> <p>Methods:</p> Name Description <code>create</code> <p>Creates a new note.</p> <code>delete</code> <p>Deletes a note by its ID.</p> <code>get_by_id</code> <p>Retrieves a note by its ID.</p> <code>list</code> <p>Lists notes by their parent ID.</p> <code>update</code> <p>Updates a note.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{NotesCollection._api_version}/notes\"\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.NotesCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/notes'\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.NotesCollection.create","title":"create","text":"<pre><code>create(*, note: Note) -&gt; Note\n</code></pre> <p>Creates a new note.</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>str</code> <p>The note content.</p> required <p>Returns:</p> Type Description <code>Note</code> <p>The created note.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def create(self, *, note: Note) -&gt; Note:\n    \"\"\"\n    Creates a new note.\n\n    Parameters\n    ----------\n    note : str\n        The note content.\n\n    Returns\n    -------\n    Note\n        The created note.\n    \"\"\"\n    response = self.session.post(\n        self.base_path, json=note.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    )\n    return Note(**response.json())\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.NotesCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a note by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the note to delete.</p> required Source code in <code>src/albert/collections/notes.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a note by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the note to delete.\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.NotesCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Note\n</code></pre> <p>Retrieves a note by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the note to retrieve.</p> required <p>Returns:</p> Type Description <code>Note</code> <p>The note if found, None otherwise.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Note:\n    \"\"\"\n    Retrieves a note by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the note to retrieve.\n\n    Returns\n    -------\n    Note\n        The note if found, None otherwise.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return Note(**response.json())\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.NotesCollection.list","title":"list","text":"<pre><code>list(\n    *, parent_id: str, order_by: OrderBy = DESCENDING\n) -&gt; list[Note]\n</code></pre> <p>Lists notes by their parent ID.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>str</code> <p>The parent ID of the notes to list.</p> required <code>order_by</code> <code>OrderBy</code> <p>The order to list notes in, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <p>Returns:</p> Type Description <code>List[Note]</code> <p>The list of notes.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def list(self, *, parent_id: str, order_by: OrderBy = OrderBy.DESCENDING) -&gt; list[Note]:\n    \"\"\"\n    Lists notes by their parent ID.\n\n    Parameters\n    ----------\n    parent_id : str\n        The parent ID of the notes to list.\n    order_by : OrderBy, optional\n        The order to list notes in, by default OrderBy.DESCENDING.\n\n    Returns\n    -------\n    List[Note]\n        The list of notes.\n    \"\"\"\n\n    params = {\"parentId\": parent_id, \"orderBy\": order_by.value}\n    return AlbertPaginator(\n        session=self.session,\n        path=self.base_path,\n        mode=PaginationMode.KEY,\n        params=params,\n        deserialize=lambda items: [Note(**item) for item in items],\n    )\n</code></pre>"},{"location":"attachments/#albert.collections.attachments.NotesCollection.update","title":"update","text":"<pre><code>update(*, note: Note) -&gt; Note\n</code></pre> <p>Updates a note.</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>Note</code> <p>The note to update. The note must have an ID.</p> required <p>Returns:</p> Type Description <code>Note</code> <p>The updated note as returned by the server.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def update(self, *, note: Note) -&gt; Note:\n    \"\"\"Updates a note.\n\n    Parameters\n    ----------\n    note : Note\n        The note to update. The note must have an ID.\n\n    Returns\n    -------\n    Note\n        The updated note as returned by the server.\n    \"\"\"\n    patch = self._generate_patch_payload(\n        existing=self.get_by_id(id=note.id), updated=note, generate_metadata_diff=False\n    )\n    self.session.patch(\n        f\"{self.base_path}/{note.id}\",\n        json=patch.model_dump(mode=\"json\", by_alias=True, exclude_unset=True),\n    )\n    return self.get_by_id(id=note.id)\n</code></pre>"},{"location":"batch_data/","title":"Batch Data","text":""},{"location":"batch_data/#albert.collections.batch_data.TaskId","title":"TaskId  <code>module-attribute</code>","text":"<pre><code>TaskId = Annotated[str, AfterValidator(ensure_task_id)]\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchData","title":"BatchData","text":"<p>               Bases: <code>BaseResource</code></p>"},{"location":"batch_data/#albert.collections.batch_data.BatchData.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: TaskId | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchData.last_key","title":"last_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>last_key: str | None = Field(default=None, alias='lastKey')\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchData.product","title":"product  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>product: list[BatchDataColumn] | None = Field(\n    default=None, alias=\"Product\"\n)\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchData.rows","title":"rows  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rows: list[BatchDataRow] | None = Field(\n    default=None, alias=\"Rows\"\n)\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchData.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int | None = Field(default=None)\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchDataCollection","title":"BatchDataCollection","text":"<pre><code>BatchDataCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>BatchDataCollection is a collection class for managing BatchData entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create_batch_data</code> <p>Create a new batch data entry.</p> <code>get</code> <p>Retrieve BatchData by ID.</p> <code>update_used_batch_amounts</code> <p>Update the used batch amounts for a given task ID.</p> Source code in <code>src/albert/collections/batch_data.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the BatchDataCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{BatchDataCollection._api_version}/batchdata\"\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchDataCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/batchdata'\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchDataCollection.create_batch_data","title":"create_batch_data","text":"<pre><code>create_batch_data(*, task_id: TaskId)\n</code></pre> <p>Create a new batch data entry.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task for which the batch data is being created.</p> required <p>Returns:</p> Type Description <code>BatchData</code> <p>The created BatchData object.</p> Source code in <code>src/albert/collections/batch_data.py</code> <pre><code>def create_batch_data(self, *, task_id: TaskId):\n    \"\"\"\n    Create a new batch data entry.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task for which the batch data is being created.\n\n    Returns\n    -------\n    BatchData\n        The created BatchData object.\n    \"\"\"\n    url = f\"{self.base_path}\"\n    response = self.session.post(url, json={\"parentId\": task_id})\n    return BatchData(**response.json())\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchDataCollection.get","title":"get","text":"<pre><code>get(\n    *,\n    id: TaskId,\n    type: BatchDataType = TASK_ID,\n    limit: int = 100,\n    start_key: str | None = None,\n    order_by: OrderBy = DESCENDING,\n) -&gt; BatchData\n</code></pre> <p>Retrieve BatchData by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TaskId</code> <p>Unique Id of the selected type.</p> required <code>type</code> <code>BatchDataType</code> <p>Type of Id for which BatchData will be fetched.</p> <code>TASK_ID</code> <code>limit</code> <code>int</code> <p>The maximum number of list entities to return.</p> <code>100</code> <code>start_key</code> <code>str</code> <p>The primary key of the first item that this operation will evaluate.</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING</p> <code>DESCENDING</code> <p>Returns:</p> Type Description <code>BatchData</code> <p>The BatchData object.</p> Source code in <code>src/albert/collections/batch_data.py</code> <pre><code>def get(\n    self,\n    *,\n    id: TaskId,\n    type: BatchDataType = BatchDataType.TASK_ID,\n    limit: int = 100,\n    start_key: str | None = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n) -&gt; BatchData:\n    \"\"\"\n    Retrieve BatchData by ID.\n\n    Parameters\n    ----------\n    id : TaskId\n        Unique Id of the selected type.\n    type : BatchDataType\n        Type of Id for which BatchData will be fetched.\n    limit : int, optional\n        The maximum number of list entities to return.\n    start_key : str, optional\n        The primary key of the first item that this operation will evaluate.\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING\n    Returns\n    ------\n    BatchData\n        The BatchData object.\n    \"\"\"\n    params = {\n        \"id\": id,\n        \"limit\": limit,\n        \"type\": type,\n        \"startKey\": start_key,\n        \"orderBy\": order_by,\n    }\n    response = self.session.get(self.base_path, params=params)\n    return BatchData(**response.json())\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchDataCollection.update_used_batch_amounts","title":"update_used_batch_amounts","text":"<pre><code>update_used_batch_amounts(\n    *, task_id: str, patches=list[BatchValuePatchPayload]\n) -&gt; None\n</code></pre> <p>Update the used batch amounts for a given task ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to update.</p> required <code>patch</code> <code>BatchValuePatchPayload</code> <p>The patch payload containing the data to update.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This method does not return anything.</p> Source code in <code>src/albert/collections/batch_data.py</code> <pre><code>def update_used_batch_amounts(\n    self, *, task_id: str, patches=list[BatchValuePatchPayload]\n) -&gt; None:\n    \"\"\"\n    Update the used batch amounts for a given task ID.\n\n    Parameters\n    ----------\n    task_id : str\n        The ID of the task to update.\n    patch : BatchValuePatchPayload\n        The patch payload containing the data to update.\n\n    Returns\n    -------\n    None\n        This method does not return anything.\n    \"\"\"\n    url = f\"{self.base_path}/{task_id}/values\"\n    self.session.patch(\n        url,\n        json=[\n            patch.model_dump(exclude_none=True, by_alias=True, mode=\"json\")\n            for patch in patches\n        ],\n    )\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchDataType","title":"BatchDataType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"batch_data/#albert.collections.batch_data.BatchDataType.TASK_ID","title":"TASK_ID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TASK_ID = 'taskId'\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchValuePatchPayload","title":"BatchValuePatchPayload","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"batch_data/#albert.collections.batch_data.BatchValuePatchPayload.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: list[BatchValuePatchDatum] = Field(\n    default_factory=list\n)\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchValuePatchPayload.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: BatchValueId = Field(alias='Id')\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.BatchValuePatchPayload.lot_id","title":"lot_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lot_id: str | None = Field(default=None, alias='lotId')\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"batch_data/#albert.collections.batch_data.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"batch_data/#albert.collections.batch_data.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"btdataset/","title":"Breakthrough Datasets","text":""},{"location":"btdataset/#albert.collections.btdataset.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDataset","title":"BTDataset","text":"<p>               Bases: <code>BaseResource</code></p>"},{"location":"btdataset/#albert.collections.btdataset.BTDataset.file_name","title":"file_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file_name: str | None = Field(\n    default=None, alias=\"fileName\"\n)\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDataset.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDataset.key","title":"key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>key: str | None = Field(default=None)\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDataset.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDataset.report","title":"report  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>report: EntityLink | None = Field(\n    default=None, alias=\"Report\"\n)\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDatasetCollection","title":"BTDatasetCollection","text":"<pre><code>BTDatasetCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>BTDatasetCollection is a collection class for managing Breakthrough dataset entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base path for btdataset API requests.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new BTDataset.</p> <code>delete</code> <p>Delete a BTDataset by ID.</p> <code>get_by_id</code> <p>Get a BTDataset by ID.</p> <code>list</code> <p>List items in the BTInsight collection.</p> <code>update</code> <p>Update a BTDataset.</p> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initialize the BTDatasetCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{BTDatasetCollection._api_version}/btdataset\"\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDatasetCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/btdataset'\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDatasetCollection.create","title":"create","text":"<pre><code>create(*, dataset: BTDataset) -&gt; BTDataset\n</code></pre> <p>Create a new BTDataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>BTDataset</code> <p>The BTDataset record to create.</p> required <p>Returns:</p> Type Description <code>BTDataset</code> <p>The created BTDataset.</p> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def create(self, *, dataset: BTDataset) -&gt; BTDataset:\n    \"\"\"\n    Create a new BTDataset.\n\n    Parameters\n    ----------\n    dataset : BTDataset\n        The BTDataset record to create.\n\n    Returns\n    -------\n    BTDataset\n        The created BTDataset.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=dataset.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return BTDataset(**response.json())\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDatasetCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a BTDataset by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the BTDataset to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a BTDataset by ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the BTDataset to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDatasetCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; BTDataset\n</code></pre> <p>Get a BTDataset by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The Albert ID of the BTDataset.</p> required <p>Returns:</p> Type Description <code>BTDataset</code> <p>The retrived BTDataset.</p> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; BTDataset:\n    \"\"\"\n    Get a BTDataset by ID.\n\n    Parameters\n    ----------\n    id : str\n        The Albert ID of the BTDataset.\n\n    Returns\n    -------\n    BTDataset\n        The retrived BTDataset.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return BTDataset(**response.json())\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDatasetCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    name: str | None = None,\n    start_key: str | None = None,\n    created_by: str | None = None,\n) -&gt; Iterator[BTDataset]\n</code></pre> <p>List items in the BTInsight collection.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Number of items to return per page, default 100</p> <code>100</code> <code>name</code> <code>str</code> <p>Name of the dataset to filter by, default None</p> <code>None</code> <code>start_key</code> <code>str</code> <p>The starting key for pagination, default None</p> <code>None</code> <code>created_by</code> <code>str</code> <p>The user who created the dataset, default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[BTDataset]</code> <p>An iterator of elements returned by the BTDataset listing.</p> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    name: str | None = None,\n    start_key: str | None = None,\n    created_by: str | None = None,\n) -&gt; Iterator[BTDataset]:\n    \"\"\"List items in the BTInsight collection.\n\n    Parameters\n    ----------\n    limit : int, optional\n        Number of items to return per page, default 100\n    name : str, optional\n        Name of the dataset to filter by, default None\n    start_key : str, optional\n        The starting key for pagination, default None\n    created_by : str, optional\n        The user who created the dataset, default None\n\n    Returns\n    -------\n    Iterator[BTDataset]\n        An iterator of elements returned by the BTDataset listing.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[BTDataset]:\n        yield from [BTDataset(**item) for item in items]\n\n    params = {\n        \"limit\": limit,\n        \"startKey\": start_key,\n        \"createdBy\": created_by,\n        \"name\": name,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BTDatasetCollection.update","title":"update","text":"<pre><code>update(*, dataset: BTDataset) -&gt; BTDataset\n</code></pre> <p>Update a BTDataset.</p> <p>The provided dataset must be registered with an Albert ID.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>BTDataset</code> <p>The BTDataset with updated fields.</p> required <p>Returns:</p> Type Description <code>BTDataset</code> <p>The updated BTDataset object.</p> Source code in <code>src/albert/collections/btdataset.py</code> <pre><code>def update(self, *, dataset: BTDataset) -&gt; BTDataset:\n    \"\"\"\n    Update a BTDataset.\n\n    The provided dataset must be registered with an Albert ID.\n\n    Parameters\n    ----------\n    dataset : BTDataset\n        The BTDataset with updated fields.\n\n    Returns\n    -------\n    BTDataset\n        The updated BTDataset object.\n    \"\"\"\n    path = f\"{self.base_path}/{dataset.id}\"\n    payload = self._generate_patch_payload(\n        existing=self.get_by_id(id=dataset.id),\n        updated=dataset,\n    )\n    self.session.patch(path, json=payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=dataset.id)\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"btdataset/#albert.collections.btdataset.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"btinsight/","title":"Breakthrough Insights","text":""},{"location":"btinsight/#albert.collections.btinsight.AlbertHTTPError","title":"AlbertHTTPError","text":"<pre><code>AlbertHTTPError(response: Response)\n</code></pre> <p>               Bases: <code>AlbertException</code></p> <p>Base class for all erors due to HTTP responses.</p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, response: requests.Response):\n    message = self._format_message(response)\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.AlbertHTTPError.response","title":"response  <code>instance-attribute</code>","text":"<pre><code>response = response\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight","title":"BTInsight","text":"<p>               Bases: <code>BaseResource</code></p>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: BTInsightCategory\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.content_edited","title":"content_edited  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content_edited: bool | None = Field(\n    default=None, alias=\"contentEdited\"\n)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.dataset_id","title":"dataset_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dataset_id: str | None = Field(\n    default=None, alias=\"datasetId\"\n)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.end_time","title":"end_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_time: str | None = Field(default=None, alias='endTime')\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, Any] = Field(alias='Metadata')\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.model_session_id","title":"model_session_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_session_id: str | None = Field(\n    default=None, alias=\"modelSessionId\"\n)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.output_key","title":"output_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_key: str | None = Field(\n    default=None, alias=\"outputKey\"\n)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.payload_type","title":"payload_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>payload_type: BTInsightPayloadType | None = Field(\n    default=None, alias=\"payloadType\"\n)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.raw_payload","title":"raw_payload  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>raw_payload: dict[str, Any] | None = Field(\n    default=None, alias=\"RawPayload\"\n)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.registry","title":"registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>registry: BTInsightRegistry | None = Field(\n    default=None, alias=\"Registry\"\n)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.start_time","title":"start_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_time: str | None = Field(\n    default=None, alias=\"startTime\"\n)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: BTInsightState | None = Field(default=None)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsight.total_time","title":"total_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total_time: str | None = Field(\n    default=None, alias=\"totalTime\"\n)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCategory","title":"BTInsightCategory","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCategory.CUSTOM_OPTIMIZER","title":"CUSTOM_OPTIMIZER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CUSTOM_OPTIMIZER = 'Custom Optimizer'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCategory.GENERATE","title":"GENERATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERATE = 'Generate'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCategory.IMPACT_CHART","title":"IMPACT_CHART  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IMPACT_CHART = 'Impact Chart'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCategory.MOLECULE","title":"MOLECULE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MOLECULE = 'Molecule'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCategory.OPTIMIZER","title":"OPTIMIZER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OPTIMIZER = 'Optimizer'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCategory.SMART_DOE","title":"SMART_DOE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SMART_DOE = 'Smart DOE'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCollection","title":"BTInsightCollection","text":"<pre><code>BTInsightCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>BTInsightCollection is a collection class for managing Breakthrough insight entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base path for BTInsight API requests.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new BTInsight.</p> <code>delete</code> <p>Delete a BTInsight by ID.</p> <code>get_by_id</code> <p>Get a BTInsight by ID.</p> <code>list</code> <p>List items in the BTInsight collection.</p> <code>update</code> <p>Update a BTInsight.</p> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initialize the BTInsightCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{BTInsightCollection._api_version}/btinsight\"\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/btinsight'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCollection.create","title":"create","text":"<pre><code>create(*, insight: BTInsight) -&gt; BTInsight\n</code></pre> <p>Create a new BTInsight.</p> <p>Parameters:</p> Name Type Description Default <code>insight</code> <code>BTInsight</code> <p>The BTInsight record to create.</p> required <p>Returns:</p> Type Description <code>BTInsight</code> <p>The created BTInsight.</p> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def create(self, *, insight: BTInsight) -&gt; BTInsight:\n    \"\"\"\n    Create a new BTInsight.\n\n    Parameters\n    ----------\n    insight : BTInsight\n        The BTInsight record to create.\n\n    Returns\n    -------\n    BTInsight\n        The created BTInsight.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=insight.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return BTInsight(**response.json())\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a BTInsight by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the BTInsight to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a BTInsight by ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the BTInsight to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; BTInsight\n</code></pre> <p>Get a BTInsight by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The Albert ID of the insight.</p> required <p>Returns:</p> Type Description <code>BTInsight</code> <p>The retrived BTInsight.</p> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; BTInsight:\n    \"\"\"\n    Get a BTInsight by ID.\n\n    Parameters\n    ----------\n    id : str\n        The Albert ID of the insight.\n\n    Returns\n    -------\n    BTInsight\n        The retrived BTInsight.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return BTInsight(**response.json())\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    offset: int | None = None,\n    order_by: OrderBy | None = None,\n    sort_by: str | None = None,\n    text: str | None = None,\n    name: str | list[str] | None = None,\n    state: BTInsightState\n    | list[BTInsightState]\n    | None = None,\n    category: BTInsightCategory\n    | list[BTInsightCategory]\n    | None = None,\n) -&gt; Iterator[BTInsight]\n</code></pre> <p>List items in the BTInsight collection.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Number of items to return per page, default 100</p> <code>100</code> <code>offset</code> <code>int | None</code> <p>Item offset to begin search at, default None</p> <code>None</code> <code>order_by</code> <code>OrderBy | None</code> <p>Asc/desc ordering, default None</p> <code>None</code> <code>sort_by</code> <code>str | None</code> <p>Sort field, default None</p> <code>None</code> <code>text</code> <code>str | None</code> <p>Text field in search query, default None</p> <code>None</code> <code>name</code> <code>str | list[str] | None</code> <p>BTInsight name search filter, default None</p> <code>None</code> <code>state</code> <code>BTInsightState | list[BTInsightState] | None</code> <p>BTInsight state search filter, default None</p> <code>None</code> <code>category</code> <code>BTInsightCategory | list[BTInsightCategory] | None</code> <p>BTInsight category search filter, default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[BTInsight]</code> <p>An iterator of elements returned by the BTInsight search query.</p> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    offset: int | None = None,\n    order_by: OrderBy | None = None,\n    sort_by: str | None = None,\n    text: str | None = None,\n    name: str | list[str] | None = None,\n    state: BTInsightState | list[BTInsightState] | None = None,\n    category: BTInsightCategory | list[BTInsightCategory] | None = None,\n) -&gt; Iterator[BTInsight]:\n    \"\"\"List items in the BTInsight collection.\n\n    Parameters\n    ----------\n    limit : int, optional\n        Number of items to return per page, default 100\n    offset : int | None, optional\n        Item offset to begin search at, default None\n    order_by : OrderBy | None, optional\n        Asc/desc ordering, default None\n    sort_by : str | None\n        Sort field, default None\n    text : str | None\n        Text field in search query, default None\n    name : str | list[str] | None\n        BTInsight name search filter, default None\n    state : BTInsightState | list[BTInsightState] | None\n        BTInsight state search filter, default None\n    category : BTInsightCategory | list[BTInsightCategory] | None\n        BTInsight category search filter, default None\n\n    Returns\n    -------\n    Iterator[BTInsight]\n        An iterator of elements returned by the BTInsight search query.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[BTInsight]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching insight '{id}': {e}\")\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"order\": OrderBy(order_by).value if order_by else None,\n        \"sortBy\": sort_by,\n        \"text\": text,\n        \"name\": name,\n    }\n    if state:\n        state = state if isinstance(state, list) else [state]\n        params[\"state\"] = [BTInsightState(x).value for x in state]\n    if category:\n        category = category if isinstance(category, list) else [category]\n        params[\"category\"] = [BTInsightCategory(x).value for x in category]\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightCollection.update","title":"update","text":"<pre><code>update(*, insight: BTInsight) -&gt; BTInsight\n</code></pre> <p>Update a BTInsight.</p> <p>Parameters:</p> Name Type Description Default <code>insight</code> <code>BTInsight</code> <p>The BTInsight to update.</p> required <p>Returns:</p> Type Description <code>BTInsight</code> <p>The updated BTInsight.</p> Source code in <code>src/albert/collections/btinsight.py</code> <pre><code>def update(self, *, insight: BTInsight) -&gt; BTInsight:\n    \"\"\"Update a BTInsight.\n\n    Parameters\n    ----------\n    insight : BTInsight\n        The BTInsight to update.\n\n    Returns\n    -------\n    BTInsight\n        The updated BTInsight.\n    \"\"\"\n    path = f\"{self.base_path}/{insight.id}\"\n    payload = self._generate_patch_payload(\n        existing=self.get_by_id(id=insight.id),\n        updated=insight,\n        generate_metadata_diff=False,\n    )\n    self.session.patch(path, json=payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=insight.id)\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightState","title":"BTInsightState","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightState.BUILDING_MODELS","title":"BUILDING_MODELS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUILDING_MODELS = 'Building Models'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightState.COMPLETE","title":"COMPLETE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COMPLETE = 'Complete'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightState.ERROR","title":"ERROR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ERROR = 'Error'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightState.GENERATING_CANDIDATES","title":"GENERATING_CANDIDATES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERATING_CANDIDATES = 'Generating Candidates'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BTInsightState.QUEUED","title":"QUEUED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUEUED = 'Queued'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"btinsight/#albert.collections.btinsight.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"btinsight/#albert.collections.btinsight.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"btmodel/","title":"Breakthrough Model","text":""},{"location":"btmodel/#albert.collections.btmodel.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModel","title":"BTModel","text":"<p>               Bases: <code>BaseResource</code></p>"},{"location":"btmodel/#albert.collections.btmodel.BTModel.dataset_id","title":"dataset_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dataset_id: str = Field(..., alias='datasetId')\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModel.end_time","title":"end_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_time: str | None = Field(default=None, alias='endTime')\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModel.flag","title":"flag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flag: bool = Field(default=False)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModel.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModel.model_binary_key","title":"model_binary_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_binary_key: str | None = Field(\n    default=None, alias=\"modelBinaryKey\"\n)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModel.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModel.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: str | None = Field(\n    default=None, alias=\"parentId\"\n)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModel.start_time","title":"start_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_time: str | None = Field(\n    default=None, alias=\"startTime\"\n)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModel.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: BTModelState\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModel.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target: list[str]\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModel.total_time","title":"total_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total_time: str | None = Field(\n    default=None, alias=\"totalTime\"\n)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelCollection","title":"BTModelCollection","text":"<pre><code>BTModelCollection(\n    *, session: AlbertSession, parent_id: str\n)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>BTModelCollection is a collection class for managing Breakthrough model entities.</p> <p>Breakthrough models are associated with a parent Breakthrough model session.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <code>parent_id</code> <code>str</code> <p>The Albert ID for the parent BTModelSession.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base path for BTModel API requests.</p> <p>Methods:</p> Name Description <code>create</code> <code>delete</code> <p>Delete a BTModel by ID.</p> <code>get_by_id</code> <code>update</code> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def __init__(self, *, session: AlbertSession, parent_id: str):\n    super().__init__(session=session)\n    self.parent_id = parent_id\n    self.base_path = f\"/api/{BTModelCollection._api_version}/btmodel/{parent_id}/model\"\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f\"/api/{_api_version}/btmodel/{parent_id}/model\"\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelCollection.parent_id","title":"parent_id  <code>instance-attribute</code>","text":"<pre><code>parent_id = parent_id\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelCollection.create","title":"create","text":"<pre><code>create(*, model: BTModel) -&gt; BTModel\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def create(self, *, model: BTModel) -&gt; BTModel:\n    response = self.session.post(\n        self.base_path,\n        json=model.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return BTModel(**response.json())\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a BTModel by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the BTModel to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a BTModel by ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the BTModel to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; BTModel\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; BTModel:\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return BTModel(**response.json())\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelCollection.update","title":"update","text":"<pre><code>update(*, model: BTModel) -&gt; BTModel\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def update(self, *, model: BTModel) -&gt; BTModel:\n    path = f\"{self.base_path}/{model.id}\"\n    payload = self._generate_patch_payload(\n        existing=self.get_by_id(id=model.id),\n        updated=model,\n    )\n    self.session.patch(path, json=payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=model.id)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession","title":"BTModelSession","text":"<pre><code>BTModelSession(**data)\n</code></pre> <p>               Bases: <code>BaseSessionResource</code></p> Source code in <code>src/albert/resources/base.py</code> <pre><code>def __init__(self, **data):\n    super().__init__(**data)\n    self._session = data.get(\"session\")\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.albert_model_details","title":"albert_model_details  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>albert_model_details: dict[str, Any] | None = Field(\n    default=None, alias=\"albertModelDetails\"\n)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: BTModelCategory\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.dataset_id","title":"dataset_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dataset_id: str = Field(..., alias='datasetId')\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.default_model","title":"default_model  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_model: str | None = Field(\n    default=None, alias=\"defaultModel\"\n)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.flag","title":"flag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flag: bool = Field(default=False)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.model_count","title":"model_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_count: int | None = Field(\n    default=None, alias=\"modelCount\"\n)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.models","title":"models  <code>property</code>","text":"<pre><code>models\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.registry","title":"registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>registry: BTModelRegistry | None = Field(\n    default=None, alias=\"Registry\"\n)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>target: list[str] | None = Field(default=None)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSession.total_time","title":"total_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>total_time: str | None = Field(\n    default=None, alias=\"totalTime\"\n)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSessionCollection","title":"BTModelSessionCollection","text":"<pre><code>BTModelSessionCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>BTModelSessionCollection is a collection class for managing Breakthrough model session entities.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base path for BTModelSession API requests.</p> <p>Methods:</p> Name Description <code>create</code> <code>delete</code> <p>Delete a BTModelSession by ID.</p> <code>get_by_id</code> <code>update</code> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{BTModelSessionCollection._api_version}/btmodel\"\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSessionCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/btmodel'\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSessionCollection.create","title":"create","text":"<pre><code>create(*, model_session: BTModelSession) -&gt; BTModelSession\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def create(self, *, model_session: BTModelSession) -&gt; BTModelSession:\n    response = self.session.post(\n        self.base_path,\n        json=model_session.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return self._deserialize_with_session(response.json())\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSessionCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a BTModelSession by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the BTModelSession to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a BTModelSession by ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the BTModelSession to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSessionCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; BTModelSession\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; BTModelSession:\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return self._deserialize_with_session(response.json())\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BTModelSessionCollection.update","title":"update","text":"<pre><code>update(*, model_session: BTModelSession) -&gt; BTModelSession\n</code></pre> Source code in <code>src/albert/collections/btmodel.py</code> <pre><code>def update(self, *, model_session: BTModelSession) -&gt; BTModelSession:\n    path = f\"{self.base_path}/{model_session.id}\"\n    payload = self._generate_patch_payload(\n        existing=self.get_by_id(id=model_session.id),\n        updated=model_session,\n    )\n    self.session.patch(path, json=payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=model_session.id)\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"btmodel/#albert.collections.btmodel.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"cas/","title":"Cas","text":""},{"location":"cas/#albert.collections.cas.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"cas/#albert.collections.cas.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"cas/#albert.collections.cas.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"cas/#albert.collections.cas.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"cas/#albert.collections.cas.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"cas/#albert.collections.cas.Cas","title":"Cas  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a CAS entity.</p> Show JSON schema: <pre><code>{\n  \"$defs\": {\n    \"CasCategory\": {\n      \"enum\": [\n        \"User\",\n        \"Verisk\",\n        \"TSCA - Public\",\n        \"TSCA - Private\",\n        \"not TSCA\",\n        \"CAS linked to External Database\",\n        \"Unknown (Trade Secret)\",\n        \"CL_Inventory Upload\"\n      ],\n      \"title\": \"CasCategory\",\n      \"type\": \"string\"\n    },\n    \"Hazard\": {\n      \"description\": \"Represents a chemical hazard.\",\n      \"properties\": {\n        \"subCategory\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"description\": \"Hazard subcategory\",\n          \"title\": \"Subcategory\"\n        },\n        \"hCode\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"description\": \"Hazard code\",\n          \"title\": \"Hcode\"\n        },\n        \"category\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"description\": \"Hazard category\",\n          \"title\": \"Category\"\n        },\n        \"class\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"description\": \"Hazard classification\",\n          \"title\": \"Class\"\n        },\n        \"hCodeText\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"description\": \"Hazard code text\",\n          \"title\": \"Hcodetext\"\n        }\n      },\n      \"title\": \"Hazard\",\n      \"type\": \"object\"\n    }\n  },\n  \"description\": \"Represents a CAS entity.\",\n  \"properties\": {\n    \"number\": {\n      \"description\": \"The CAS number.\",\n      \"title\": \"Number\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"Name of the CAS.\",\n      \"title\": \"Name\"\n    },\n    \"description\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"The description or name of the CAS.\",\n      \"title\": \"Description\"\n    },\n    \"notes\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"Notes related to the CAS.\",\n      \"title\": \"Notes\"\n    },\n    \"category\": {\n      \"anyOf\": [\n        {\n          \"$ref\": \"#/$defs/CasCategory\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"The category of the CAS.\"\n    },\n    \"casSmiles\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"CAS SMILES notation.\",\n      \"title\": \"Cassmiles\"\n    },\n    \"inchiKey\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"InChIKey of the CAS.\",\n      \"title\": \"Inchikey\"\n    },\n    \"iUpacName\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"IUPAC name of the CAS.\",\n      \"title\": \"Iupacname\"\n    },\n    \"albertId\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"The AlbertID of the CAS.\",\n      \"title\": \"Albertid\"\n    },\n    \"hazards\": {\n      \"anyOf\": [\n        {\n          \"items\": {\n            \"$ref\": \"#/$defs/Hazard\"\n          },\n          \"type\": \"array\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"Hazards associated with the CAS.\",\n      \"title\": \"Hazards\"\n    },\n    \"wgk\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"German Water Hazard Class (WGK) number.\",\n      \"title\": \"Wgk\"\n    },\n    \"ecListNo\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"European Community (EC) number.\",\n      \"title\": \"Eclistno\"\n    },\n    \"type\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"Type of the CAS.\",\n      \"title\": \"Type\"\n    },\n    \"classificationType\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"Classification type of the CAS.\",\n      \"title\": \"Classificationtype\"\n    },\n    \"order\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"CAS order.\",\n      \"title\": \"Order\"\n    }\n  },\n  \"required\": [\n    \"number\"\n  ],\n  \"title\": \"Cas\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>number</code>                 (<code>str</code>)             </li> <li> <code>name</code>                 (<code>str | None</code>)             </li> <li> <code>description</code>                 (<code>str | None</code>)             </li> <li> <code>notes</code>                 (<code>str | None</code>)             </li> <li> <code>category</code>                 (<code>CasCategory | None</code>)             </li> <li> <code>smiles</code>                 (<code>str | None</code>)             </li> <li> <code>inchi_key</code>                 (<code>str | None</code>)             </li> <li> <code>iupac_name</code>                 (<code>str | None</code>)             </li> <li> <code>id</code>                 (<code>str | None</code>)             </li> <li> <code>hazards</code>                 (<code>list[Hazard] | None</code>)             </li> <li> <code>wgk</code>                 (<code>str | None</code>)             </li> <li> <code>ec_number</code>                 (<code>str | None</code>)             </li> <li> <code>type</code>                 (<code>str | None</code>)             </li> <li> <code>classification_type</code>                 (<code>str | None</code>)             </li> <li> <code>order</code>                 (<code>str | None</code>)             </li> </ul>"},{"location":"cas/#albert.collections.cas.Cas.category","title":"category  <code>pydantic-field</code>","text":"<pre><code>category: CasCategory | None = None\n</code></pre> <p>The category of the CAS.</p>"},{"location":"cas/#albert.collections.cas.Cas.classification_type","title":"classification_type  <code>pydantic-field</code>","text":"<pre><code>classification_type: str | None = None\n</code></pre> <p>Classification type of the CAS.</p>"},{"location":"cas/#albert.collections.cas.Cas.description","title":"description  <code>pydantic-field</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>The description or name of the CAS.</p>"},{"location":"cas/#albert.collections.cas.Cas.ec_number","title":"ec_number  <code>pydantic-field</code>","text":"<pre><code>ec_number: str | None = None\n</code></pre> <p>European Community (EC) number.</p>"},{"location":"cas/#albert.collections.cas.Cas.hazards","title":"hazards  <code>pydantic-field</code>","text":"<pre><code>hazards: list[Hazard] | None = None\n</code></pre> <p>Hazards associated with the CAS.</p>"},{"location":"cas/#albert.collections.cas.Cas.id","title":"id  <code>pydantic-field</code>","text":"<pre><code>id: str | None = None\n</code></pre> <p>The AlbertID of the CAS.</p>"},{"location":"cas/#albert.collections.cas.Cas.inchi_key","title":"inchi_key  <code>pydantic-field</code>","text":"<pre><code>inchi_key: str | None = None\n</code></pre> <p>InChIKey of the CAS.</p>"},{"location":"cas/#albert.collections.cas.Cas.iupac_name","title":"iupac_name  <code>pydantic-field</code>","text":"<pre><code>iupac_name: str | None = None\n</code></pre> <p>IUPAC name of the CAS.</p>"},{"location":"cas/#albert.collections.cas.Cas.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: str | None = None\n</code></pre> <p>Name of the CAS.</p>"},{"location":"cas/#albert.collections.cas.Cas.notes","title":"notes  <code>pydantic-field</code>","text":"<pre><code>notes: str | None = None\n</code></pre> <p>Notes related to the CAS.</p>"},{"location":"cas/#albert.collections.cas.Cas.number","title":"number  <code>pydantic-field</code>","text":"<pre><code>number: str\n</code></pre> <p>The CAS number.</p>"},{"location":"cas/#albert.collections.cas.Cas.order","title":"order  <code>pydantic-field</code>","text":"<pre><code>order: str | None = None\n</code></pre> <p>CAS order.</p>"},{"location":"cas/#albert.collections.cas.Cas.smiles","title":"smiles  <code>pydantic-field</code>","text":"<pre><code>smiles: str | None = None\n</code></pre> <p>CAS SMILES notation.</p>"},{"location":"cas/#albert.collections.cas.Cas.type","title":"type  <code>pydantic-field</code>","text":"<pre><code>type: str | None = None\n</code></pre> <p>Type of the CAS.</p>"},{"location":"cas/#albert.collections.cas.Cas.wgk","title":"wgk  <code>pydantic-field</code>","text":"<pre><code>wgk: str | None = None\n</code></pre> <p>German Water Hazard Class (WGK) number.</p>"},{"location":"cas/#albert.collections.cas.Cas.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(*, number: str) -&gt; Cas\n</code></pre> <p>Creates a Cas object from a string.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The CAS number.</p> required <p>Returns:</p> Type Description <code>Cas</code> <p>The Cas object created from the string.</p> Source code in <code>src/albert/resources/cas.py</code> <pre><code>@classmethod\ndef from_string(cls, *, number: str) -&gt; \"Cas\":\n    \"\"\"\n    Creates a Cas object from a string.\n\n    Parameters\n    ----------\n    number : str\n        The CAS number.\n\n    Returns\n    -------\n    Cas\n        The Cas object created from the string.\n    \"\"\"\n    return cls(number=number)\n</code></pre>"},{"location":"cas/#albert.collections.cas.CasCollection","title":"CasCollection","text":"<pre><code>CasCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>CasCollection is a collection class for managing Cas entities on the Albert Platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>cas_exists</code> <p>Checks if a CAS exists by its number.</p> <code>create</code> <p>Creates a new CAS entity.</p> <code>delete</code> <p>Deletes a CAS by its ID.</p> <code>get_by_id</code> <p>Retrieves a CAS by its ID.</p> <code>get_by_number</code> <p>Retrieves a CAS by its number.</p> <code>list</code> <p>Lists CAS entities with optional filters.</p> <code>update</code> <p>Updates a CAS entity. The updated object must have the same ID as the object you want to update.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CasCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{CasCollection._api_version}/cas\"\n</code></pre>"},{"location":"cas/#albert.collections.cas.CasCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/cas'\n</code></pre>"},{"location":"cas/#albert.collections.cas.CasCollection.cas_exists","title":"cas_exists","text":"<pre><code>cas_exists(\n    *, number: str, exact_match: bool = True\n) -&gt; bool\n</code></pre> <p>Checks if a CAS exists by its number.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The number of the CAS to check.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the number exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the CAS exists, False otherwise.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def cas_exists(self, *, number: str, exact_match: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if a CAS exists by its number.\n\n    Parameters\n    ----------\n    number : str\n        The number of the CAS to check.\n    exact_match : bool, optional\n        Whether to match the number exactly, by default True.\n\n    Returns\n    -------\n    bool\n        True if the CAS exists, False otherwise.\n    \"\"\"\n    cas_list = self.get_by_number(number=number, exact_match=exact_match)\n    return cas_list is not None\n</code></pre>"},{"location":"cas/#albert.collections.cas.CasCollection.create","title":"create","text":"<pre><code>create(*, cas: str | Cas) -&gt; Cas\n</code></pre> <p>Creates a new CAS entity.</p> <p>Parameters:</p> Name Type Description Default <code>cas</code> <code>Union[str, Cas]</code> <p>The CAS number or Cas object to create.</p> required <p>Returns:</p> Type Description <code>Cas</code> <p>The created Cas object.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def create(self, *, cas: str | Cas) -&gt; Cas:\n    \"\"\"\n    Creates a new CAS entity.\n\n    Parameters\n    ----------\n    cas : Union[str, Cas]\n        The CAS number or Cas object to create.\n\n    Returns\n    -------\n    Cas\n        The created Cas object.\n    \"\"\"\n    if isinstance(cas, str):\n        cas = Cas(number=cas)\n    hit = self.get_by_number(number=cas.number, exact_match=True)\n    if hit:\n        return hit\n    else:\n        payload = cas.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n        response = self.session.post(self.base_path, json=payload)\n        cas = Cas(**response.json())\n        return cas\n</code></pre>"},{"location":"cas/#albert.collections.cas.CasCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a CAS by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the CAS to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a CAS by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the CAS to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"cas/#albert.collections.cas.CasCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Cas\n</code></pre> <p>Retrieves a CAS by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the CAS to retrieve.</p> required <p>Returns:</p> Type Description <code>Cas</code> <p>The Cas object if found, None otherwise.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Cas:\n    \"\"\"\n    Retrieves a CAS by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the CAS to retrieve.\n\n    Returns\n    -------\n    Cas\n        The Cas object if found, None otherwise.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    cas = Cas(**response.json())\n    return cas\n</code></pre>"},{"location":"cas/#albert.collections.cas.CasCollection.get_by_number","title":"get_by_number","text":"<pre><code>get_by_number(\n    *, number: str, exact_match: bool = True\n) -&gt; Cas | None\n</code></pre> <p>Retrieves a CAS by its number.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The number of the CAS to retrieve.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the number exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[Cas]</code> <p>The Cas object if found, None otherwise.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def get_by_number(self, *, number: str, exact_match: bool = True) -&gt; Cas | None:\n    \"\"\"\n    Retrieves a CAS by its number.\n\n    Parameters\n    ----------\n    number : str\n        The number of the CAS to retrieve.\n    exact_match : bool, optional\n        Whether to match the number exactly, by default True.\n\n    Returns\n    -------\n    Optional[Cas]\n        The Cas object if found, None otherwise.\n    \"\"\"\n    found = self.list(number=number)\n    if exact_match:\n        for f in found:\n            if self._clean_cas_number(f.number) == self._clean_cas_number(number):\n                return f\n    return next(found, None)\n</code></pre>"},{"location":"cas/#albert.collections.cas.CasCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 50,\n    start_key: str | None = None,\n    number: str | None = None,\n    id: str | None = None,\n    order_by: OrderBy = DESCENDING,\n) -&gt; Iterator[Cas]\n</code></pre> <p>Lists CAS entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>The maximum number of CAS entities to return, by default 50.</p> <code>50</code> <code>start_key</code> <code>str | None</code> <p>The primary key of the first item that this operation will evaluate.</p> <code>None</code> <code>number</code> <code>str | None</code> <p>Fetches list of CAS by CAS number.</p> <code>None</code> <code>id</code> <code>str | None</code> <p>Fetches list of CAS using the CAS Albert ID.</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <p>Returns:</p> Type Description <code>Iterator[Cas]</code> <p>An iterator of Cas objects.</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 50,\n    start_key: str | None = None,\n    number: str | None = None,\n    id: str | None = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n) -&gt; Iterator[Cas]:\n    \"\"\"\n    Lists CAS entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int | None, optional\n        The maximum number of CAS entities to return, by default 50.\n    start_key : str | None, optional\n        The primary key of the first item that this operation will evaluate.\n    number : str | None, optional\n        Fetches list of CAS by CAS number.\n    id : str | None, optional\n        Fetches list of CAS using the CAS Albert ID.\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING.\n\n    Returns\n    -------\n    Iterator[Cas]\n        An iterator of Cas objects.\n    \"\"\"\n    params = {\n        \"limit\": limit,\n        \"orderBy\": order_by.value,\n        \"startKey\": start_key,\n        \"number\": number,\n        \"albertId\": id,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Cas(**item) for item in items],\n    )\n</code></pre>"},{"location":"cas/#albert.collections.cas.CasCollection.update","title":"update","text":"<pre><code>update(*, updated_object: Cas) -&gt; Cas\n</code></pre> <p>Updates a CAS entity. The updated object must have the same ID as the object you want to update.</p> <p>Parameters:</p> Name Type Description Default <code>updated_object</code> <code>Cas</code> <p>The Updated Cas object.</p> required <p>Returns:</p> Type Description <code>Cas</code> <p>The updated Cas object as it appears in Albert</p> Source code in <code>src/albert/collections/cas.py</code> <pre><code>def update(self, *, updated_object: Cas) -&gt; Cas:\n    \"\"\"Updates a CAS entity. The updated object must have the same ID as the object you want to update.\n\n    Parameters\n    ----------\n    updated_object : Cas\n        The Updated Cas object.\n\n    Returns\n    -------\n    Cas\n        The updated Cas object as it appears in Albert\n    \"\"\"\n    # Fetch the current object state from the server or database\n    existing_cas = self.get_by_id(id=updated_object.id)\n\n    # Generate the PATCH payload\n    patch_payload = self._generate_patch_payload(existing=existing_cas, updated=updated_object)\n    url = f\"{self.base_path}/{updated_object.id}\"\n    self.session.patch(url, json=patch_payload.model_dump(mode=\"json\", by_alias=True))\n\n    updated_cas = self.get_by_id(id=updated_object.id)\n    return updated_cas\n</code></pre>"},{"location":"cas/#albert.collections.cas.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"cas/#albert.collections.cas.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"cas/#albert.collections.cas.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"companies/","title":"Companies","text":""},{"location":"companies/#albert.collections.companies.AlbertException","title":"AlbertException","text":"<pre><code>AlbertException(message: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, message: str):\n    super().__init__(message)\n    self.message = message\n</code></pre>"},{"location":"companies/#albert.collections.companies.AlbertException.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"companies/#albert.collections.companies.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"companies/#albert.collections.companies.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"companies/#albert.collections.companies.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"companies/#albert.collections.companies.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"companies/#albert.collections.companies.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"companies/#albert.collections.companies.Company","title":"Company","text":"<p>               Bases: <code>BaseResource</code></p> <p>Company is a Pydantic model representing a company entity.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the company.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the company. Set when the company is retrieved from Albert.</p> <code>distance</code> <code>float | None</code> <p>The scores of a company in a search result, optional. Read-only.</p>"},{"location":"companies/#albert.collections.companies.Company.distance","title":"distance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance: float | None = Field(\n    default=None, exclude=True, frozen=True\n)\n</code></pre>"},{"location":"companies/#albert.collections.companies.Company.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"companies/#albert.collections.companies.Company.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"companies/#albert.collections.companies.CompanyCollection","title":"CompanyCollection","text":"<pre><code>CompanyCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>CompanyCollection is a collection class for managing Company entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>company_exists</code> <p>Checks if a company exists by its name.</p> <code>create</code> <p>Creates a new company entity.</p> <code>delete</code> <p>Deletes a company entity.</p> <code>get_by_id</code> <p>Get a company by its ID.</p> <code>get_by_name</code> <p>Retrieves a company by its name.</p> <code>list</code> <p>Lists company entities with optional filters.</p> <code>rename</code> <p>Renames an existing company entity.</p> <code>update</code> <p>Update a Company entity. The id of the company must be provided.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CompanyCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{CompanyCollection._api_version}/companies\"\n</code></pre>"},{"location":"companies/#albert.collections.companies.CompanyCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/companies'\n</code></pre>"},{"location":"companies/#albert.collections.companies.CompanyCollection.company_exists","title":"company_exists","text":"<pre><code>company_exists(\n    *, name: str, exact_match: bool = True\n) -&gt; bool\n</code></pre> <p>Checks if a company exists by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the company to check.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the company exists, False otherwise.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def company_exists(self, *, name: str, exact_match: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if a company exists by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the company to check.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    bool\n        True if the company exists, False otherwise.\n    \"\"\"\n    companies = self.get_by_name(name=name, exact_match=exact_match)\n    return bool(companies)\n</code></pre>"},{"location":"companies/#albert.collections.companies.CompanyCollection.create","title":"create","text":"<pre><code>create(\n    *, company: str | Company, check_if_exists: bool = True\n) -&gt; Company\n</code></pre> <p>Creates a new company entity.</p> <p>Parameters:</p> Name Type Description Default <code>company</code> <code>Union[str, Company]</code> <p>The company name or Company object to create.</p> required <code>check_if_exists</code> <code>bool</code> <p>Whether to check if the company already exists, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Company</code> <p>The created Company object.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def create(self, *, company: str | Company, check_if_exists: bool = True) -&gt; Company:\n    \"\"\"\n    Creates a new company entity.\n\n    Parameters\n    ----------\n    company : Union[str, Company]\n        The company name or Company object to create.\n    check_if_exists : bool, optional\n        Whether to check if the company already exists, by default True.\n\n    Returns\n    -------\n    Company\n        The created Company object.\n    \"\"\"\n    if isinstance(company, str):\n        company = Company(name=company)\n    hit = self.get_by_name(name=company.name, exact_match=True)\n    if check_if_exists and hit:\n        logging.warning(f\"Company {company.name} already exists with id {hit.id}.\")\n        return hit\n\n    payload = company.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    response = self.session.post(self.base_path, json=payload)\n    this_company = Company(**response.json())\n    return this_company\n</code></pre>"},{"location":"companies/#albert.collections.companies.CompanyCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a company entity.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the company to delete.</p> required Source code in <code>src/albert/collections/companies.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Deletes a company entity.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the company to delete.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"companies/#albert.collections.companies.CompanyCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Company\n</code></pre> <p>Get a company by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the company to retrieve.</p> required <p>Returns:</p> Type Description <code>Company</code> <p>The Company object.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Company:\n    \"\"\"\n    Get a company by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the company to retrieve.\n\n    Returns\n    -------\n    Company\n        The Company object.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    company = response.json()\n    found_company = Company(**company)\n    return found_company\n</code></pre>"},{"location":"companies/#albert.collections.companies.CompanyCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(\n    *, name: str, exact_match: bool = True\n) -&gt; Company | None\n</code></pre> <p>Retrieves a company by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the company to retrieve.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Company</code> <p>The Company object if found, None otherwise.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def get_by_name(self, *, name: str, exact_match: bool = True) -&gt; Company | None:\n    \"\"\"\n    Retrieves a company by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the company to retrieve.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    Company\n        The Company object if found, None otherwise.\n    \"\"\"\n    found = self.list(name=name, exact_match=exact_match)\n    return next(found, None)\n</code></pre>"},{"location":"companies/#albert.collections.companies.CompanyCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 50,\n    name: str | list[str] = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Company]\n</code></pre> <p>Lists company entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of companies to return, by default 50.</p> <code>50</code> <code>name</code> <code>Union[str, None]</code> <p>The name of the company to filter by, by default None.</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Iterator</code> <p>An iterator of Company objects.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 50,\n    name: str | list[str] = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Company]:\n    \"\"\"\n    Lists company entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of companies to return, by default 50.\n    name : Union[str, None], optional\n        The name of the company to filter by, by default None.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    Iterator\n        An iterator of Company objects.\n    \"\"\"\n    params = {\"limit\": limit, \"dupDetection\": \"false\", \"startKey\": start_key}\n    if name:\n        params[\"name\"] = name if isinstance(name, list) else [name]\n        params[\"exactMatch\"] = str(exact_match).lower()\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Company(**item) for item in items],\n    )\n</code></pre>"},{"location":"companies/#albert.collections.companies.CompanyCollection.rename","title":"rename","text":"<pre><code>rename(*, old_name: str, new_name: str) -&gt; Company\n</code></pre> <p>Renames an existing company entity.</p> <p>Parameters:</p> Name Type Description Default <code>old_name</code> <code>str</code> <p>The current name of the company.</p> required <code>new_name</code> <code>str</code> <p>The new name of the company.</p> required <p>Returns:</p> Type Description <code>Company</code> <p>The renamed Company object</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def rename(self, *, old_name: str, new_name: str) -&gt; Company:\n    \"\"\"\n    Renames an existing company entity.\n\n    Parameters\n    ----------\n    old_name : str\n        The current name of the company.\n    new_name : str\n        The new name of the company.\n\n    Returns\n    -------\n    Company\n        The renamed Company object\n    \"\"\"\n    company = self.get_by_name(name=old_name, exact_match=True)\n    if not company:\n        msg = f'Company \"{old_name}\" not found.'\n        logger.error(msg)\n        raise AlbertException(msg)\n    company_id = company.id\n    endpoint = f\"{self.base_path}/{company_id}\"\n    payload = {\n        \"data\": [\n            {\n                \"operation\": \"update\",\n                \"attribute\": \"name\",\n                \"oldValue\": old_name,\n                \"newValue\": new_name,\n            }\n        ]\n    }\n    self.session.patch(endpoint, json=payload)\n    updated_company = self.get_by_id(id=company_id)\n    return updated_company\n</code></pre>"},{"location":"companies/#albert.collections.companies.CompanyCollection.update","title":"update","text":"<pre><code>update(*, company: Company) -&gt; Company\n</code></pre> <p>Update a Company entity. The id of the company must be provided.</p> <p>Parameters:</p> Name Type Description Default <code>company</code> <code>Company</code> <p>The updated Company object.</p> required <p>Returns:</p> Type Description <code>Company</code> <p>The updated Company object as registered in Albert.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def update(self, *, company: Company) -&gt; Company:\n    \"\"\"Update a Company entity. The id of the company must be provided.\n\n    Parameters\n    ----------\n    company : Company\n        The updated Company object.\n\n    Returns\n    -------\n    Company\n        The updated Company object as registered in Albert.\n    \"\"\"\n    # Fetch the current object state from the server or database\n    current_object = self.get_by_id(id=company.id)\n\n    # Generate the PATCH payload\n    patch_payload = self._generate_patch_payload(existing=current_object, updated=company)\n    url = f\"{self.base_path}/{company.id}\"\n    self.session.patch(url, json=patch_payload.model_dump(mode=\"json\", by_alias=True))\n    updated_company = self.get_by_id(id=company.id)\n    return updated_company\n</code></pre>"},{"location":"custom_fields/","title":"Custom Fields","text":""},{"location":"custom_fields/#albert.collections.custom_fields.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField","title":"CustomField","text":"<p>               Bases: <code>BaseResource</code></p> <p>A custom field for an entity in Albert.</p> <p>Returns:</p> Type Description <code>CustomField</code> <p>A CustomField that can be used to attach Metadata to an entity in Albert.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the custom field. Cannot contain spaces.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the custom field.</p> <code>field_type</code> <code>FieldType</code> <p>The type of the custom field. Allowed values are <code>list</code> and <code>string</code>. String fields cannot be searchable and are used to set uncontrolled metadata. List fields can be searchable and are used to set controlled metadata.</p> <code>display_name</code> <code>str</code> <p>The display name of the custom field. Can contain spaces.</p> <code>searchable</code> <code>bool | None</code> <p>Whether the custom field is searchable, optional. Defaults to False.</p> <code>service</code> <code>ServiceType</code> <p>The service type the custom field is associated with.</p> <code>hidden</code> <code>bool | None</code> <p>Whether the custom field is hidden, optional. Defaults to False.</p> <code>lookup_column</code> <code>bool | None</code> <p>Whether the custom field is a lookup column, optional. Defaults to False. Only allowed for inventories.</p> <code>lookup_row</code> <code>bool | None</code> <p>Whether the custom field is a lookup row, optional. Defaults to False. Only allowed for formulas in inventories.</p> <code>category</code> <code>FieldCategory | None</code> <p>The category of the custom field, optional. Defaults to None. Required for list fields. Allowed values are <code>businessDefined</code> and <code>userDefined</code>.</p> <code>min</code> <code>int | None</code> <p>The minimum value of the custom field, optional. Defaults to None.</p> <code>max</code> <code>int | None</code> <p>The maximum value of the custom field, optional. Defaults to None.</p> <code>entity_categories</code> <code>list[EntityCategory] | None</code> <p>The entity categories of the custom field, optional. Defaults to None. Required for lookup row fields. Allowed values are <code>Formulas</code>, <code>RawMaterials</code>, <code>Consumables</code>, <code>Equipment</code>, <code>Property</code>, <code>Batch</code>, and <code>General</code>.</p> <code>ui_components</code> <code>list[UIComponent] | None</code> <p>The UI components available to the custom field, optional. Defaults to None. Allowed values are <code>create</code> and <code>details</code>.</p> <p>Methods:</p> Name Description <code>confirm_field_compatability</code>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.category","title":"category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category: FieldCategory | None = Field(default=None)\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.display_name","title":"display_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>display_name: str = Field(default=None, alias='labelName')\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.entity_categories","title":"entity_categories  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entity_categories: list[EntityCategory] | None = Field(\n    default=None, alias=\"entityCategory\"\n)\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.field_type","title":"field_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field_type: FieldType = Field(alias='type')\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.hidden","title":"hidden  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hidden: bool | None = Field(default=None)\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.lookup_column","title":"lookup_column  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lookup_column: bool | None = Field(\n    default=None, alias=\"lkpColumn\"\n)\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.lookup_row","title":"lookup_row  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lookup_row: bool | None = Field(\n    default=None, alias=\"lkpRow\"\n)\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.max","title":"max  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max: int | None = Field(default=None)\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.min","title":"min  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min: int | None = Field(default=None)\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.searchable","title":"searchable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>searchable: bool | None = Field(\n    default=None, alias=\"search\"\n)\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.service","title":"service  <code>instance-attribute</code>","text":"<pre><code>service: ServiceType\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.ui_components","title":"ui_components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ui_components: list[UIComponent] | None = Field(\n    default=None, alias=\"ui_components\"\n)\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomField.confirm_field_compatability","title":"confirm_field_compatability","text":"<pre><code>confirm_field_compatability() -&gt; CustomField\n</code></pre> Source code in <code>src/albert/resources/custom_fields.py</code> <pre><code>@model_validator(mode=\"after\")\ndef confirm_field_compatability(self) -&gt; \"CustomField\":\n    if self.field_type == FieldType.LIST and self.category is None:\n        raise ValueError(\"Category must be set for list fields\")\n    if self.lookup_column is not None and self.service != ServiceType.INVENTORIES:\n        raise ValueError(\"Lookup column is only allowed for inventories\")\n    if self.lookup_row is not None and self.service != ServiceType.INVENTORIES:\n        raise ValueError(\"Lookup row is only allowed for formulas in inventories\")\n    return self\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomFieldCollection","title":"CustomFieldCollection","text":"<pre><code>CustomFieldCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>CustomFieldCollection is a collection class for managing CustomField entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new CustomField item.</p> <code>get_by_id</code> <p>Get a CustomField item by its ID.</p> <code>get_by_name</code> <p>Get a CustomField item by its name.</p> <code>list</code> <p>Searches for CustomField items based on the provided parameters.</p> <code>update</code> <p>Update a CustomField item.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CasCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{CustomFieldCollection._api_version}/customfields\"\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomFieldCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/customfields'\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomFieldCollection.create","title":"create","text":"<pre><code>create(*, custom_field: CustomField) -&gt; CustomField\n</code></pre> <p>Create a new CustomField item.</p> <p>Parameters:</p> Name Type Description Default <code>custom_field</code> <code>CustomField</code> <p>The CustomField item to create.</p> required <p>Returns:</p> Type Description <code>CustomField</code> <p>The created CustomField item with its ID.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def create(self, *, custom_field: CustomField) -&gt; CustomField:\n    \"\"\"Create a new CustomField item.\n\n    Parameters\n    ----------\n    custom_field : CustomField\n        The CustomField item to create.\n\n    Returns\n    -------\n    CustomField\n        The created CustomField item with its ID.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=custom_field.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return CustomField(**response.json())\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomFieldCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; CustomField\n</code></pre> <p>Get a CustomField item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the CustomField item.</p> required <p>Returns:</p> Type Description <code>CustomField</code> <p>The CustomField item.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; CustomField:\n    \"\"\"Get a CustomField item by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the CustomField item.\n\n    Returns\n    -------\n    CustomField\n        The CustomField item.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return CustomField(**response.json())\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomFieldCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(\n    *, name: str, service: ServiceType | None = None\n) -&gt; CustomField | None\n</code></pre> <p>Get a CustomField item by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the CustomField item.</p> required <code>service</code> <code>ServiceType | None</code> <p>The service the field relates to, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>CustomField | None</code> <p>The CustomField item, or None if not found.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def get_by_name(self, *, name: str, service: ServiceType | None = None) -&gt; CustomField | None:\n    \"\"\"Get a CustomField item by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the CustomField item.\n    service : ServiceType | None, optional\n        The service the field relates to, by default None\n\n    Returns\n    -------\n    CustomField | None\n        The CustomField item, or None if not found.\n    \"\"\"\n    for custom_field in self.list(name=name, service=service):\n        if custom_field.name.lower() == name.lower():\n            return custom_field\n    return None\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomFieldCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    name: str | None = None,\n    service: ServiceType | None = None,\n    lookup_column: bool | None = None,\n    lookup_row: bool | None = None,\n) -&gt; Iterator[CustomField]\n</code></pre> <p>Searches for CustomField items based on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the field, by default None</p> <code>None</code> <code>service</code> <code>ServiceType | None</code> <p>The related service the field is in, by default None</p> <code>None</code> <code>lookup_column</code> <code>bool | None</code> <p>Whether the field relates to a lookup column, by default None</p> <code>None</code> <code>lookup_row</code> <code>bool | None</code> <p>Whether the field relates to a lookup row, by default None</p> <code>None</code> <p>Yields:</p> Type Description <code>Iterator[CustomField]</code> <p>Returns an iterator of CustomField items matching the search criteria.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def list(\n    self,\n    *,\n    name: str | None = None,\n    service: ServiceType | None = None,\n    lookup_column: bool | None = None,\n    lookup_row: bool | None = None,\n) -&gt; Iterator[CustomField]:\n    \"\"\"Searches for CustomField items based on the provided parameters.\n\n    Parameters\n    ----------\n    name : str | None, optional\n        The name of the field, by default None\n    service : ServiceType | None, optional\n        The related service the field is in, by default None\n    lookup_column : bool | None, optional\n        Whether the field relates to a lookup column, by default None\n    lookup_row : bool | None, optional\n        Whether the field relates to a lookup row, by default None\n\n    Yields\n    ------\n    Iterator[CustomField]\n        Returns an iterator of CustomField items matching the search criteria.\n    \"\"\"\n    params = {\n        \"name\": name,\n        \"service\": service if service else None,\n        \"lookupColumn\": json.dumps(lookup_column) if lookup_column is not None else None,\n        \"lookupRow\": json.dumps(lookup_row) if lookup_row is not None else None,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        params=params,\n        session=self.session,\n        deserialize=lambda items: [CustomField(**item) for item in items],\n    )\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.CustomFieldCollection.update","title":"update","text":"<pre><code>update(*, custom_field: CustomField) -&gt; CustomField\n</code></pre> <p>Update a CustomField item.</p> <p>Parameters:</p> Name Type Description Default <code>custom_field</code> <code>CustomField</code> <p>The updated CustomField item. The ID must be set and match the Field you want to update.</p> required <p>Returns:</p> Type Description <code>CustomField</code> <p>The updated CustomField item as registered in Albert.</p> Source code in <code>src/albert/collections/custom_fields.py</code> <pre><code>def update(self, *, custom_field: CustomField) -&gt; CustomField:\n    \"\"\"Update a CustomField item.\n\n    Parameters\n    ----------\n    custom_field : CustomField\n        The updated CustomField item. The ID must be set and match the Field you want to update.\n\n    Returns\n    -------\n    CustomField\n        The updated CustomField item as registered in Albert.\n    \"\"\"\n    # fetch current object state\n    current_object = self.get_by_id(id=custom_field.id)\n\n    # generate the patch payload\n    payload = self._generate_patch_payload(\n        existing=current_object,\n        updated=custom_field,\n        generate_metadata_diff=False,\n        stringify_values=False,\n    )\n\n    for patch in payload.data:\n        if (\n            patch.attribute in (\"hidden\", \"search\", \"lkpColumn\", \"lkpRow\")\n            and patch.operation == \"add\"\n        ):\n            patch.operation = \"update\"\n            patch.old_value = False\n        if (\n            patch.attribute in (\"entityCategory\")\n            and patch.operation == \"add\"\n            and isinstance(patch.new_value, list)\n        ):\n            patch.new_value = patch.new_value[0]\n\n    # run patch\n    url = f\"{self.base_path}/{custom_field.id}\"\n    self.session.patch(url, json=payload.model_dump(mode=\"json\", by_alias=True))\n    updated_ctf = self.get_by_id(id=custom_field.id)\n    return updated_ctf\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.ServiceType","title":"ServiceType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The service type the custom field is associated with</p>"},{"location":"custom_fields/#albert.collections.custom_fields.ServiceType.DATA_COLUMNS","title":"DATA_COLUMNS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATA_COLUMNS = 'datacolumns'\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.ServiceType.DATA_TEMPLATES","title":"DATA_TEMPLATES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATA_TEMPLATES = 'datatemplates'\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.ServiceType.INVENTORIES","title":"INVENTORIES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INVENTORIES = 'inventories'\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.ServiceType.LOTS","title":"LOTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOTS = 'lots'\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.ServiceType.PARAMETERS","title":"PARAMETERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARAMETERS = 'parameters'\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.ServiceType.PARAMETER_GROUPS","title":"PARAMETER_GROUPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARAMETER_GROUPS = 'parametergroups'\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.ServiceType.PROJECTS","title":"PROJECTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROJECTS = 'projects'\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.ServiceType.TASKS","title":"TASKS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TASKS = 'tasks'\n</code></pre>"},{"location":"custom_fields/#albert.collections.custom_fields.ServiceType.USERS","title":"USERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>USERS = 'users'\n</code></pre>"},{"location":"custom_templates/","title":"Custom Templates","text":""},{"location":"custom_templates/#albert.collections.custom_templates.AlbertHTTPError","title":"AlbertHTTPError","text":"<pre><code>AlbertHTTPError(response: Response)\n</code></pre> <p>               Bases: <code>AlbertException</code></p> <p>Base class for all erors due to HTTP responses.</p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, response: requests.Response):\n    message = self._format_message(response)\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.AlbertHTTPError.response","title":"response  <code>instance-attribute</code>","text":"<pre><code>response = response\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplate","title":"CustomTemplate","text":"<p>               Bases: <code>BaseTaggedEntity</code></p> <p>A custom template entity.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the template.</p> <code>id</code> <code>str</code> <p>The Albert ID of the template. Set when the template is retrieved from Albert.</p> <code>category</code> <code>TemplateCategory</code> <p>The category of the template. Allowed values are <code>Property Task</code>, <code>Property</code>, <code>Batch</code>, <code>Sheet</code>, <code>Notebook</code>, and <code>General</code>.</p> <code>metadata</code> <code>Dict[str, str | List[EntityLink] | EntityLink] | None</code> <p>The metadata of the template. Allowed Metadata fields can be found using Custim Fields.</p> <code>data</code> <code>CustomTemplateData | None</code> <p>The data of the template.</p> <code>team</code> <code>List[TeamACL] | None</code> <p>The team of the template.</p> <code>acl</code> <code>TemplateACL | None</code> <p>Methods:</p> Name Description <code>add_missing_category</code> <p>Initialize private attributes from the incoming data dictionary before the model is fully constructed.</p>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplate.acl","title":"acl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acl: TemplateACL | None = Field(\n    default_factory=list, alias=\"ACL\"\n)\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplate.category","title":"category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category: TemplateCategory = Field(default=GENERAL)\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplate.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: CustomTemplateData | None = Field(\n    default=None, alias=\"Data\"\n)\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplate.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(alias='albertId')\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplate.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] | None = Field(\n    default=None, alias=\"Metadata\"\n)\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplate.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplate.team","title":"team  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>team: list[TeamACL] | None = Field(default_factory=list)\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplate.add_missing_category","title":"add_missing_category  <code>classmethod</code>","text":"<pre><code>add_missing_category(\n    data: dict[str, Any],\n) -&gt; dict[str, Any]\n</code></pre> <p>Initialize private attributes from the incoming data dictionary before the model is fully constructed.</p> Source code in <code>src/albert/resources/custom_templates.py</code> <pre><code>@model_validator(mode=\"before\")  # Must happen before construction so the data are captured\n@classmethod\ndef add_missing_category(cls, data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Initialize private attributes from the incoming data dictionary before the model is fully constructed.\n    \"\"\"\n\n    if \"Data\" in data and \"category\" in data and \"category\" not in data[\"Data\"]:\n        data[\"Data\"][\"category\"] = data[\"category\"]\n    return data\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplatesCollection","title":"CustomTemplatesCollection","text":"<pre><code>CustomTemplatesCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>CustomTemplatesCollection is a collection class for managing CustomTemplate entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>get_by_id</code> <p>Get a Custom Template by ID</p> <code>list</code> <p>Searches for custom templates matching the provided criteria.</p> Source code in <code>src/albert/collections/custom_templates.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CustomTemplatesCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{CustomTemplatesCollection._api_version}/customtemplates\"\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplatesCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/customtemplates'\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplatesCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id) -&gt; CustomTemplate\n</code></pre> <p>Get a Custom Template by ID</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>id of the custom template</p> required <p>Returns:</p> Type Description <code>CustomTemplate</code> <p>The CutomTemplate with the provided ID (or None if not found)</p> Source code in <code>src/albert/collections/custom_templates.py</code> <pre><code>def get_by_id(self, *, id) -&gt; CustomTemplate:\n    \"\"\"Get a Custom Template by ID\n\n    Parameters\n    ----------\n    id : str\n        id of the custom template\n\n    Returns\n    -------\n    CustomTemplate\n        The CutomTemplate with the provided ID (or None if not found)\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return CustomTemplate(**response.json())\n</code></pre>"},{"location":"custom_templates/#albert.collections.custom_templates.CustomTemplatesCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    text: str | None = None,\n    limit: int = 50,\n    offset: int = 0,\n) -&gt; Iterator[CustomTemplate]\n</code></pre> <p>Searches for custom templates matching the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>The text to search for, by default None</p> <code>None</code> <p>Yields:</p> Type Description <code>Iterator[CustomTemplate]</code> <p>An iterator of CustomTemplate items matching the search criteria.</p> Source code in <code>src/albert/collections/custom_templates.py</code> <pre><code>def list(\n    self,\n    *,\n    text: str | None = None,\n    limit: int = 50,\n    offset: int = 0,\n) -&gt; Iterator[CustomTemplate]:\n    \"\"\"Searches for custom templates matching the provided criteria.\n\n    Parameters\n    ----------\n    text : str | None, optional\n        The text to search for, by default None\n\n\n    Yields\n    ------\n    Iterator[CustomTemplate]\n        An iterator of CustomTemplate items matching the search criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[CustomTemplate]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching custom template {id}: {e}\")\n\n    params = {\"limit\": limit, \"offset\": offset, \"text\": text}\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"data_columns/","title":"Data Columns","text":""},{"location":"data_columns/#albert.collections.data_columns.AlbertHTTPError","title":"AlbertHTTPError","text":"<pre><code>AlbertHTTPError(response: Response)\n</code></pre> <p>               Bases: <code>AlbertException</code></p> <p>Base class for all erors due to HTTP responses.</p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, response: requests.Response):\n    message = self._format_message(response)\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.AlbertHTTPError.response","title":"response  <code>instance-attribute</code>","text":"<pre><code>response = response\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumn","title":"DataColumn","text":"<p>               Bases: <code>BaseResource</code></p>"},{"location":"data_columns/#albert.collections.data_columns.DataColumn.defalt","title":"defalt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defalt: bool = False\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumn.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumn.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] | None = Field(\n    alias=\"Metadata\", default=None\n)\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumn.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumnCollection","title":"DataColumnCollection","text":"<pre><code>DataColumnCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>DataColumnCollection is a collection class for managing DataColumn entities in the Albert platform.</p> <p>Methods:</p> Name Description <code>create</code> <p>Create a new data column entity.</p> <code>delete</code> <p>Delete a data column entity.</p> <code>get_by_id</code> <p>Get a data column by its ID.</p> <code>get_by_name</code> <p>Get a data column by its name.</p> <code>list</code> <p>Lists data column entities with optional filters.</p> <code>update</code> <p>Update a data column entity.</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initialize the DataColumnCollection with the provided session.\"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{DataColumnCollection._api_version}/datacolumns\"\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumnCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/datacolumns'\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumnCollection.create","title":"create","text":"<pre><code>create(*, data_column: DataColumn) -&gt; DataColumn\n</code></pre> <p>Create a new data column entity.</p> <p>Parameters:</p> Name Type Description Default <code>data_column</code> <code>DataColumn</code> <p>The data column object to create.</p> required <p>Returns:</p> Type Description <code>DataColumn</code> <p>The created data column object.</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def create(self, *, data_column: DataColumn) -&gt; DataColumn:\n    \"\"\"\n    Create a new data column entity.\n\n    Parameters\n    ----------\n    data_column : DataColumn\n        The data column object to create.\n\n    Returns\n    -------\n    DataColumn\n        The created data column object.\n    \"\"\"\n    payload = [data_column.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")]\n    response = self.session.post(self.base_path, json=payload)\n\n    return DataColumn(**response.json()[0])\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumnCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a data column entity.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the data column object to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Delete a data column entity.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the data column object to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumnCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id) -&gt; DataColumn\n</code></pre> <p>Get a data column by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the data column to get.</p> required <p>Returns:</p> Type Description <code>DataColumn | None</code> <p>The data column object on match or None</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def get_by_id(self, *, id) -&gt; DataColumn:\n    \"\"\"\n    Get a data column by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the data column to get.\n\n    Returns\n    -------\n    DataColumn | None\n        The data column object on match or None\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    dc = DataColumn(**response.json())\n    return dc\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumnCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(*, name) -&gt; DataColumn | None\n</code></pre> <p>Get a data column by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data column to get.</p> required <p>Returns:</p> Type Description <code>DataColumn | None</code> <p>The data column object on match or None</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def get_by_name(self, *, name) -&gt; DataColumn | None:\n    \"\"\"\n    Get a data column by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the data column to get.\n\n    Returns\n    -------\n    DataColumn | None\n        The data column object on match or None\n    \"\"\"\n    for dc in self.list(name=name):\n        if dc.name.lower() == name.lower():\n            return dc\n    return None\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumnCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    order_by: OrderBy = DESCENDING,\n    ids: str | list[str] | None = None,\n    name: str | list[str] | None = None,\n    exact_match: bool | None = None,\n    default: bool | None = None,\n    start_key: str | None = None,\n    limit: int = 100,\n) -&gt; Iterator[DataColumn]\n</code></pre> <p>Lists data column entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <code>ids</code> <code>str | list[str] | None</code> <p>Data column IDs to filter the search by, default None.</p> <code>None</code> <code>name</code> <code>Union[str, None]</code> <p>The name of the tag to filter by, by default None.</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>None</code> <code>default</code> <code>bool</code> <p>Whether to return only default columns, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[DataColumn]</code> <p>An iterator of DataColumns matching the provided criteria.</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def list(\n    self,\n    *,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    ids: str | list[str] | None = None,\n    name: str | list[str] | None = None,\n    exact_match: bool | None = None,\n    default: bool | None = None,\n    start_key: str | None = None,\n    limit: int = 100,\n) -&gt; Iterator[DataColumn]:\n    \"\"\"\n    Lists data column entities with optional filters.\n\n    Parameters\n    ----------\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING.\n    ids: str | list[str] | None, optional\n        Data column IDs to filter the search by, default None.\n    name : Union[str, None], optional\n        The name of the tag to filter by, by default None.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n    default : bool, optional\n        Whether to return only default columns, by default None.\n\n    Returns\n    -------\n    Iterator[DataColumn]\n        An iterator of DataColumns matching the provided criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[DataColumn]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching Data Column '{id}': {e}\")\n\n    params = {\n        \"limit\": limit,\n        \"orderBy\": order_by.value,\n        \"startKey\": start_key,\n        \"name\": [name] if isinstance(name, str) else name,\n        \"exactMatch\": json.dumps(exact_match) if exact_match is not None else None,\n        \"default\": json.dumps(default) if default is not None else None,\n        \"dataColumns\": [ids] if isinstance(ids, str) else ids,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.DataColumnCollection.update","title":"update","text":"<pre><code>update(*, data_column: DataColumn) -&gt; DataColumn\n</code></pre> <p>Update a data column entity.</p> <p>Parameters:</p> Name Type Description Default <code>data_column</code> <code>DataColumn</code> <p>The updated data column object. The ID must be set and match an existing data column.</p> required <p>Returns:</p> Type Description <code>DataColumn</code> <p>The updated data column object as registered in Albert.</p> Source code in <code>src/albert/collections/data_columns.py</code> <pre><code>def update(self, *, data_column: DataColumn) -&gt; DataColumn:\n    \"\"\"Update a data column entity.\n\n    Parameters\n    ----------\n    data_column : DataColumn\n        The updated data column object. The ID must be set and match an existing data column.\n\n    Returns\n    -------\n    DataColumn\n        The updated data column object as registered in Albert.\n    \"\"\"\n    existing = self.get_by_id(id=data_column.id)\n    payload = self._generate_patch_payload(\n        existing=existing,\n        updated=data_column,\n    )\n    payload_dump = payload.model_dump(mode=\"json\", by_alias=True)\n    for i, change in enumerate(payload_dump[\"data\"]):\n        if not self._is_metadata_item_list(\n            existing_object=existing,\n            updated_object=data_column,\n            metadata_field=change[\"attribute\"],\n        ):\n            change[\"operation\"] = \"update\"\n            if \"newValue\" in change and change[\"newValue\"] is None:\n                del change[\"newValue\"]\n            if \"oldValue\" in change and change[\"oldValue\"] is None:\n                del change[\"oldValue\"]\n            payload_dump[\"data\"][i] = change\n    if len(payload_dump[\"data\"]) == 0:\n        return data_column\n    for e in payload_dump[\"data\"]:\n        self.session.patch(\n            f\"{self.base_path}/{data_column.id}\",\n            json={\"data\": [e]},\n        )\n    return self.get_by_id(id=data_column.id)\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"data_columns/#albert.collections.data_columns.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"data_columns/#albert.collections.data_columns.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"data_templates/","title":"Data Templates","text":""},{"location":"data_templates/#albert.collections.data_templates.DataTemplateId","title":"DataTemplateId  <code>module-attribute</code>","text":"<pre><code>DataTemplateId = Annotated[\n    str, AfterValidator(ensure_datatemplate_id)\n]\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.AlbertHTTPError","title":"AlbertHTTPError","text":"<pre><code>AlbertHTTPError(response: Response)\n</code></pre> <p>               Bases: <code>AlbertException</code></p> <p>Base class for all erors due to HTTP responses.</p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, response: requests.Response):\n    message = self._format_message(response)\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.AlbertHTTPError.response","title":"response  <code>instance-attribute</code>","text":"<pre><code>response = response\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataColumnValue","title":"DataColumnValue","text":"<p>               Bases: <code>BaseAlbertModel</code></p> <p>Methods:</p> Name Description <code>check_for_id</code>"},{"location":"data_templates/#albert.collections.data_templates.DataColumnValue.calculation","title":"calculation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calculation: str | None = None\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataColumnValue.column_sequence","title":"column_sequence  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>column_sequence: str | None = Field(\n    default=None, alias=\"sequence\", exclude=True\n)\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataColumnValue.data_column","title":"data_column  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_column: DataColumn = Field(exclude=True, default=None)\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataColumnValue.data_column_id","title":"data_column_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_column_id: str = Field(alias='id', default=None)\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataColumnValue.hidden","title":"hidden  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hidden: bool = False\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataColumnValue.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: SerializeAsEntityLink[Unit] | None = Field(\n    default=None, alias=\"Unit\"\n)\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataColumnValue.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str | None = None\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataColumnValue.check_for_id","title":"check_for_id","text":"<pre><code>check_for_id()\n</code></pre> Source code in <code>src/albert/resources/data_templates.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_for_id(self):\n    if self.data_column_id is None and self.data_column is None:\n        raise ValueError(\"Either data_column_id or data_column must be set\")\n    elif (\n        self.data_column_id is not None\n        and self.data_column is not None\n        and self.data_column.id != self.data_column_id\n    ):\n        raise ValueError(\"If both are provided, data_column_id and data_column.id must match\")\n    elif self.data_column_id is None:\n        self.data_column_id = self.data_column.id\n    return self\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplate","title":"DataTemplate","text":"<p>               Bases: <code>BaseTaggedEntity</code></p>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplate.data_column_values","title":"data_column_values  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_column_values: list[DataColumnValue] | None = Field(\n    alias=\"DataColumns\", default=None\n)\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplate.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplate.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(None, alias='albertId')\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplate.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] | None = Field(\n    default=None, alias=\"Metadata\"\n)\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplate.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplate.security_class","title":"security_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>security_class: SecurityClass | None = None\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplate.users_with_access","title":"users_with_access  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>users_with_access: (\n    list[SerializeAsEntityLink[User]] | None\n) = Field(alias=\"ACL\", default=None)\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplate.verified","title":"verified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verified: bool = False\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplateCollection","title":"DataTemplateCollection","text":"<pre><code>DataTemplateCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>DataTemplateCollection is a collection class for managing DataTemplate entities in the Albert platform.</p> <p>Methods:</p> Name Description <code>add_data_columns</code> <p>Adds data columns to a data template.</p> <code>create</code> <p>Creates a new data template.</p> <code>delete</code> <p>Deletes a data template by its ID.</p> <code>get_by_id</code> <p>Get a data template by its ID.</p> <code>get_by_ids</code> <p>Get a list of data templates by their IDs.</p> <code>get_by_name</code> <p>Get a data template by its name.</p> <code>list</code> <p>Lists data template entities with optional filters.</p> <code>update</code> <p>Updates a data template.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{DataTemplateCollection._api_version}/datatemplates\"\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplateCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/datatemplates'\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplateCollection.add_data_columns","title":"add_data_columns","text":"<pre><code>add_data_columns(\n    *,\n    data_template_id: str,\n    data_columns: list[DataColumnValue],\n) -&gt; DataTemplate\n</code></pre> <p>Adds data columns to a data template.</p> <p>Parameters:</p> Name Type Description Default <code>data_template_id</code> <code>str</code> <p>The ID of the data template to add the columns to.</p> required <code>data_columns</code> <code>list[DataColumnValue]</code> <p>The list of DataColumnValue objects to add to the data template.</p> required <p>Returns:</p> Type Description <code>DataTemplate</code> <p>The updated DataTemplate object.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def add_data_columns(\n    self, *, data_template_id: str, data_columns: list[DataColumnValue]\n) -&gt; DataTemplate:\n    \"\"\"Adds data columns to a data template.\n\n    Parameters\n    ----------\n    data_template_id : str\n        The ID of the data template to add the columns to.\n    data_columns : list[DataColumnValue]\n        The list of DataColumnValue objects to add to the data template.\n\n    Returns\n    -------\n    DataTemplate\n        The updated DataTemplate object.\n    \"\"\"\n    payload = {\n        \"DataColumns\": [\n            x.model_dump(mode=\"json\", by_alias=True, exclude_none=True) for x in data_columns\n        ]\n    }\n    self.session.put(\n        f\"{self.base_path}/{data_template_id}/datacolumns\",\n        json=payload,\n    )\n    return self.get_by_id(id=data_template_id)\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplateCollection.create","title":"create","text":"<pre><code>create(*, data_template: DataTemplate) -&gt; DataTemplate\n</code></pre> <p>Creates a new data template.</p> <p>Parameters:</p> Name Type Description Default <code>data_template</code> <code>DataTemplate</code> <p>The DataTemplate object to create.</p> required <p>Returns:</p> Type Description <code>DataTemplate</code> <p>The registered DataTemplate object with an ID.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def create(self, *, data_template: DataTemplate) -&gt; DataTemplate:\n    \"\"\"Creates a new data template.\n\n    Parameters\n    ----------\n    data_template : DataTemplate\n        The DataTemplate object to create.\n\n    Returns\n    -------\n    DataTemplate\n        The registered DataTemplate object with an ID.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=data_template.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return DataTemplate(**response.json())\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplateCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a data template by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the data template to delete.</p> required Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Deletes a data template by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the data template to delete.\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplateCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: DataTemplateId) -&gt; DataTemplate\n</code></pre> <p>Get a data template by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>DataTemplateId</code> <p>The ID of the data template to get.</p> required <p>Returns:</p> Type Description <code>DataTemplate</code> <p>The data template object on match or None</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def get_by_id(self, *, id: DataTemplateId) -&gt; DataTemplate:\n    \"\"\"Get a data template by its ID.\n\n    Parameters\n    ----------\n    id : DataTemplateId\n        The ID of the data template to get.\n\n    Returns\n    -------\n    DataTemplate\n        The data template object on match or None\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return DataTemplate(**response.json())\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplateCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(\n    *, ids: list[DataTemplateId]\n) -&gt; list[DataTemplate]\n</code></pre> <p>Get a list of data templates by their IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[DataTemplateId]</code> <p>The list of DataTemplate IDs to get.</p> required <p>Returns:</p> Type Description <code>list[DataTemplate]</code> <p>A list of DataTemplate objects with the provided IDs.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def get_by_ids(self, *, ids: list[DataTemplateId]) -&gt; list[DataTemplate]:\n    \"\"\"Get a list of data templates by their IDs.\n\n    Parameters\n    ----------\n    ids : list[DataTemplateId]\n        The list of DataTemplate IDs to get.\n\n    Returns\n    -------\n    list[DataTemplate]\n        A list of DataTemplate objects with the provided IDs.\n    \"\"\"\n    url = f\"{self.base_path}/ids\"\n    batches = [ids[i : i + 250] for i in range(0, len(ids), 250)]\n    return [\n        DataTemplate(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()[\"Items\"]\n    ]\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplateCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(*, name: str) -&gt; DataTemplate | None\n</code></pre> <p>Get a data template by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data template to get.</p> required <p>Returns:</p> Type Description <code>DataTemplate | None</code> <p>The matching data template object or None if not found.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def get_by_name(self, *, name: str) -&gt; DataTemplate | None:\n    \"\"\"Get a data template by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the data template to get.\n\n    Returns\n    -------\n    DataTemplate | None\n        The matching data template object or None if not found.\n    \"\"\"\n    hits = list(self.list(name=name))\n    for h in hits:\n        if h.name.lower() == name.lower():\n            return h\n    return None\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplateCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    name: str | None = None,\n    user_id: str | None = None,\n    order_by: OrderBy = DESCENDING,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; Iterator[DataTemplate]\n</code></pre> <p>Lists data template entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Union[str, None]</code> <p>The name of the data template to filter by, by default None.</p> <code>None</code> <code>user_id</code> <code>str</code> <p>user_id to filter by, by default None.</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <p>Returns:</p> Type Description <code>Iterator[DataTemplate]</code> <p>An iterator of DataTemplate objects matching the provided criteria.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def list(\n    self,\n    *,\n    name: str | None = None,\n    user_id: str | None = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; Iterator[DataTemplate]:\n    \"\"\"\n    Lists data template entities with optional filters.\n\n    Parameters\n    ----------\n    name : Union[str, None], optional\n        The name of the data template to filter by, by default None.\n    user_id : str, optional\n        user_id to filter by, by default None.\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING.\n\n    Returns\n    -------\n    Iterator[DataTemplate]\n        An iterator of DataTemplate objects matching the provided criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[DataTemplate]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching parameter group {id}: {e}\")\n        # get by ids is not currently returning metadata correctly, so temp fixing this\n        # return self.get_by_ids(ids=[x[\"albertId\"] for x in items])\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"order\": OrderBy(order_by).value if order_by else None,\n        \"text\": name,\n        \"userId\": user_id,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        deserialize=deserialize,\n        params=params,\n    )\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.DataTemplateCollection.update","title":"update","text":"<pre><code>update(*, data_template: DataTemplate) -&gt; DataTemplate\n</code></pre> <p>Updates a data template.</p> <p>Parameters:</p> Name Type Description Default <code>data_template</code> <code>DataTemplate</code> <p>The DataTemplate object to update. The ID must be set and matching the ID of the DataTemplate to update.</p> required <p>Returns:</p> Type Description <code>DataTemplate</code> <p>The Updated DataTemplate object.</p> Source code in <code>src/albert/collections/data_templates.py</code> <pre><code>def update(self, *, data_template: DataTemplate) -&gt; DataTemplate:\n    \"\"\"Updates a data template.\n\n    Parameters\n    ----------\n    data_template : DataTemplate\n        The DataTemplate object to update. The ID must be set and matching the ID of the DataTemplate to update.\n\n    Returns\n    -------\n    DataTemplate\n        The Updated DataTemplate object.\n    \"\"\"\n    existing = self.get_by_id(id=data_template.id)\n    base_payload = self._generate_patch_payload(existing=existing, updated=data_template)\n    payload = base_payload.model_dump(mode=\"json\", by_alias=True)\n    _updatable_attributes_special = {\"tags\", \"data_column_values\"}\n    for attribute in _updatable_attributes_special:\n        old_value = getattr(existing, attribute)\n        new_value = getattr(data_template, attribute)\n        if attribute == \"tags\":\n            if (old_value is None or old_value == []) and new_value is not None:\n                for t in new_value:\n                    payload[\"data\"].append(\n                        {\n                            \"operation\": \"add\",\n                            \"attribute\": \"tagId\",\n                            \"newValue\": t.id,  # This will be a CasAmount Object,\n                            \"entityId\": t.id,\n                        }\n                    )\n            else:\n                if old_value is None:  # pragma: no cover\n                    old_value = []\n                if new_value is None:  # pragma: no cover\n                    new_value = []\n                old_set = {obj.id for obj in old_value}\n                new_set = {obj.id for obj in new_value}\n\n                # Find what's in set 1 but not in set 2\n                to_del = old_set - new_set\n\n                # Find what's in set 2 but not in set 1\n                to_add = new_set - old_set\n\n                for id in to_add:\n                    payload[\"data\"].append(\n                        {\n                            \"operation\": \"add\",\n                            \"attribute\": \"tagId\",\n                            \"newValue\": id,\n                        }\n                    )\n                for id in to_del:\n                    payload[\"data\"].append(\n                        {\n                            \"operation\": \"delete\",\n                            \"attribute\": \"tagId\",\n                            \"oldValue\": id,\n                        }\n                    )\n        elif attribute == \"data_column_values\":\n            # Do the update by column\n            to_remove = set([x.data_column_id for x in old_value]) - set(\n                [x.data_column_id for x in new_value]\n            )\n            to_add = set([x.data_column_id for x in new_value]) - set(\n                [x.data_column_id for x in old_value]\n            )\n            to_update = set([x.data_column_id for x in new_value]) &amp; set(\n                [x.data_column_id for x in old_value]\n            )\n            if len(to_remove) &gt; 0:\n                logger.error(\n                    \"Data Columns cannot be Removed from a Data Template. Set to hidden instead and retry.\"\n                )\n            if len(to_add) &gt; 0:\n                new_dcs = [x for x in new_value if x.data_column_id in to_add]\n                self.add_data_columns(data_template_id=data_template.id, data_columns=new_dcs)\n            for dc_id in to_update:\n                actions = []\n                old_dc_val = next(x for x in old_value if x.data_column_id == dc_id)\n                new_dc_val = next(x for x in new_value if x.data_column_id == dc_id)\n                # do hidden last because it can change the column sequence.\n                if old_dc_val.unit != new_dc_val.unit:\n                    payload[\"data\"].append(\n                        {\n                            \"operation\": \"update\",\n                            \"attribute\": \"unit\",\n                            \"newValue\": new_dc_val.unit.id,\n                            \"oldValue\": old_dc_val.unit.id,\n                            \"colId\": old_dc_val.column_sequence,\n                        }\n                    )\n                if old_dc_val.hidden != new_dc_val.hidden:\n                    actions.append(\n                        {\n                            \"operation\": \"update\",\n                            \"attribute\": \"hidden\",\n                            \"newValue\": new_dc_val.hidden,\n                            \"oldValue\": old_dc_val.hidden,\n                        }\n                    )\n                if len(actions) &gt; 0:\n                    payload[\"data\"].append(\n                        {\n                            \"actions\": actions,\n                            \"attribute\": \"datacolumn\",\n                            \"colId\": old_dc_val.column_sequence,\n                        }\n                    )\n    if len(payload[\"data\"]) &gt; 0:\n        url = f\"{self.base_path}/{existing.id}\"\n        self.session.patch(url, json=payload)\n    return self.get_by_id(id=existing.id)  # always do this in case columns were added\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"data_templates/#albert.collections.data_templates.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"data_templates/#albert.collections.data_templates.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"files/","title":"Files","text":""},{"location":"files/#albert.collections.files.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"files/#albert.collections.files.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"files/#albert.collections.files.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"files/#albert.collections.files.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"files/#albert.collections.files.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"files/#albert.collections.files.FileCategory","title":"FileCategory","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"files/#albert.collections.files.FileCategory.OTHER","title":"OTHER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTHER = 'Other'\n</code></pre>"},{"location":"files/#albert.collections.files.FileCategory.SDS","title":"SDS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SDS = 'SDS'\n</code></pre>"},{"location":"files/#albert.collections.files.FileCollection","title":"FileCollection","text":"<pre><code>FileCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>FileCollection is a collection class for managing File entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>get_by_name</code> <p>Gets a file by name and namespace.</p> <code>get_signed_download_url</code> <p>Get a signed download URL for a file.</p> <code>get_signed_upload_url</code> <p>Get a signed upload URL for a file.</p> <code>sign_and_upload_file</code> <p>Sign and upload a file to Albert.</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initialize the FileCllection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{FileCollection._api_version}/files\"\n</code></pre>"},{"location":"files/#albert.collections.files.FileCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/files'\n</code></pre>"},{"location":"files/#albert.collections.files.FileCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(\n    *,\n    name: str,\n    namespace: FileNamespace,\n    generic: bool = False,\n) -&gt; FileInfo\n</code></pre> <p>Gets a file by name and namespace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The Name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>generic</code> <code>bool</code> <p>description, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>FileInfo</code> <p>The file information related to the matching file.</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def get_by_name(\n    self,\n    *,\n    name: str,\n    namespace: FileNamespace,\n    generic: bool = False,\n) -&gt; FileInfo:\n    \"\"\"Gets a file by name and namespace.\n\n    Parameters\n    ----------\n    name : str\n        The Name of the file\n    namespace : FileNamespace\n        The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    generic : bool, optional\n        _description_, by default False\n\n    Returns\n    -------\n    FileInfo\n        The file information related to the matching file.\n    \"\"\"\n    params = {\n        \"name\": name,\n        \"namespace\": namespace,\n        \"generic\": json.dumps(generic),\n    }\n    response = self.session.get(f\"{self.base_path}/info\", params=params)\n    return FileInfo(**response.json())\n</code></pre>"},{"location":"files/#albert.collections.files.FileCollection.get_signed_download_url","title":"get_signed_download_url","text":"<pre><code>get_signed_download_url(\n    *,\n    name: str,\n    namespace: FileNamespace,\n    version_id: str | None = None,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str\n</code></pre> <p>Get a signed download URL for a file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The Name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>version_id</code> <code>str | None</code> <p>The version of the file, by default None</p> <code>None</code> <code>category</code> <code>FileCategory | None</code> <p>The file category (E.g., SDS, OTHER), by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>description</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def get_signed_download_url(\n    self,\n    *,\n    name: str,\n    namespace: FileNamespace,\n    version_id: str | None = None,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str:\n    \"\"\"Get a signed download URL for a file.\n\n    Parameters\n    ----------\n    name : str\n        The Name of the file\n    namespace : FileNamespace\n        The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    version_id : str | None, optional\n        The version of the file, by default None\n    category : FileCategory | None, optional\n        The file category (E.g., SDS, OTHER), by default None\n\n    Returns\n    -------\n    str\n        _description_\n    \"\"\"\n    params = {\n        \"name\": name,\n        \"namespace\": namespace,\n        \"versionId\": version_id,\n        \"generic\": json.dumps(generic),\n        \"category\": category,\n    }\n    response = self.session.get(\n        f\"{self.base_path}/sign\",\n        params={k: v for k, v in params.items() if v is not None},\n    )\n    return response.json()[\"URL\"]\n</code></pre>"},{"location":"files/#albert.collections.files.FileCollection.get_signed_upload_url","title":"get_signed_upload_url","text":"<pre><code>get_signed_upload_url(\n    *,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str\n</code></pre> <p>Get a signed upload URL for a file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The Name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>content_type</code> <code>str</code> <p>The content type of the file</p> required <code>category</code> <code>FileCategory | None</code> <p>The File category (E.g., SDS, OTHER), by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>description</p> Source code in <code>src/albert/collections/files.py</code> <pre><code>def get_signed_upload_url(\n    self,\n    *,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; str:\n    \"\"\"Get a signed upload URL for a file.\n\n    Parameters\n    ----------\n    name : str\n        The Name of the file\n    namespace : FileNamespace\n        The namespace of the file (e.g. AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    content_type : str\n        The content type of the file\n    category : FileCategory | None, optional\n        The File category (E.g., SDS, OTHER), by default None\n\n    Returns\n    -------\n    str\n        _description_\n    \"\"\"\n    params = {\"generic\": json.dumps(generic)}\n\n    post_body = SignURLPOST(\n        files=[\n            SignURLPOSTFile(\n                name=name,\n                namespace=namespace,\n                content_type=content_type,\n                category=category,\n            )\n        ]\n    )\n\n    response = self.session.post(\n        f\"{self.base_path}/sign\",\n        json=post_body.model_dump(by_alias=True, exclude_unset=True, mode=\"json\"),\n        params=params,\n    )\n    return response.json()[0][\"URL\"]\n</code></pre>"},{"location":"files/#albert.collections.files.FileCollection.sign_and_upload_file","title":"sign_and_upload_file","text":"<pre><code>sign_and_upload_file(\n    data: IO,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; None\n</code></pre> <p>Sign and upload a file to Albert.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>IO</code> <p>The file data</p> required <code>name</code> <code>str</code> <p>The name of the file</p> required <code>namespace</code> <code>FileNamespace</code> <p>The File Namespace (e.g., AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)</p> required <code>content_type</code> <code>str</code> <p>The content type of the file</p> required <code>category</code> <code>FileCategory | None</code> <p>The category of the file (E.g., SDS, OTHER), by default None</p> <code>None</code> Source code in <code>src/albert/collections/files.py</code> <pre><code>def sign_and_upload_file(\n    self,\n    data: IO,\n    name: str,\n    namespace: FileNamespace,\n    content_type: str,\n    generic: bool = False,\n    category: FileCategory | None = None,\n) -&gt; None:\n    \"\"\"Sign and upload a file to Albert.\n\n    Parameters\n    ----------\n    data : IO\n        The file data\n    name : str\n        The name of the file\n    namespace : FileNamespace\n        The File Namespace (e.g., AGENT, BREAKTHROUGH, PIPELINE, PUBLIC, RESULT, SDS)\n    content_type : str\n        The content type of the file\n    category : FileCategory | None, optional\n        The category of the file (E.g., SDS, OTHER), by default None\n    \"\"\"\n    upload_url = self.get_signed_upload_url(\n        name=name,\n        namespace=namespace,\n        content_type=content_type,\n        generic=generic,\n        category=category,\n    )\n    requests.put(upload_url, data=data, headers={\"Content-Type\": content_type})\n</code></pre>"},{"location":"files/#albert.collections.files.FileInfo","title":"FileInfo","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"files/#albert.collections.files.FileInfo.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content_type: str = Field(..., alias='contentType')\n</code></pre>"},{"location":"files/#albert.collections.files.FileInfo.etag","title":"etag  <code>instance-attribute</code>","text":"<pre><code>etag: str\n</code></pre>"},{"location":"files/#albert.collections.files.FileInfo.last_modified","title":"last_modified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>last_modified: datetime = Field(..., alias='lastModified')\n</code></pre>"},{"location":"files/#albert.collections.files.FileInfo.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: list[dict[str, str]] = Field(\n    ..., default_factory=list\n)\n</code></pre>"},{"location":"files/#albert.collections.files.FileInfo.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"files/#albert.collections.files.FileInfo.namespace","title":"namespace  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>namespace: FileNamespace | None = Field(default=None)\n</code></pre>"},{"location":"files/#albert.collections.files.FileInfo.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre>"},{"location":"files/#albert.collections.files.FileNamespace","title":"FileNamespace","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"files/#albert.collections.files.FileNamespace.AGENT","title":"AGENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AGENT = 'agent'\n</code></pre>"},{"location":"files/#albert.collections.files.FileNamespace.BREAKTHROUGH","title":"BREAKTHROUGH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BREAKTHROUGH = 'breakthrough'\n</code></pre>"},{"location":"files/#albert.collections.files.FileNamespace.PIPELINE","title":"PIPELINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PIPELINE = 'pipeline'\n</code></pre>"},{"location":"files/#albert.collections.files.FileNamespace.PUBLIC","title":"PUBLIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PUBLIC = 'public'\n</code></pre>"},{"location":"files/#albert.collections.files.FileNamespace.RESULT","title":"RESULT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESULT = 'result'\n</code></pre>"},{"location":"files/#albert.collections.files.FileNamespace.SDS","title":"SDS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SDS = 'sds'\n</code></pre>"},{"location":"files/#albert.collections.files.SignURLPOST","title":"SignURLPOST","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"files/#albert.collections.files.SignURLPOST.files","title":"files  <code>instance-attribute</code>","text":"<pre><code>files: list[SignURLPOSTFile]\n</code></pre>"},{"location":"files/#albert.collections.files.SignURLPOSTFile","title":"SignURLPOSTFile","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"files/#albert.collections.files.SignURLPOSTFile.category","title":"category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category: FileCategory | None = Field(default=None)\n</code></pre>"},{"location":"files/#albert.collections.files.SignURLPOSTFile.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content_type: str = Field(..., alias='contentType')\n</code></pre>"},{"location":"files/#albert.collections.files.SignURLPOSTFile.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: list[dict[str, str]] | None = Field(default=None)\n</code></pre>"},{"location":"files/#albert.collections.files.SignURLPOSTFile.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"files/#albert.collections.files.SignURLPOSTFile.namespace","title":"namespace  <code>instance-attribute</code>","text":"<pre><code>namespace: FileNamespace\n</code></pre>"},{"location":"files/#albert.collections.files.SignURLPOSTFile.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: str | None = Field(default=None)\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#overview","title":"Overview","text":"<p>The SDK is built around two main concepts:</p> <ol> <li> <p>Resource Models: Represent individual entities like InventoryItem, Project, Company, and Tag. These are all controlled using Pydantic.</p> </li> <li> <p>Resource Collections: Provide methods to interact with the API endpoints related to a specific resource, such as listing, creating, updating, and deleting resources.</p> </li> </ol>"},{"location":"getting-started/#resource-models","title":"Resource Models","text":"<p>Resource Models represent the data structure of individual resources. They encapsulate the attributes and behaviors of a single resource. For example, an <code>InventoryItem</code> has attributes like <code>name</code>, <code>description</code>, <code>category</code>, and <code>tags</code>.</p>"},{"location":"getting-started/#resource-collections","title":"Resource Collections","text":"<p>Resource Collections act as managers for Resource Models. They provide methods for performing CRUD operations (Create, Read, Update, Delete) on the resources. For example, the <code>InventoryCollection</code> class has methods like create, <code>get_by_id()</code>, <code>list()</code>, <code>update()</code>, and <code>delete()</code>. <code>list()</code> methods generally accept parameters to narrow the query to use it like a search.</p>"},{"location":"getting-started/#usage","title":"Usage","text":""},{"location":"getting-started/#initialization","title":"Initialization","text":"<p>To use the SDK, you need to initialize the Albert client with your base URL and either a bearer token (which will expire) or client credientals, which will enable automatic token refresh.</p> <pre><code>from albert import Albert, ClientCredentials\n\n# Initialize the client using a JWT token\nclient = Albert(\n    base_url=\"https://app.albertinvent.com/\", # example value\n    token = os.getenv(\"ALBERT_TOKEN\") # example value\n)\n\n\n# Initalize using an API key from environment\n\nclient = Albert(\n    client_credentials=ClientCredentials.from_env(\n        client_id_env=\"ALBERT_CLIENT_ID\",\n        client_secret_env=\"ALBERT_CLIENT_SECRET\",\n    )\n)\n\n#  By default, if environment variables `ALBERT_CLIENT_ID` and `ALBERT_CLIENT_SECRET` are set you can simply do:\n\nclient = Albert()\n</code></pre>"},{"location":"getting-started/#working-with-resource-collections-and-models","title":"Working with Resource Collections and Models","text":""},{"location":"getting-started/#example-inventory-collection","title":"Example: Inventory Collection","text":"<p>You can interact with inventory items using the InventoryCollection class. Here is an example of how to create a new inventory item, list all inventory items, and fetch an inventory item by its ID.</p> <pre><code>from albert import Albert\nfrom albert.resources.inventory import InventoryItem, InventoryCategory, UnitCategory\n\nclient = Albert()\n\n# Create a new inventory item\nnew_inventory = InventoryItem(\n    name=\"Goggles\",\n    description=\"Safety Equipment\",\n    category=InventoryCategory.EQUIPMENT,\n    unit_category=UnitCategory.UNITS,\n    tags=[\"safety\", \"equipment\"],\n    company=\"Company ABC\"\n)\ncreated_inventory = client.inventory.create(inventory_item=new_inventory)\n\n# List all inventory items\nall_inventories = client.inventory.list()\n\n# Fetch an inventory item by ID\ninventory_id = \"INV1\"\ninventory_item = client.inventory.get_by_id(inventory_id=inventory_id)\n\n# Search an inventory item by name\ninventory_item = inventory_collection.list(name=\"Acetone\")\n</code></pre>"},{"location":"getting-started/#entitylink-serializeasentitylink","title":"EntityLink / SerializeAsEntityLink","text":"<p>We introduced the concept of a <code>EntityLink</code> to represent the foreign key references you can find around the Albert API. Payloads to the API expect these refrences in the <code>EntityLink</code> format (e.g., <code>{\"id\":x}</code>). However, as a convenience, you will see some value types defined as <code>SerializeAsEntityLink</code>, and then another resource name (e.g., <code>SerializeAsEntityLink[Location]</code>). This allows a user to make that reference either to a base and link or to the actual other entity, and the SDK will handle the serialization for you! For example:</p> <pre><code>from albert import Albert\nfrom albert.resources.project import Project\nfrom albert.resources.base import EntityLink\n\nclient = Albert()\n\nmy_location = next(client.locations.list(name=\"My Location\")\n\np = Project(\n    description=\"Example project\",\n    locations=[my_location]\n)\n\n# Equivalent to\n\np = Project(\n    description=\"Example project\",\n    locations=[EntityLink(id=my_location.id)]\n)\n</code></pre>"},{"location":"getting-started/#custom-fields-lists","title":"Custom Fields &amp; Lists","text":"<p><code>CustomFields</code> allow you to store custom metadata on a <code>Project</code>, <code>InventoryItem</code>, <code>User</code>, <code>BaseTask</code> (Tasks), and <code>Lot</code>. The <code>FieldType</code> used determines the shape of the medatdata field's value. If the <code>FieldType</code> is <code>LIST</code>, then the <code>FieldCategory</code> defines the ACL needed to add new allowed items to the given list. A <code>FieldCategory.USER_DEFINED</code> allows general users to add new items to the list whereas <code>FieldCategory.BUSINESS_DEFINED</code> allows only admin users to add new allowed values.</p>"},{"location":"getting-started/#creating-custom-fields","title":"Creating Custom Fields","text":"<pre><code># Create some custom fields on projects\n# Let's add a stage-gate field, which is a single allowed value from a list, and an open text field for \"Project Justification\"\n\nfrom albert import Albert\nfrom albert.resources.custom_fields import CustomField, FieldCategory, FieldType, ServiceType\nfrom albert.resources.lists import ListItem\nfrom albert.resources.project import Project\n\nstage_gate_field = CustomField(\n    name=\"stage_gate_status\",\n    display_name=\"Stage Gate\",\n    field_type=FieldType.LIST,\n    service=ServiceType.PROJECTS,\n    min=1,\n    max=1,\n    category=FieldCategory.BUSINESS_DEFINED # These are going to be defined by the business, not by any user\n)\n\njustification_field = CustomField(\n    name=\"justification\",\n    display_name=\"Project Justification\",\n    field_type=FieldType.STRING,\n    service=ServiceType.PROJECTS,\n)\n\nclient = Albert()\n\n\nclient.custom_fields.create(stage_gate_field)\nclient.custom_fields.create(justification_field)\n\n# Next, let's add some allowed values to the Stage Gate List (assumes user is an admin)\n\nstages = [\n    \"1. Discovery\",\n    \"2. Concept Validation\",\n    \"3. Proof of Concept\",\n    \"4. Prototype Development\",\n    \"5. Preliminary Evaluation\",\n    \"6. Feasibility Study\",\n    \"7. Optimization\",\n    \"8. Scale-Up\",\n    \"9. Regulatory Assessment\",\n]\n\nfor s in stages:\n    item = ListItem(\n        name=s\n        category=stage_gate_field.category,\n        list_type=stage_gate_field.name,\n    )\n    client.lists.create(list_item=item)\n\n# Now, let's say I want to add some Projects with this metadata.\n\np = Project(\n    description=\"Example project\",\n    locations=[next(client.locations.list(name=\"My Location\"))],\n    metadata = {\n        stage_gate_field.name: [client.lists.get_matching_item(list_type=stage_gate_field.name, name = stages[0]).to_entity_link()],\n        justification_field.name: \"To show an example of using custom fields.\"\n    }\n# Also note that the values of list metadata fields are list[EntityLink]\n)\n</code></pre>"},{"location":"inventory/","title":"Inventory","text":""},{"location":"inventory/#albert.collections.inventory.ALL_MERGE_MODULES","title":"ALL_MERGE_MODULES  <code>module-attribute</code>","text":"<pre><code>ALL_MERGE_MODULES = [\n    \"PRICING\",\n    \"NOTES\",\n    \"SDS\",\n    \"PD\",\n    \"BD\",\n    \"LOT\",\n    \"CAS\",\n    \"TAS\",\n    \"WFL\",\n    \"PRG\",\n    \"PTD\",\n]\n</code></pre> <p>All modules selectable for inventory merge.</p>"},{"location":"inventory/#albert.collections.inventory.InventoryId","title":"InventoryId  <code>module-attribute</code>","text":"<pre><code>InventoryId = Annotated[\n    str, AfterValidator(ensure_inventory_id)\n]\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.ProjectId","title":"ProjectId  <code>module-attribute</code>","text":"<pre><code>ProjectId = Annotated[\n    str, AfterValidator(ensure_project_id)\n]\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.SearchProjectId","title":"SearchProjectId  <code>module-attribute</code>","text":"<pre><code>SearchProjectId = Annotated[\n    str, AfterValidator(ensure_project_search_id)\n]\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.WorksheetId","title":"WorksheetId  <code>module-attribute</code>","text":"<pre><code>WorksheetId = Annotated[\n    str, AfterValidator(ensure_worksheet_id)\n]\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.Cas","title":"Cas  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a CAS entity.</p> Show JSON schema: <pre><code>{\n  \"$defs\": {\n    \"CasCategory\": {\n      \"enum\": [\n        \"User\",\n        \"Verisk\",\n        \"TSCA - Public\",\n        \"TSCA - Private\",\n        \"not TSCA\",\n        \"CAS linked to External Database\",\n        \"Unknown (Trade Secret)\",\n        \"CL_Inventory Upload\"\n      ],\n      \"title\": \"CasCategory\",\n      \"type\": \"string\"\n    },\n    \"Hazard\": {\n      \"description\": \"Represents a chemical hazard.\",\n      \"properties\": {\n        \"subCategory\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"description\": \"Hazard subcategory\",\n          \"title\": \"Subcategory\"\n        },\n        \"hCode\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"description\": \"Hazard code\",\n          \"title\": \"Hcode\"\n        },\n        \"category\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"description\": \"Hazard category\",\n          \"title\": \"Category\"\n        },\n        \"class\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"description\": \"Hazard classification\",\n          \"title\": \"Class\"\n        },\n        \"hCodeText\": {\n          \"anyOf\": [\n            {\n              \"type\": \"string\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"description\": \"Hazard code text\",\n          \"title\": \"Hcodetext\"\n        }\n      },\n      \"title\": \"Hazard\",\n      \"type\": \"object\"\n    }\n  },\n  \"description\": \"Represents a CAS entity.\",\n  \"properties\": {\n    \"number\": {\n      \"description\": \"The CAS number.\",\n      \"title\": \"Number\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"Name of the CAS.\",\n      \"title\": \"Name\"\n    },\n    \"description\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"The description or name of the CAS.\",\n      \"title\": \"Description\"\n    },\n    \"notes\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"Notes related to the CAS.\",\n      \"title\": \"Notes\"\n    },\n    \"category\": {\n      \"anyOf\": [\n        {\n          \"$ref\": \"#/$defs/CasCategory\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"The category of the CAS.\"\n    },\n    \"casSmiles\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"CAS SMILES notation.\",\n      \"title\": \"Cassmiles\"\n    },\n    \"inchiKey\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"InChIKey of the CAS.\",\n      \"title\": \"Inchikey\"\n    },\n    \"iUpacName\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"IUPAC name of the CAS.\",\n      \"title\": \"Iupacname\"\n    },\n    \"albertId\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"The AlbertID of the CAS.\",\n      \"title\": \"Albertid\"\n    },\n    \"hazards\": {\n      \"anyOf\": [\n        {\n          \"items\": {\n            \"$ref\": \"#/$defs/Hazard\"\n          },\n          \"type\": \"array\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"Hazards associated with the CAS.\",\n      \"title\": \"Hazards\"\n    },\n    \"wgk\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"German Water Hazard Class (WGK) number.\",\n      \"title\": \"Wgk\"\n    },\n    \"ecListNo\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"European Community (EC) number.\",\n      \"title\": \"Eclistno\"\n    },\n    \"type\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"Type of the CAS.\",\n      \"title\": \"Type\"\n    },\n    \"classificationType\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"Classification type of the CAS.\",\n      \"title\": \"Classificationtype\"\n    },\n    \"order\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null,\n      \"description\": \"CAS order.\",\n      \"title\": \"Order\"\n    }\n  },\n  \"required\": [\n    \"number\"\n  ],\n  \"title\": \"Cas\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Fields:</p> <ul> <li> <code>number</code>                 (<code>str</code>)             </li> <li> <code>name</code>                 (<code>str | None</code>)             </li> <li> <code>description</code>                 (<code>str | None</code>)             </li> <li> <code>notes</code>                 (<code>str | None</code>)             </li> <li> <code>category</code>                 (<code>CasCategory | None</code>)             </li> <li> <code>smiles</code>                 (<code>str | None</code>)             </li> <li> <code>inchi_key</code>                 (<code>str | None</code>)             </li> <li> <code>iupac_name</code>                 (<code>str | None</code>)             </li> <li> <code>id</code>                 (<code>str | None</code>)             </li> <li> <code>hazards</code>                 (<code>list[Hazard] | None</code>)             </li> <li> <code>wgk</code>                 (<code>str | None</code>)             </li> <li> <code>ec_number</code>                 (<code>str | None</code>)             </li> <li> <code>type</code>                 (<code>str | None</code>)             </li> <li> <code>classification_type</code>                 (<code>str | None</code>)             </li> <li> <code>order</code>                 (<code>str | None</code>)             </li> </ul>"},{"location":"inventory/#albert.collections.inventory.Cas.category","title":"category  <code>pydantic-field</code>","text":"<pre><code>category: CasCategory | None = None\n</code></pre> <p>The category of the CAS.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.classification_type","title":"classification_type  <code>pydantic-field</code>","text":"<pre><code>classification_type: str | None = None\n</code></pre> <p>Classification type of the CAS.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.description","title":"description  <code>pydantic-field</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>The description or name of the CAS.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.ec_number","title":"ec_number  <code>pydantic-field</code>","text":"<pre><code>ec_number: str | None = None\n</code></pre> <p>European Community (EC) number.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.hazards","title":"hazards  <code>pydantic-field</code>","text":"<pre><code>hazards: list[Hazard] | None = None\n</code></pre> <p>Hazards associated with the CAS.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.id","title":"id  <code>pydantic-field</code>","text":"<pre><code>id: str | None = None\n</code></pre> <p>The AlbertID of the CAS.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.inchi_key","title":"inchi_key  <code>pydantic-field</code>","text":"<pre><code>inchi_key: str | None = None\n</code></pre> <p>InChIKey of the CAS.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.iupac_name","title":"iupac_name  <code>pydantic-field</code>","text":"<pre><code>iupac_name: str | None = None\n</code></pre> <p>IUPAC name of the CAS.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name: str | None = None\n</code></pre> <p>Name of the CAS.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.notes","title":"notes  <code>pydantic-field</code>","text":"<pre><code>notes: str | None = None\n</code></pre> <p>Notes related to the CAS.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.number","title":"number  <code>pydantic-field</code>","text":"<pre><code>number: str\n</code></pre> <p>The CAS number.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.order","title":"order  <code>pydantic-field</code>","text":"<pre><code>order: str | None = None\n</code></pre> <p>CAS order.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.smiles","title":"smiles  <code>pydantic-field</code>","text":"<pre><code>smiles: str | None = None\n</code></pre> <p>CAS SMILES notation.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.type","title":"type  <code>pydantic-field</code>","text":"<pre><code>type: str | None = None\n</code></pre> <p>Type of the CAS.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.wgk","title":"wgk  <code>pydantic-field</code>","text":"<pre><code>wgk: str | None = None\n</code></pre> <p>German Water Hazard Class (WGK) number.</p>"},{"location":"inventory/#albert.collections.inventory.Cas.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(*, number: str) -&gt; Cas\n</code></pre> <p>Creates a Cas object from a string.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The CAS number.</p> required <p>Returns:</p> Type Description <code>Cas</code> <p>The Cas object created from the string.</p> Source code in <code>src/albert/resources/cas.py</code> <pre><code>@classmethod\ndef from_string(cls, *, number: str) -&gt; \"Cas\":\n    \"\"\"\n    Creates a Cas object from a string.\n\n    Parameters\n    ----------\n    number : str\n        The CAS number.\n\n    Returns\n    -------\n    Cas\n        The Cas object created from the string.\n    \"\"\"\n    return cls(number=number)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.Company","title":"Company","text":"<p>               Bases: <code>BaseResource</code></p> <p>Company is a Pydantic model representing a company entity.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the company.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the company. Set when the company is retrieved from Albert.</p> <code>distance</code> <code>float | None</code> <p>The scores of a company in a search result, optional. Read-only.</p>"},{"location":"inventory/#albert.collections.inventory.Company.distance","title":"distance  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distance: float | None = Field(\n    default=None, exclude=True, frozen=True\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.Company.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.Company.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.CompanyCollection","title":"CompanyCollection","text":"<pre><code>CompanyCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>CompanyCollection is a collection class for managing Company entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>company_exists</code> <p>Checks if a company exists by its name.</p> <code>create</code> <p>Creates a new company entity.</p> <code>delete</code> <p>Deletes a company entity.</p> <code>get_by_id</code> <p>Get a company by its ID.</p> <code>get_by_name</code> <p>Retrieves a company by its name.</p> <code>list</code> <p>Lists company entities with optional filters.</p> <code>rename</code> <p>Renames an existing company entity.</p> <code>update</code> <p>Update a Company entity. The id of the company must be provided.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CompanyCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{CompanyCollection._api_version}/companies\"\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.CompanyCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/companies'\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.CompanyCollection.company_exists","title":"company_exists","text":"<pre><code>company_exists(\n    *, name: str, exact_match: bool = True\n) -&gt; bool\n</code></pre> <p>Checks if a company exists by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the company to check.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the company exists, False otherwise.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def company_exists(self, *, name: str, exact_match: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if a company exists by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the company to check.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    bool\n        True if the company exists, False otherwise.\n    \"\"\"\n    companies = self.get_by_name(name=name, exact_match=exact_match)\n    return bool(companies)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.CompanyCollection.create","title":"create","text":"<pre><code>create(\n    *, company: str | Company, check_if_exists: bool = True\n) -&gt; Company\n</code></pre> <p>Creates a new company entity.</p> <p>Parameters:</p> Name Type Description Default <code>company</code> <code>Union[str, Company]</code> <p>The company name or Company object to create.</p> required <code>check_if_exists</code> <code>bool</code> <p>Whether to check if the company already exists, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Company</code> <p>The created Company object.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def create(self, *, company: str | Company, check_if_exists: bool = True) -&gt; Company:\n    \"\"\"\n    Creates a new company entity.\n\n    Parameters\n    ----------\n    company : Union[str, Company]\n        The company name or Company object to create.\n    check_if_exists : bool, optional\n        Whether to check if the company already exists, by default True.\n\n    Returns\n    -------\n    Company\n        The created Company object.\n    \"\"\"\n    if isinstance(company, str):\n        company = Company(name=company)\n    hit = self.get_by_name(name=company.name, exact_match=True)\n    if check_if_exists and hit:\n        logging.warning(f\"Company {company.name} already exists with id {hit.id}.\")\n        return hit\n\n    payload = company.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    response = self.session.post(self.base_path, json=payload)\n    this_company = Company(**response.json())\n    return this_company\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.CompanyCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a company entity.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the company to delete.</p> required Source code in <code>src/albert/collections/companies.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Deletes a company entity.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the company to delete.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.CompanyCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Company\n</code></pre> <p>Get a company by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the company to retrieve.</p> required <p>Returns:</p> Type Description <code>Company</code> <p>The Company object.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Company:\n    \"\"\"\n    Get a company by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the company to retrieve.\n\n    Returns\n    -------\n    Company\n        The Company object.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    company = response.json()\n    found_company = Company(**company)\n    return found_company\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.CompanyCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(\n    *, name: str, exact_match: bool = True\n) -&gt; Company | None\n</code></pre> <p>Retrieves a company by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the company to retrieve.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Company</code> <p>The Company object if found, None otherwise.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def get_by_name(self, *, name: str, exact_match: bool = True) -&gt; Company | None:\n    \"\"\"\n    Retrieves a company by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the company to retrieve.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    Company\n        The Company object if found, None otherwise.\n    \"\"\"\n    found = self.list(name=name, exact_match=exact_match)\n    return next(found, None)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.CompanyCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 50,\n    name: str | list[str] = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Company]\n</code></pre> <p>Lists company entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of companies to return, by default 50.</p> <code>50</code> <code>name</code> <code>Union[str, None]</code> <p>The name of the company to filter by, by default None.</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Iterator</code> <p>An iterator of Company objects.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 50,\n    name: str | list[str] = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Company]:\n    \"\"\"\n    Lists company entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of companies to return, by default 50.\n    name : Union[str, None], optional\n        The name of the company to filter by, by default None.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    Iterator\n        An iterator of Company objects.\n    \"\"\"\n    params = {\"limit\": limit, \"dupDetection\": \"false\", \"startKey\": start_key}\n    if name:\n        params[\"name\"] = name if isinstance(name, list) else [name]\n        params[\"exactMatch\"] = str(exact_match).lower()\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Company(**item) for item in items],\n    )\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.CompanyCollection.rename","title":"rename","text":"<pre><code>rename(*, old_name: str, new_name: str) -&gt; Company\n</code></pre> <p>Renames an existing company entity.</p> <p>Parameters:</p> Name Type Description Default <code>old_name</code> <code>str</code> <p>The current name of the company.</p> required <code>new_name</code> <code>str</code> <p>The new name of the company.</p> required <p>Returns:</p> Type Description <code>Company</code> <p>The renamed Company object</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def rename(self, *, old_name: str, new_name: str) -&gt; Company:\n    \"\"\"\n    Renames an existing company entity.\n\n    Parameters\n    ----------\n    old_name : str\n        The current name of the company.\n    new_name : str\n        The new name of the company.\n\n    Returns\n    -------\n    Company\n        The renamed Company object\n    \"\"\"\n    company = self.get_by_name(name=old_name, exact_match=True)\n    if not company:\n        msg = f'Company \"{old_name}\" not found.'\n        logger.error(msg)\n        raise AlbertException(msg)\n    company_id = company.id\n    endpoint = f\"{self.base_path}/{company_id}\"\n    payload = {\n        \"data\": [\n            {\n                \"operation\": \"update\",\n                \"attribute\": \"name\",\n                \"oldValue\": old_name,\n                \"newValue\": new_name,\n            }\n        ]\n    }\n    self.session.patch(endpoint, json=payload)\n    updated_company = self.get_by_id(id=company_id)\n    return updated_company\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.CompanyCollection.update","title":"update","text":"<pre><code>update(*, company: Company) -&gt; Company\n</code></pre> <p>Update a Company entity. The id of the company must be provided.</p> <p>Parameters:</p> Name Type Description Default <code>company</code> <code>Company</code> <p>The updated Company object.</p> required <p>Returns:</p> Type Description <code>Company</code> <p>The updated Company object as registered in Albert.</p> Source code in <code>src/albert/collections/companies.py</code> <pre><code>def update(self, *, company: Company) -&gt; Company:\n    \"\"\"Update a Company entity. The id of the company must be provided.\n\n    Parameters\n    ----------\n    company : Company\n        The updated Company object.\n\n    Returns\n    -------\n    Company\n        The updated Company object as registered in Albert.\n    \"\"\"\n    # Fetch the current object state from the server or database\n    current_object = self.get_by_id(id=company.id)\n\n    # Generate the PATCH payload\n    patch_payload = self._generate_patch_payload(existing=current_object, updated=company)\n    url = f\"{self.base_path}/{company.id}\"\n    self.session.patch(url, json=patch_payload.model_dump(mode=\"json\", by_alias=True))\n    updated_company = self.get_by_id(id=company.id)\n    return updated_company\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.FacetItem","title":"FacetItem","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"inventory/#albert.collections.inventory.FacetItem.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.FacetItem.parameter","title":"parameter  <code>instance-attribute</code>","text":"<pre><code>parameter: str\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.FacetItem.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: FacetType\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.FacetItem.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: list[FacetValue] = Field(\n    default_factory=list, alias=\"Value\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCategory","title":"InventoryCategory","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"inventory/#albert.collections.inventory.InventoryCategory.CONSUMABLES","title":"CONSUMABLES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONSUMABLES = 'Consumables'\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCategory.EQUIPMENT","title":"EQUIPMENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EQUIPMENT = 'Equipment'\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCategory.FORMULAS","title":"FORMULAS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FORMULAS = 'Formulas'\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCategory.RAW_MATERIALS","title":"RAW_MATERIALS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RAW_MATERIALS = 'RawMaterials'\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection","title":"InventoryCollection","text":"<pre><code>InventoryCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>InventoryCollection is a collection class for managing Inventory Item entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Albert</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>add_specs</code> <p>Add inventory specs to the inventory item.</p> <code>create</code> <p>Create a new inventory item.</p> <code>delete</code> <p>Delete an inventory item by its ID.</p> <code>get_all_facets</code> <p>Get available facets for inventory items based on the provided filters.</p> <code>get_by_id</code> <p>Retrieve an inventory item by its ID.</p> <code>get_by_ids</code> <p>Retrieve an set of inventory items by their IDs.</p> <code>get_facet_by_name</code> <p>Returns a specific facet by its name with all the filters applied to the search.</p> <code>get_match_or_none</code> <p>Get a matching inventory item or return None if not found.</p> <code>get_specs</code> <p>Get the specs for a list of inventory items.</p> <code>inventory_exists</code> <p>Check if an inventory item exists.</p> <code>list</code> <p>List inventory items with optional filters.</p> <code>merge</code> <p>Merge one or multiple child inventory into a parent inventory item.</p> <code>search</code> <p>Get a list of inventory items that match the search criteria and</p> <code>update</code> <p>Update an inventory item.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    InventoryCollection is a collection class for managing inventory items.\n\n    Parameters\n    ----------\n    session : Albert\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{InventoryCollection._api_version}/inventories\"\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/inventories'\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.add_specs","title":"add_specs","text":"<pre><code>add_specs(\n    *,\n    inventory_id: InventoryId,\n    specs: InventorySpec | list[InventorySpec],\n) -&gt; InventorySpecList\n</code></pre> <p>Add inventory specs to the inventory item.</p> <p>An <code>InventorySpec</code> is a property that was not directly measured via a task, but is a generic property of that inentory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The Albert ID of the inventory item to add the specs to</p> required <code>specs</code> <code>list[InventorySpec]</code> <p>List of InventorySpec objects to add to the inventory item, which described the value and, optionally, the conditions associated with the value (via workflow).</p> required <p>Returns:</p> Type Description <code>InventorySpecList</code> <p>The list of InventorySpecs attached to the InventoryItem.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef add_specs(\n    self,\n    *,\n    inventory_id: InventoryId,\n    specs: InventorySpec | list[InventorySpec],\n) -&gt; InventorySpecList:\n    \"\"\"Add inventory specs to the inventory item.\n\n    An `InventorySpec` is a property that was not directly measured via a task,\n    but is a generic property of that inentory item.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The Albert ID of the inventory item to add the specs to\n    specs : list[InventorySpec]\n        List of InventorySpec objects to add to the inventory item,\n        which described the value and, optionally,\n        the conditions associated with the value (via workflow).\n\n    Returns\n    -------\n    InventorySpecList\n        The list of InventorySpecs attached to the InventoryItem.\n    \"\"\"\n    if isinstance(specs, InventorySpec):\n        specs = [specs]\n    response = self.session.put(\n        url=f\"{self.base_path}/{inventory_id}/specs\",\n        json=[x.model_dump(exclude_unset=True, by_alias=True, mode=\"json\") for x in specs],\n    )\n    return InventorySpecList(**response.json())\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.create","title":"create","text":"<pre><code>create(\n    *,\n    inventory_item: InventoryItem,\n    avoid_duplicates: bool = True,\n) -&gt; InventoryItem\n</code></pre> <p>Create a new inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_item</code> <code>InventoryItem</code> <p>The inventory item to create.</p> required <code>avoid_duplicates</code> <code>bool</code> <p>Whether to avoid creating duplicate items (default is True).</p> <code>True</code> <p>Returns:</p> Type Description <code>InventoryItem</code> <p>The created inventory item.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def create(\n    self,\n    *,\n    inventory_item: InventoryItem,\n    avoid_duplicates: bool = True,\n) -&gt; InventoryItem:\n    \"\"\"\n    Create a new inventory item.\n\n    Parameters\n    ----------\n    inventory_item : InventoryItem\n        The inventory item to create.\n    avoid_duplicates : bool, optional\n        Whether to avoid creating duplicate items (default is True).\n\n    Returns\n    -------\n    InventoryItem\n        The created inventory item.\n    \"\"\"\n    category = (\n        inventory_item.category\n        if isinstance(inventory_item.category, str)\n        else inventory_item.category.value\n    )\n    if category == InventoryCategory.FORMULAS.value:\n        # This will need to interact with worksheets\n        raise NotImplementedError(\"Registrations of formulas not yet implemented\")\n    tag_collection = TagCollection(session=self.session)\n    if inventory_item.tags is not None and inventory_item.tags != []:\n        all_tags = [\n            tag_collection.create(tag=t) if t.id is None else t for t in inventory_item.tags\n        ]\n        inventory_item.tags = all_tags\n    if inventory_item.company and inventory_item.company.id is None:\n        company_collection = CompanyCollection(session=self.session)\n        inventory_item.company = company_collection.create(company=inventory_item.company)\n    # Check to see if there is a match on name + Company already\n    if avoid_duplicates:\n        existing = self.get_match_or_none(inventory_item=inventory_item)\n        if isinstance(existing, InventoryItem):\n            logging.warning(\n                f\"Inventory item already exists with name {existing.name} and company {existing.company.name}, returning existing item.\"\n            )\n            return existing\n    response = self.session.post(\n        self.base_path,\n        json=inventory_item.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return InventoryItem(**response.json())\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.delete","title":"delete","text":"<pre><code>delete(*, id: InventoryId) -&gt; None\n</code></pre> <p>Delete an inventory item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>InventoryId</code> <p>The ID of the inventory item.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef delete(self, *, id: InventoryId) -&gt; None:\n    \"\"\"\n    Delete an inventory item by its ID.\n\n    Parameters\n    ----------\n    id : InventoryId\n        The ID of the inventory item.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.get_all_facets","title":"get_all_facets","text":"<pre><code>get_all_facets(\n    *,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory]\n    | InventoryCategory\n    | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation]\n    | StorageLocation\n    | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; list[FacetItem]\n</code></pre> <p>Get available facets for inventory items based on the provided filters.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef get_all_facets(\n    self,\n    *,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory] | InventoryCategory | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation] | StorageLocation | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; list[FacetItem]:\n    \"\"\"\n    Get available facets for inventory items based on the provided filters.\n    \"\"\"\n\n    params = self._prepare_parameters(\n        limit=1,\n        text=text,\n        cas=cas,\n        category=category,\n        company=company,\n        location=location,\n        storage_location=storage_location,\n        project_id=project_id,\n        sheet_id=sheet_id,\n        created_by=created_by,\n        lot_owner=lot_owner,\n        tags=tags,\n    )\n    response = self.session.get(\n        url=f\"{self.base_path}/llmsearch\"\n        if match_all_conditions\n        else f\"{self.base_path}/search\",\n        params=params,\n    )\n    return [FacetItem.model_validate(x) for x in response.json()[\"Facets\"]]\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: InventoryId) -&gt; InventoryItem\n</code></pre> <p>Retrieve an inventory item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>InventoryId</code> <p>The ID of the inventory item.</p> required <p>Returns:</p> Type Description <code>InventoryItem</code> <p>The retrieved inventory item.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef get_by_id(self, *, id: InventoryId) -&gt; InventoryItem:\n    \"\"\"\n    Retrieve an inventory item by its ID.\n\n    Parameters\n    ----------\n    id : InventoryId\n        The ID of the inventory item.\n\n    Returns\n    -------\n    InventoryItem\n        The retrieved inventory item.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return InventoryItem(**response.json())\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(\n    *, ids: list[InventoryId]\n) -&gt; list[InventoryItem]\n</code></pre> <p>Retrieve an set of inventory items by their IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[InventoryId]</code> <p>The list of IDs of the inventory items.</p> required <p>Returns:</p> Type Description <code>list[InventoryItem]</code> <p>The retrieved inventory items.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef get_by_ids(self, *, ids: list[InventoryId]) -&gt; list[InventoryItem]:\n    \"\"\"\n    Retrieve an set of inventory items by their IDs.\n\n    Parameters\n    ----------\n    ids : list[InventoryId]\n        The list of IDs of the inventory items.\n\n    Returns\n    -------\n    list[InventoryItem]\n        The retrieved inventory items.\n    \"\"\"\n    url = f\"{self.base_path}/ids\"\n    batches = [ids[i : i + 250] for i in range(0, len(ids), 250)]\n    return [\n        InventoryItem(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()[\"Items\"]\n    ]\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.get_facet_by_name","title":"get_facet_by_name","text":"<pre><code>get_facet_by_name(\n    name: str | list[str],\n    *,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory]\n    | InventoryCategory\n    | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation]\n    | StorageLocation\n    | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; list[FacetItem]\n</code></pre> <p>Returns a specific facet by its name with all the filters applied to the search. This can be used for example to fetch all remaining tags as part of an iterative refinement of a search.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef get_facet_by_name(\n    self,\n    name: str | list[str],\n    *,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory] | InventoryCategory | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation] | StorageLocation | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; list[FacetItem]:\n    \"\"\"\n    Returns a specific facet by its name with all the filters applied to the search.\n    This can be used for example to fetch all remaining tags as part of an iterative\n    refinement of a search.\n    \"\"\"\n    if isinstance(name, str):\n        name = [name]\n\n    facets = self.get_all_facets(\n        text=text,\n        cas=cas,\n        category=category,\n        company=company,\n        location=location,\n        storage_location=storage_location,\n        project_id=project_id,\n        sheet_id=sheet_id,\n        created_by=created_by,\n        lot_owner=lot_owner,\n        tags=tags,\n        match_all_conditions=match_all_conditions,\n    )\n    filtered_facets = []\n    for facet in facets:\n        if facet.name in name or facet.name.lower() in name:\n            filtered_facets.append(facet)\n\n    return filtered_facets\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.get_match_or_none","title":"get_match_or_none","text":"<pre><code>get_match_or_none(\n    *, inventory_item: InventoryItem\n) -&gt; InventoryItem | None\n</code></pre> <p>Get a matching inventory item or return None if not found.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_item</code> <code>InventoryItem</code> <p>The inventory item to match.</p> required <p>Returns:</p> Type Description <code>Union[InventoryItem, None]</code> <p>The matching inventory item or None if not found.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def get_match_or_none(self, *, inventory_item: InventoryItem) -&gt; InventoryItem | None:\n    \"\"\"\n    Get a matching inventory item or return None if not found.\n\n    Parameters\n    ----------\n    inventory_item : InventoryItem\n        The inventory item to match.\n\n    Returns\n    -------\n    Union[InventoryItem, None]\n        The matching inventory item or None if not found.\n    \"\"\"\n    hits = self.list(text=inventory_item.name, company=[inventory_item.company])\n    inv_company = (\n        inventory_item.company.name\n        if isinstance(inventory_item.company, Company)\n        else inventory_item.company\n    )\n    for inv in hits:\n        if inv and inv.name == inventory_item.name and inv.company.name == inv_company:\n            return inv\n    else:\n        return None\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.get_specs","title":"get_specs","text":"<pre><code>get_specs(\n    *, ids: list[InventoryId]\n) -&gt; list[InventorySpecList]\n</code></pre> <p>Get the specs for a list of inventory items.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[InventoryId]</code> <p>List of Inventory IDs to get the specs for.</p> required <p>Returns:</p> Type Description <code>list[InventorySpecList]</code> <p>A list of InventorySpecList objects, each containing the specs for an inventory item.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef get_specs(self, *, ids: list[InventoryId]) -&gt; list[InventorySpecList]:\n    \"\"\"Get the specs for a list of inventory items.\n\n    Parameters\n    ----------\n    ids : list[InventoryId]\n        List of Inventory IDs to get the specs for.\n\n    Returns\n    -------\n    list[InventorySpecList]\n        A list of InventorySpecList objects, each containing the specs for an inventory item.\n    \"\"\"\n    url = f\"{self.base_path}/specs\"\n    batches = [ids[i : i + 250] for i in range(0, len(ids), 250)]\n    ta = TypeAdapter(InventorySpecList)\n    return [\n        ta.validate_python(item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()\n    ]\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.inventory_exists","title":"inventory_exists","text":"<pre><code>inventory_exists(*, inventory_item: InventoryItem) -&gt; bool\n</code></pre> <p>Check if an inventory item exists.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_item</code> <code>InventoryItem</code> <p>The inventory item to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the inventory item exists, False otherwise.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def inventory_exists(self, *, inventory_item: InventoryItem) -&gt; bool:\n    \"\"\"\n    Check if an inventory item exists.\n\n    Parameters\n    ----------\n    inventory_item : InventoryItem\n        The inventory item to check.\n\n    Returns\n    -------\n    bool\n        True if the inventory item exists, False otherwise.\n    \"\"\"\n    hit = self.get_match_or_none(inventory_item=inventory_item)\n    return bool(hit)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory]\n    | InventoryCategory\n    | None = None,\n    company: list[Company] | Company | None = None,\n    order: OrderBy = DESCENDING,\n    sort_by: str | None = \"createdAt\",\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation]\n    | StorageLocation\n    | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; Iterator[InventoryItem]\n</code></pre> <p>List inventory items with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of items to return (default is 100)</p> <code>100</code> <code>text</code> <code>str</code> <p>Text to search for in inventory names and descriptions</p> <code>None</code> <code>cas</code> <code>list[Cas] | Cas | None</code> <p>Filter by CAS number(s)</p> <code>None</code> <code>category</code> <code>list[InventoryCategory] | InventoryCategory | None</code> <p>Filter by inventory category/categories</p> <code>None</code> <code>company</code> <code>list[Company] | Company | None</code> <p>Filter by manufacturing company/companies</p> <code>None</code> <code>order</code> <code>OrderBy</code> <p>Sort order, either ASCENDING or DESCENDING (default is DESCENDING)</p> <code>DESCENDING</code> <code>sort_by</code> <code>str</code> <p>Field to sort by (default is \"createdAt\")</p> <code>'createdAt'</code> <code>location</code> <code>list[Location] | None</code> <p>Filter by location(s)</p> <code>None</code> <code>storage_location</code> <code>list[StorageLocation] | None</code> <p>Filter by storage location(s)</p> <code>None</code> <code>project_id</code> <code>str</code> <p>Filter by project ID</p> <code>None</code> <code>sheet_id</code> <code>str</code> <p>Filter by sheet ID</p> <code>None</code> <code>created_by</code> <code>list[User]</code> <p>Filter by creator(s)</p> <code>None</code> <code>lot_owner</code> <code>list[User]</code> <p>Filter by lot owner(s)</p> <code>None</code> <code>tags</code> <code>list[str]</code> <p>Filter by tag(s)</p> <code>None</code> <code>match_all_conditions</code> <code>bool</code> <p>Whether to match all conditions (default is False -- e.g. OR between conditions)</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterator[InventoryItem]</code> <p>An iterator over the matching inventory items</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef list(\n    self,\n    *,\n    limit: int = 100,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory] | InventoryCategory | None = None,\n    company: list[Company] | Company | None = None,\n    order: OrderBy = OrderBy.DESCENDING,\n    sort_by: str | None = \"createdAt\",\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation] | StorageLocation | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; Iterator[InventoryItem]:\n    \"\"\"\n    List inventory items with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        Maximum number of items to return (default is 100)\n    text : str, optional\n        Text to search for in inventory names and descriptions\n    cas : list[Cas] | Cas | None, optional\n        Filter by CAS number(s)\n    category : list[InventoryCategory] | InventoryCategory | None, optional\n        Filter by inventory category/categories\n    company : list[Company] | Company | None, optional\n        Filter by manufacturing company/companies\n    order : OrderBy, optional\n        Sort order, either ASCENDING or DESCENDING (default is DESCENDING)\n    sort_by : str, optional\n        Field to sort by (default is \"createdAt\")\n    location : list[Location] | None, optional\n        Filter by location(s)\n    storage_location : list[StorageLocation] | None, optional\n        Filter by storage location(s)\n    project_id : str, optional\n        Filter by project ID\n    sheet_id : str, optional\n        Filter by sheet ID\n    created_by : list[User], optional\n        Filter by creator(s)\n    lot_owner : list[User], optional\n        Filter by lot owner(s)\n    tags : list[str], optional\n        Filter by tag(s)\n    match_all_conditions : bool, optional\n        Whether to match all conditions (default is False -- e.g. OR between conditions)\n\n    Returns\n    -------\n    Iterator[InventoryItem]\n        An iterator over the matching inventory items\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; list[InventoryItem]:\n        return self.get_by_ids(ids=[x[\"albertId\"] for x in items])\n\n    search_text = text if (text is None or len(text) &lt; 50) else text[0:50]\n\n    params = self._prepare_parameters(\n        limit=limit,\n        text=search_text,\n        cas=cas,\n        category=category,\n        company=company,\n        order=order,\n        sort_by=sort_by,\n        location=location,\n        storage_location=storage_location,\n        project_id=project_id,\n        sheet_id=sheet_id,\n        created_by=created_by,\n        lot_owner=lot_owner,\n        tags=tags,\n    )\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/llmsearch\"\n        if match_all_conditions\n        else f\"{self.base_path}/search\",\n        params=params,\n        session=self.session,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.merge","title":"merge","text":"<pre><code>merge(\n    *,\n    parent_id: InventoryId,\n    child_id: InventoryId | list[InventoryId],\n    modules: list[str] | None = None,\n) -&gt; None\n</code></pre> <p>Merge one or multiple child inventory into a parent inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>InventoryId</code> <p>The ID of the parent inventory item.</p> required <code>child_id</code> <code>InventoryId | list[InventoryId]</code> <p>The ID(s) of the child inventory item(s).</p> required <code>modules</code> <code>list[str]</code> <p>The merge modules to use (default is all).</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def merge(\n    self,\n    *,\n    parent_id: InventoryId,\n    child_id: InventoryId | list[InventoryId],\n    modules: list[str] | None = None,\n) -&gt; None:\n    \"\"\"\n    Merge one or multiple child inventory into a parent inventory item.\n\n    Parameters\n    ----------\n    parent_id : InventoryId\n        The ID of the parent inventory item.\n    child_id : InventoryId | list[InventoryId]\n        The ID(s) of the child inventory item(s).\n    modules : list[str], optional\n        The merge modules to use (default is all).\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    # assume \"all\" modules if not specified explicitly\n    modules = modules if modules is not None else ALL_MERGE_MODULES\n\n    # define merge endpoint\n    url = f\"{self.base_path}/merge\"\n\n    if isinstance(child_id, list):\n        child_inventories = [{\"id\": i} for i in child_id]\n    else:\n        child_inventories = [{\"id\": child_id}]\n\n    # define payload using the class\n    payload = MergeInventory(\n        parent_id=parent_id,\n        child_inventories=child_inventories,\n        modules=modules,\n    )\n\n    # post request\n    self.session.post(url, json=payload.model_dump(mode=\"json\", by_alias=True))\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.search","title":"search","text":"<pre><code>search(\n    *,\n    limit: int = 100,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory]\n    | InventoryCategory\n    | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation]\n    | StorageLocation\n    | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; Iterator[InventorySearchItem]\n</code></pre> <p>Get a list of inventory items that match the search criteria and return the raw search records. These are not full inventory item objects, but are special short documents intended for fast summary results</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>@validate_call\ndef search(\n    self,\n    *,\n    limit: int = 100,\n    text: str | None = None,\n    cas: list[Cas] | Cas | None = None,\n    category: list[InventoryCategory] | InventoryCategory | None = None,\n    company: list[Company] | Company | None = None,\n    location: list[Location] | Location | None = None,\n    storage_location: list[StorageLocation] | StorageLocation | None = None,\n    project_id: ProjectId | None = None,\n    sheet_id: WorksheetId | None = None,\n    created_by: list[User] | User | None = None,\n    lot_owner: list[User] | User | None = None,\n    tags: list[str] | None = None,\n    match_all_conditions: bool = False,\n) -&gt; Iterator[InventorySearchItem]:\n    \"\"\"\n    Get a list of inventory items that match the search criteria and\n    return the raw search records. These are not full inventory item\n    objects, but are special short documents intended for fast summary results\n    \"\"\"\n\n    def deserialize(items: list[dict]):\n        return [InventorySearchItem.model_validate(x) for x in items]\n\n    params = self._prepare_parameters(\n        limit=limit,\n        text=text,\n        cas=cas,\n        category=category,\n        company=company,\n        location=location,\n        storage_location=storage_location,\n        project_id=project_id,\n        sheet_id=sheet_id,\n        created_by=created_by,\n        lot_owner=lot_owner,\n        tags=tags,\n    )\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/llmsearch\"\n        if match_all_conditions\n        else f\"{self.base_path}/search\",\n        params=params,\n        session=self.session,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryCollection.update","title":"update","text":"<pre><code>update(*, inventory_item: InventoryItem) -&gt; InventoryItem\n</code></pre> <p>Update an inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_item</code> <code>InventoryItem</code> <p>The updated inventory item object.</p> required <p>Returns:</p> Type Description <code>InventoryItem</code> <p>The updated inventory item retrieved from the server.</p> Source code in <code>src/albert/collections/inventory.py</code> <pre><code>def update(self, *, inventory_item: InventoryItem) -&gt; InventoryItem:\n    \"\"\"\n    Update an inventory item.\n\n    Parameters\n    ----------\n    inventory_item : InventoryItem\n        The updated inventory item object.\n\n    Returns\n    -------\n    InventoryItem\n        The updated inventory item retrieved from the server.\n    \"\"\"\n    # Fetch the current object state from the server or database\n    current_object = self.get_by_id(id=inventory_item.id)\n\n    # Generate the PATCH payload\n    patch_payload = self._generate_inventory_patch_payload(\n        existing=current_object, updated=inventory_item\n    )\n\n    # Complex patching is not working, so I'm going to do this in a loop :(\n    # https://teams.microsoft.com/l/message/19:de4a48c366664ce1bafcdbea02298810@thread.tacv2/1724856117312?tenantId=98aab90e-764b-48f1-afaa-02e3c7300653&amp;groupId=35a36a3d-fc25-4899-a1dd-ad9c7d77b5b3&amp;parentMessageId=1724856117312&amp;teamName=Product%20%2B%20Engineering&amp;channelName=General%20-%20API&amp;createdTime=1724856117312\n    url = f\"{self.base_path}/{inventory_item.id}\"\n    for change in patch_payload[\"data\"]:\n        change_payload = {\"data\": [change]}\n        self.session.patch(url, json=change_payload)\n    updated_inv = self.get_by_id(id=inventory_item.id)\n    return updated_inv\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem","title":"InventoryItem","text":"<p>               Bases: <code>BaseTaggedEntity</code></p> <p>An InventoryItem is a Pydantic model representing an item in the inventory. Can be a raw material, consumable, equipment, or formula. Note: Formulas should be registered via the Worksheet collection / Sheet resource.</p> <p>Returns:</p> Type Description <code>InventoryItem</code> <p>An InventoryItem that can be used to represent an item in the inventory. Can be a raw material, consumable, equipment, or formula.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the InventoryItem.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the InventoryItem. Set when the InventoryItem is retrieved from Albert.</p> <code>description</code> <code>str | None</code> <p>The description of the InventoryItem.</p> <code>category</code> <code>InventoryCategory</code> <p>The category of the InventoryItem. Allowed values are <code>RawMaterials</code>, <code>Consumables</code>, <code>Equipment</code>, and <code>Formulas</code>.</p> <code>unit_category</code> <code>InventoryUnitCategory</code> <p>The unit category of the InventoryItem. Can be mass, volume, length, pressure, or units. By default, mass is used for RawMaterials and Formulas, and units is used for Equipment and Consumables.</p> <code>security_class</code> <code>SecurityClass | None</code> <p>The security class of the InventoryItem. Optional. Can be confidential, shared, or restricted.</p> <code>company</code> <code>Company | str | None</code> <p>The company associated with the InventoryItem. Can be a Company object or a string. If a String is provided, a Company object with the name of the provided string will be first-or-created.</p> <code>minimum</code> <code>list[InventoryMinimum] | None</code> <p>The minimum amount of the InventoryItem that must be kept in stock at a given Location. Optional.</p> <code>alias</code> <code>str | None</code> <p>An alias for the InventoryItem. Optional.</p> <code>cas</code> <code>list[CasAmount] | None</code> <p>The CAS numbers associated with the InventoryItem. This is how a compositional breakdown can be provided. Optional.</p> <code>metadata</code> <code>dict[str, str | list[EntityLink] | EntityLink] | None</code> <p>Metadata associated with the InventoryItem. Optional. Allowed metadata fields can be found in the CustomFields documentation.</p> <code>project_id</code> <code>str | None</code> <p>The project ID associated with the InventoryItem. Read Only. Required for Formulas.</p> <code>formula_id</code> <code>str | None</code> <p>The formula ID associated with the InventoryItem. Read Only.</p> <code>tags</code> <code>list[str | Tag] | None</code> <p>The tags associated with the InventoryItem. Optional. If a string is provided, a Tag object with the name of the provided string will be first-or-created.</p> <p>Methods:</p> Name Description <code>set_unit_category</code> <p>Set unit category from category if not defined.</p> <code>validate_company_string</code> <code>validate_formula_fields</code> <p>Ensure required fields are present for formulas.</p> <code>validate_un_number</code>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.acls","title":"acls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acls: list[ACL] = Field(default_factory=list, alias='ACL')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.alias","title":"alias  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alias: str | None = Field(default=None)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.cas","title":"cas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cas: list[CasAmount] | None = Field(\n    default=None, alias=\"Cas\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: InventoryCategory\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.company","title":"company  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>company: SerializeAsEntityLink[Company] | None = Field(\n    default=None, alias=\"Company\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.formula_id","title":"formula_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>formula_id: str | None = Field(\n    default=None,\n    alias=\"formulaId\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(None, alias='albertId')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] | None = Field(\n    alias=\"Metadata\", default=None\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.minimum","title":"minimum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>minimum: list[InventoryMinimum] | None = Field(default=None)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = None\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.project_id","title":"project_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>project_id: str | None = Field(\n    default=None, alias=\"parentId\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.recent_atachment_id","title":"recent_atachment_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>recent_atachment_id: str | None = Field(\n    default=None,\n    alias=\"recentAttachmentId\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.security_class","title":"security_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>security_class: SecurityClass | None = Field(\n    default=None, alias=\"class\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.symbols","title":"symbols  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbols: list[dict] | None = Field(\n    default=None, alias=\"Symbols\", exclude=True, frozen=True\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.task_config","title":"task_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task_config: list[dict] | None = Field(\n    default=None,\n    alias=\"TaskConfig\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.un_number","title":"un_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>un_number: str | None = Field(\n    default=None,\n    alias=\"unNumber\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.unit_category","title":"unit_category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit_category: InventoryUnitCategory | None = Field(\n    default=None, alias=\"unitCategory\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.set_unit_category","title":"set_unit_category","text":"<pre><code>set_unit_category() -&gt; InventoryItem\n</code></pre> <p>Set unit category from category if not defined.</p> Source code in <code>src/albert/resources/inventory.py</code> <pre><code>@model_validator(mode=\"after\")\ndef set_unit_category(self) -&gt; \"InventoryItem\":\n    \"\"\"Set unit category from category if not defined.\"\"\"\n    if self.unit_category is None:\n        if self.category in [InventoryCategory.RAW_MATERIALS, InventoryCategory.FORMULAS]:\n            object.__setattr__(self, \"unit_category\", InventoryUnitCategory.MASS)\n        elif self.category in [InventoryCategory.EQUIPMENT, InventoryCategory.CONSUMABLES]:\n            object.__setattr__(self, \"unit_category\", InventoryUnitCategory.UNITS)\n    return self\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.validate_company_string","title":"validate_company_string  <code>classmethod</code>","text":"<pre><code>validate_company_string(value: Any) -&gt; Any\n</code></pre> Source code in <code>src/albert/resources/inventory.py</code> <pre><code>@field_validator(\"company\", mode=\"before\")\n@classmethod\ndef validate_company_string(cls, value: Any) -&gt; Any:\n    if isinstance(value, str):\n        value = Company(name=value)\n    return value\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.validate_formula_fields","title":"validate_formula_fields","text":"<pre><code>validate_formula_fields() -&gt; InventoryItem\n</code></pre> <p>Ensure required fields are present for formulas.</p> Source code in <code>src/albert/resources/inventory.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_formula_fields(self) -&gt; \"InventoryItem\":\n    \"\"\"Ensure required fields are present for formulas.\"\"\"\n    if self.category == InventoryCategory.FORMULAS and not self.project_id and not self.id:\n        # Some legacy on platform formulas don't have a project_id so check if its already on platform\n        raise ValueError(\"A project_id must be supplied for all formulas.\")\n    return self\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventoryItem.validate_un_number","title":"validate_un_number  <code>classmethod</code>","text":"<pre><code>validate_un_number(value: Any) -&gt; Any\n</code></pre> Source code in <code>src/albert/resources/inventory.py</code> <pre><code>@field_validator(\"un_number\", mode=\"before\")\n@classmethod\ndef validate_un_number(cls, value: Any) -&gt; Any:\n    if value == \"N/A\":\n        value = None\n    return value\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySearchItem","title":"InventorySearchItem","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"inventory/#albert.collections.inventory.InventorySearchItem.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: InventoryCategory\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySearchItem.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = Field(default='')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySearchItem.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(alias='albertId')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySearchItem.inventory_on_hand","title":"inventory_on_hand  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_on_hand: float = Field(\n    default=0.0, alias=\"inventoryOnHand\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySearchItem.lots","title":"lots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lots: list[dict[str, Any]] = Field(default_factory=list)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySearchItem.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(default='')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySearchItem.pictogram","title":"pictogram  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pictogram: list[InventorySearchPictogramItem] = Field(\n    default_factory=list\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySearchItem.sds","title":"sds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sds: InventorySearchSDSItem | None = Field(\n    default=None, alias=\"SDS\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySearchItem.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: list[Tag] = Field(default_factory=list)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySearchItem.unit","title":"unit  <code>instance-attribute</code>","text":"<pre><code>unit: InventoryUnitCategory\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec","title":"InventorySpec","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.data_column_id","title":"data_column_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_column_id: str = Field(..., alias='datacolumnId')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.data_column_name","title":"data_column_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_column_name: str | None = Field(\n    default=None, alias=\"datacolumnName\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.data_template_id","title":"data_template_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_template_id: str | None = Field(\n    default=None, alias=\"datatemplateId\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.data_template_name","title":"data_template_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_template_name: str | None = Field(\n    default=None, alias=\"datatemplateName\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.spec_config","title":"spec_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>spec_config: str | None = Field(\n    default=None, alias=\"specConfig\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.unit_id","title":"unit_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit_id: str | None = Field(default=None, alias='unitId')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.unit_name","title":"unit_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit_name: str | None = Field(\n    default=None, alias=\"unitName\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: InventorySpecValue | None = Field(\n    default=None, alias=\"Value\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.workflow_id","title":"workflow_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workflow_id: str | None = Field(\n    default=None, alias=\"workflowId\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpec.workflow_name","title":"workflow_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workflow_name: str | None = Field(\n    default=None, alias=\"workflowName\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpecList","title":"InventorySpecList","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"inventory/#albert.collections.inventory.InventorySpecList.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: str = Field(..., alias='parentId')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.InventorySpecList.specs","title":"specs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specs: list[InventorySpec] = Field(..., alias='Specs')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.Location","title":"Location","text":"<p>               Bases: <code>BaseResource</code></p> <p>A location in Albert.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the location.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the location. Set when the location is retrieved from Albert.</p> <code>latitude</code> <code>float</code> <p>The latitude of the location.</p> <code>longitude</code> <code>float</code> <p>The longitude of the location.</p> <code>address</code> <code>str</code> <p>The address of the location.</p> <code>country</code> <code>str | None</code> <p>The country code of the location. Must be two characters long.</p>"},{"location":"inventory/#albert.collections.inventory.Location.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address: str\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.Location.country","title":"country  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>country: str | None = Field(\n    None, max_length=2, min_length=2\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.Location.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(None, alias='albertId')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.Location.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = Field()\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.Location.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = Field()\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.Location.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.MergeInventory","title":"MergeInventory","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"inventory/#albert.collections.inventory.MergeInventory.child_inventories","title":"child_inventories  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>child_inventories: list[dict[str, InventoryId]] = Field(\n    alias=\"ChildInventories\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.MergeInventory.modules","title":"modules  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>modules: list[str] | None = Field(default=None)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.MergeInventory.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: InventoryId = Field(alias='parentId')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"inventory/#albert.collections.inventory.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.StorageLocation","title":"StorageLocation","text":"<p>               Bases: <code>BaseResource</code></p> <p>A storage location entity. For example, a specific flammables cabinet or a storage room.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the storage location.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the storage location. Set when the storage location is retrieved from Albert.</p> <code>location</code> <code>Location</code> <p>The location entity link of the storage location.</p>"},{"location":"inventory/#albert.collections.inventory.StorageLocation.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(alias='albertId', default=None)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.StorageLocation.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: SerializeAsEntityLink[Location] = Field(\n    alias=\"Location\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.StorageLocation.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(\n    alias=\"name\", min_length=2, max_length=255\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.TagCollection","title":"TagCollection","text":"<pre><code>TagCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>TagCollection is a collection class for managing Tag entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base URL for tag API requests.</p> <p>Methods:</p> Name Description <code>list</code> <p>Lists tag entities with optional filters.</p> <code>tag_exists</code> <p>Checks if a tag exists by its name.</p> <code>create</code> <p>Creates a new tag entity.</p> <code>get_by_id</code> <p>Retrieves a tag by its ID.</p> <code>get_by_ids</code> <p>Retrieve a list of tags by their IDs.</p> <code>get_by_tag</code> <p>Retrieves a tag by its name.</p> <code>delete</code> <p>Deletes a tag by its ID.</p> <code>rename</code> <p>Renames an existing tag entity.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required Source code in <code>src/albert/collections/tags.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the TagCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{TagCollection._api_version}/tags\"\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.TagCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/tags'\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.TagCollection.create","title":"create","text":"<pre><code>create(*, tag: str | Tag) -&gt; Tag\n</code></pre> <p>Creates a new tag entity if the given tag does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Union[str, Tag]</code> <p>The tag name or Tag object to create.</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>The created Tag object or the existing Tag object of it already exists.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def create(self, *, tag: str | Tag) -&gt; Tag:\n    \"\"\"\n    Creates a new tag entity if the given tag does not exist.\n\n    Parameters\n    ----------\n    tag : Union[str, Tag]\n        The tag name or Tag object to create.\n\n    Returns\n    -------\n    Tag\n        The created Tag object or the existing Tag object of it already exists.\n    \"\"\"\n    if isinstance(tag, str):\n        tag = Tag(tag=tag)\n    hit = self.get_by_tag(tag=tag.tag, exact_match=True)\n    if hit is not None:\n        logging.warning(f\"Tag {hit.tag} already exists with id {hit.id}\")\n        return hit\n    payload = {\"name\": tag.tag}\n    response = self.session.post(self.base_path, json=payload)\n    tag = Tag(**response.json())\n    return tag\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.TagCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a tag by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the tag to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a tag by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the tag to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.TagCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Tag\n</code></pre> <p>Get a tag by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the tag to get.</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>The Tag object.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Tag:\n    \"\"\"\n    Get a tag by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the tag to get.\n\n    Returns\n    -------\n    Tag\n        The Tag object.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return Tag(**response.json())\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.TagCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(*, ids: list[str]) -&gt; list[Tag]\n</code></pre> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def get_by_ids(self, *, ids: list[str]) -&gt; list[Tag]:\n    url = f\"{self.base_path}/ids\"\n    batches = [ids[i : i + 100] for i in range(0, len(ids), 100)]\n    return [\n        Tag(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()\n    ]\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.TagCollection.get_by_tag","title":"get_by_tag","text":"<pre><code>get_by_tag(\n    *, tag: str, exact_match: bool = True\n) -&gt; Tag | None\n</code></pre> <p>Retrieves a tag by its name of None if not found.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The name of the tag to retrieve.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tag</code> <p>The Tag object if found, None otherwise.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def get_by_tag(self, *, tag: str, exact_match: bool = True) -&gt; Tag | None:\n    \"\"\"\n    Retrieves a tag by its name of None if not found.\n\n    Parameters\n    ----------\n    tag : str\n        The name of the tag to retrieve.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    Tag\n        The Tag object if found, None otherwise.\n    \"\"\"\n    found = self.list(name=tag, exact_match=exact_match)\n    return next(found, None)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.TagCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 50,\n    order_by: OrderBy = DESCENDING,\n    name: str | list[str] | None = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Tag]\n</code></pre> <p>Lists Tag entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of tags to return, by default 50.</p> <code>50</code> <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <code>name</code> <code>Union[str, None]</code> <p>The name of the tag to filter by, by default None.</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <code>start_key</code> <code>Optional[str]</code> <p>The starting point for the next set of results, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Tag]</code> <p>An iterator of Tag objects.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 50,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    name: str | list[str] | None = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Tag]:\n    \"\"\"\n    Lists Tag entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of tags to return, by default 50.\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING.\n    name : Union[str, None], optional\n        The name of the tag to filter by, by default None.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n    start_key : Optional[str], optional\n        The starting point for the next set of results, by default None.\n\n    Returns\n    -------\n    Iterator[Tag]\n        An iterator of Tag objects.\n    \"\"\"\n    params = {\"limit\": limit, \"orderBy\": order_by.value, \"startKey\": start_key}\n    if name:\n        params[\"name\"] = [name] if isinstance(name, str) else name\n        params[\"exactMatch\"] = json.dumps(exact_match)\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Tag(**item) for item in items],\n    )\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.TagCollection.rename","title":"rename","text":"<pre><code>rename(*, old_name: str, new_name: str) -&gt; Tag\n</code></pre> <p>Renames an existing tag entity.</p> <p>Parameters:</p> Name Type Description Default <code>old_name</code> <code>str</code> <p>The current name of the tag.</p> required <code>new_name</code> <code>str</code> <p>The new name of the tag.</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>The renamed Tag.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def rename(self, *, old_name: str, new_name: str) -&gt; Tag:\n    \"\"\"\n    Renames an existing tag entity.\n\n    Parameters\n    ----------\n    old_name : str\n        The current name of the tag.\n    new_name : str\n        The new name of the tag.\n\n    Returns\n    -------\n    Tag\n        The renamed Tag.\n    \"\"\"\n    found_tag = self.get_by_tag(tag=old_name, exact_match=True)\n    if not found_tag:\n        msg = f'Tag \"{old_name}\" not found.'\n        logger.error(msg)\n        raise AlbertException(msg)\n    tag_id = found_tag.id\n    payload = [\n        {\n            \"data\": [\n                {\n                    \"operation\": \"update\",\n                    \"attribute\": \"name\",\n                    \"oldValue\": old_name,\n                    \"newValue\": new_name,\n                }\n            ],\n            \"id\": tag_id,\n        }\n    ]\n    self.session.patch(self.base_path, json=payload)\n    return self.get_by_id(id=tag_id)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.TagCollection.tag_exists","title":"tag_exists","text":"<pre><code>tag_exists(*, tag: str, exact_match: bool = True) -&gt; bool\n</code></pre> <p>Checks if a tag exists by its name.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The name of the tag to check.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the tag exists, False otherwise.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def tag_exists(self, *, tag: str, exact_match: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if a tag exists by its name.\n\n    Parameters\n    ----------\n    tag : str\n        The name of the tag to check.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    bool\n        True if the tag exists, False otherwise.\n    \"\"\"\n\n    return self.get_by_tag(tag=tag, exact_match=exact_match) is not None\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.User","title":"User","text":"<p>               Bases: <code>BaseResource</code></p> <p>Represents a User on the Albert Platform</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the user.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the user. Set when the user is retrieved from Albert.</p> <code>location</code> <code>Location | None</code> <p>The location of the user.</p> <code>email</code> <code>EmailStr | None</code> <p>The email of the user.</p> <code>roles</code> <code>list[Role]</code> <p>The roles of the user.</p> <code>user_class</code> <code>UserClass</code> <p>The ACL class level of the user.</p> <code>metadata</code> <code>dict[str, str | list[EntityLink] | EntityLink] | None</code> <p>Methods:</p> Name Description <code>to_note_mention</code> <p>Convert the user to a note mention string.</p>"},{"location":"inventory/#albert.collections.inventory.User.email","title":"email  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>email: EmailStr = Field(default=None, alias='email')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.User.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UserId | None = Field(None, alias='albertId')\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.User.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: SerializeAsEntityLink[Location] | None = Field(\n    default=None, alias=\"Location\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.User.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] | None = Field(\n    alias=\"Metadata\", default=None\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.User.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.User.roles","title":"roles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>roles: list[SerializeAsEntityLink[Role]] = Field(\n    max_length=1, default_factory=list, alias=\"Roles\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.User.user_class","title":"user_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_class: UserClass = Field(\n    default=STANDARD, alias=\"userClass\"\n)\n</code></pre>"},{"location":"inventory/#albert.collections.inventory.User.to_note_mention","title":"to_note_mention","text":"<pre><code>to_note_mention() -&gt; str\n</code></pre> <p>Convert the user to a note mention string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The note mention string.</p> Source code in <code>src/albert/resources/users.py</code> <pre><code>def to_note_mention(self) -&gt; str:\n    \"\"\"Convert the user to a note mention string.\n\n    Returns\n    -------\n    str\n        The note mention string.\n    \"\"\"\n    return f\"@{self.name}#{self.id}#\"\n</code></pre>"},{"location":"links/","title":"Links","text":""},{"location":"links/#albert.collections.links.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"links/#albert.collections.links.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"links/#albert.collections.links.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"links/#albert.collections.links.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"links/#albert.collections.links.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"links/#albert.collections.links.Link","title":"Link","text":"<p>               Bases: <code>BaseResource</code></p> <p>A link in Albert.</p> <p>Attributes:</p> Name Type Description <code>parent</code> <code>EntityLink</code> <p>The parent entity of the link.</p> <code>child</code> <code>BaseEntity</code> <p>The child entity of the link.</p> <code>category</code> <code>LinkCategory</code> <p>The category of the link. Allowed values are <code>mention</code>, <code>linkedTask</code>, and <code>synthesis</code>.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the link. Set when the link is retrieved from Albert.</p> <code>counter</code> <code>int | None</code> <p>The counter of the link. Optional.</p>"},{"location":"links/#albert.collections.links.Link.category","title":"category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category: LinkCategory = Field(...)\n</code></pre>"},{"location":"links/#albert.collections.links.Link.child","title":"child  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>child: EntityLink = Field(..., alias='Child')\n</code></pre>"},{"location":"links/#albert.collections.links.Link.counter","title":"counter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>counter: int | None = Field(default=None)\n</code></pre>"},{"location":"links/#albert.collections.links.Link.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"links/#albert.collections.links.Link.parent","title":"parent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent: EntityLink = Field(..., alias='Parent')\n</code></pre>"},{"location":"links/#albert.collections.links.LinkCategory","title":"LinkCategory","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"links/#albert.collections.links.LinkCategory.LINKED_INVENTORY","title":"LINKED_INVENTORY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LINKED_INVENTORY = 'linkedInventory'\n</code></pre>"},{"location":"links/#albert.collections.links.LinkCategory.LINKED_TASK","title":"LINKED_TASK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LINKED_TASK = 'linkedTask'\n</code></pre>"},{"location":"links/#albert.collections.links.LinkCategory.MENTION","title":"MENTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MENTION = 'mention'\n</code></pre>"},{"location":"links/#albert.collections.links.LinkCategory.SYNTHESIS","title":"SYNTHESIS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYNTHESIS = 'synthesis'\n</code></pre>"},{"location":"links/#albert.collections.links.LinksCollection","title":"LinksCollection","text":"<pre><code>LinksCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>LinksCollection is a collection class for managing Link entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Creates a new link entity.</p> <code>delete</code> <p>Deletes a link entity by its ID.</p> <code>get_by_id</code> <p>Retrieves a link entity by its ID.</p> <code>list</code> <p>Generates a list of link entities with optional filters.</p> Source code in <code>src/albert/collections/links.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the LinksCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{LinksCollection._api_version}/links\"\n</code></pre>"},{"location":"links/#albert.collections.links.LinksCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/links'\n</code></pre>"},{"location":"links/#albert.collections.links.LinksCollection.create","title":"create","text":"<pre><code>create(*, links: list[Link]) -&gt; list[Link]\n</code></pre> <p>Creates a new link entity.</p> <p>Parameters:</p> Name Type Description Default <code>links</code> <code>list[Link]</code> <p>List of Link entities to create.</p> required <p>Returns:</p> Type Description <code>Link</code> <p>The created link entity.</p> Source code in <code>src/albert/collections/links.py</code> <pre><code>def create(self, *, links: list[Link]) -&gt; list[Link]:\n    \"\"\"\n    Creates a new link entity.\n\n    Parameters\n    ----------\n    links : list[Link]\n        List of Link entities to create.\n\n    Returns\n    -------\n    Link\n        The created link entity.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=[l.model_dump(by_alias=True, exclude_none=True, mode=\"json\") for l in links],\n    )\n    return [Link(**l) for l in response.json()]\n</code></pre>"},{"location":"links/#albert.collections.links.LinksCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a link entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the link entity to delete.</p> required Source code in <code>src/albert/collections/links.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a link entity by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the link entity to delete.\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    self.session.delete(path)\n</code></pre>"},{"location":"links/#albert.collections.links.LinksCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Link\n</code></pre> <p>Retrieves a link entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the link entity to retrieve.</p> required <p>Returns:</p> Type Description <code>Link</code> <p>The retrieved link entity.</p> Source code in <code>src/albert/collections/links.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Link:\n    \"\"\"\n    Retrieves a link entity by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the link entity to retrieve.\n\n    Returns\n    -------\n    Link\n        The retrieved link entity.\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    response = self.session.get(path)\n    return Link(**response.json())\n</code></pre>"},{"location":"links/#albert.collections.links.LinksCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    type: str | None = None,\n    category: LinkCategory | None = None,\n    id: str | None = None,\n) -&gt; Iterator[Link]\n</code></pre> <p>Generates a list of link entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of link entities to return.</p> <code>100</code> <code>type</code> <code>str</code> <p>The type of the link entities to return. Allowed values are <code>parent</code>, <code>child</code>, and <code>all</code>. If type is \"all\" then it will fetch both parent/child record for mentioned id.</p> <code>None</code> <code>category</code> <code>LinkCategory</code> <p>The category of the link entities to return. Allowed values are <code>mention</code>, <code>linkedTask</code>, and <code>synthesis</code>.</p> <code>None</code> <code>id</code> <code>str</code> <p>The ID of the link entity to return. (Use with <code>type</code> parameter)</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Link]</code> <p>An iterator of Links.</p> Source code in <code>src/albert/collections/links.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    type: str | None = None,\n    category: LinkCategory | None = None,\n    id: str | None = None,\n) -&gt; Iterator[Link]:\n    \"\"\"\n    Generates a list of link entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of link entities to return.\n    type : str, optional\n        The type of the link entities to return. Allowed values are `parent`, `child`, and `all`. If type is \"all\" then it will fetch both parent/child record for mentioned id.\n    category : LinkCategory, optional\n        The category of the link entities to return. Allowed values are `mention`, `linkedTask`, and `synthesis`.\n    id : str\n        The ID of the link entity to return. (Use with `type` parameter)\n\n    Returns\n    ------\n    Iterator[Link]\n        An iterator of Links.\n    \"\"\"\n    params = {\"limit\": limit, \"type\": type, \"category\": category, \"id\": id}\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        params=params,\n        session=self.session,\n        deserialize=lambda items: [Link(**item) for item in items],\n    )\n</code></pre>"},{"location":"lists/","title":"Lists","text":""},{"location":"lists/#albert.collections.lists.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"lists/#albert.collections.lists.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"lists/#albert.collections.lists.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"lists/#albert.collections.lists.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"lists/#albert.collections.lists.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListItem","title":"ListItem","text":"<p>               Bases: <code>BaseResource</code></p> <p>An item in a list.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the list item.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the list item. Set when the list item is retrieved from Albert.</p> <code>category</code> <code>ListItemCategory | None</code> <p>The category of the list item. Allowed values are <code>businessDefined</code>, <code>userDefined</code>, <code>projects</code>, and <code>extensions</code>.</p> <code>list_type</code> <code>str | None</code> <p>The type of the list item. Allowed values are <code>projectState</code> for <code>projects</code> and <code>extensions</code> for <code>extensions</code>.</p> <p>Methods:</p> Name Description <code>validate_list_type</code>"},{"location":"lists/#albert.collections.lists.ListItem.category","title":"category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category: ListItemCategory | None = Field(default=None)\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListItem.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListItem.list_type","title":"list_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>list_type: str | None = Field(\n    default=None, alias=\"listType\"\n)\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListItem.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListItem.validate_list_type","title":"validate_list_type","text":"<pre><code>validate_list_type() -&gt; ListItem\n</code></pre> Source code in <code>src/albert/resources/lists.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_list_type(self) -&gt; \"ListItem\":\n    if (\n        self.category == ListItemCategory.PROJECTS\n        and self.list_type is not None\n        and self.list_type != \"projectState\"\n    ) or (\n        self.category == ListItemCategory.EXTENSIONS\n        and self.list_type is not None\n        and self.list_type != \"extensions\"\n    ):\n        raise ValueError(\n            f\"List type {self.list_type} is not allowed for category {self.category}\"\n        )\n    return self\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListItemCategory","title":"ListItemCategory","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"lists/#albert.collections.lists.ListItemCategory.BUSINESS_DEFINED","title":"BUSINESS_DEFINED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUSINESS_DEFINED = 'businessDefined'\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListItemCategory.EXTENSIONS","title":"EXTENSIONS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXTENSIONS = 'extensions'\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListItemCategory.INVENTORY","title":"INVENTORY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INVENTORY = 'inventory'\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListItemCategory.PROJECTS","title":"PROJECTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROJECTS = 'projects'\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListItemCategory.USER_DEFINED","title":"USER_DEFINED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>USER_DEFINED = 'userDefined'\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListsCollection","title":"ListsCollection","text":"<pre><code>ListsCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ListsCollection is a collection class for managing ListItem entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Creates a list entity.</p> <code>delete</code> <p>Delete a lists entry item by its ID.</p> <code>get_by_id</code> <p>Retrieves a list entity by its ID.</p> <code>get_matching_item</code> <p>Get a list item by name and list type.</p> <code>list</code> <p>Generates a list of list entities with optional filters.</p> <code>update</code> <p>Update a list item.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the TagCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ListsCollection._api_version}/lists\"\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListsCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/lists'\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListsCollection.create","title":"create","text":"<pre><code>create(*, list_item: ListItem) -&gt; ListItem\n</code></pre> <p>Creates a list entity.</p> <p>Parameters:</p> Name Type Description Default <code>list_item</code> <code>ListItem</code> <p>The list entity to create.</p> required <p>Returns:</p> Type Description <code>List</code> <p>The created list entity.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def create(self, *, list_item: ListItem) -&gt; ListItem:\n    \"\"\"\n    Creates a list entity.\n\n    Parameters\n    ----------\n    list_item : ListItem\n        The list entity to create.\n\n    Returns\n    -------\n    List\n        The created list entity.\n    \"\"\"\n    response = self.session.post(\n        self.base_path,\n        json=list_item.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return ListItem(**response.json())\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListsCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a lists entry item by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the lists item.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Delete a lists entry item by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the lists item.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListsCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; ListItem\n</code></pre> <p>Retrieves a list entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the list entity to retrieve.</p> required <p>Returns:</p> Type Description <code>List</code> <p>A list entity.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; ListItem:\n    \"\"\"\n    Retrieves a list entity by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the list entity to retrieve.\n\n    Returns\n    -------\n    List\n        A list entity.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return ListItem(**response.json())\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListsCollection.get_matching_item","title":"get_matching_item","text":"<pre><code>get_matching_item(\n    *, name: str, list_type: str\n) -&gt; ListItem | None\n</code></pre> <p>Get a list item by name and list type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of it item to retrieve.</p> required <code>list_type</code> <code>str</code> <p>The type of list (can be the name of the custom field)</p> required <p>Returns:</p> Type Description <code>ListItem | None</code> <p>A list item with the provided name and list type, or None if not found.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def get_matching_item(self, *, name: str, list_type: str) -&gt; ListItem | None:\n    \"\"\"Get a list item by name and list type.\n\n    Parameters\n    ----------\n    name : str\n        The name of it item to retrieve.\n    list_type : str\n        The type of list (can be the name of the custom field)\n\n    Returns\n    -------\n    ListItem | None\n        A list item with the provided name and list type, or None if not found.\n    \"\"\"\n    for list_item in self.list(names=[name], list_type=list_type):\n        if list_item.name.lower() == name.lower():\n            return list_item\n    return None\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListsCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    names: list[str] | None = None,\n    category: ListItemCategory | None = None,\n    list_type: str | None = None,\n    start_key: str | None = None,\n) -&gt; Iterator[ListItem]\n</code></pre> <p>Generates a list of list entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of list entities to return.</p> <code>100</code> <code>names</code> <code>list[str]</code> <p>A list of names of the list entity to retrieve.</p> <code>None</code> <code>category</code> <code>ListItemCategory</code> <p>The category of the list entity to retrieve.</p> <code>None</code> <code>list_type</code> <code>str</code> <p>The type of list entity to retrieve.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[ListItem]</code> <p>An iterator of ListItems.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    names: list[str] | None = None,\n    category: ListItemCategory | None = None,\n    list_type: str | None = None,\n    start_key: str | None = None,\n) -&gt; Iterator[ListItem]:\n    \"\"\"\n    Generates a list of list entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of list entities to return.\n    names : list[str], optional\n        A list of names of the list entity to retrieve.\n    category : ListItemCategory, optional\n        The category of the list entity to retrieve.\n    list_type : str, optional\n        The type of list entity to retrieve.\n    Returns\n    ------\n    Iterator[ListItem]\n        An iterator of ListItems.\n    \"\"\"\n    params = {\n        \"limit\": limit,\n        \"startKey\": start_key,\n        \"name\": [names] if isinstance(names, str) else names,\n        \"category\": category.value if isinstance(category, ListItemCategory) else category,\n        \"listType\": list_type,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [ListItem(**item) for item in items],\n    )\n</code></pre>"},{"location":"lists/#albert.collections.lists.ListsCollection.update","title":"update","text":"<pre><code>update(*, list_item=ListItem) -&gt; ListItem\n</code></pre> <p>Update a list item.</p> <p>Parameters:</p> Name Type Description Default <code>list_item</code> <code>ListItem</code> <p>The list item to update.</p> <code>ListItem</code> <p>Returns:</p> Type Description <code>ListItem</code> <p>The updated list item.</p> Source code in <code>src/albert/collections/lists.py</code> <pre><code>def update(self, *, list_item=ListItem) -&gt; ListItem:\n    \"\"\"Update a list item.\n\n    Parameters\n    ----------\n    list_item : ListItem\n        The list item to update.\n\n    Returns\n    -------\n    ListItem\n        The updated list item.\n    \"\"\"\n    existing = self.get_by_id(id=list_item.id)\n    patches = self._generate_patch_payload(\n        existing=existing, updated=list_item, generate_metadata_diff=False\n    )\n    if len(patches.data) == 0:\n        return existing\n    self.session.patch(\n        url=f\"{self.base_path}/{list_item.id}\",\n        json=patches.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n    )\n    return self.get_by_id(id=list_item.id)\n</code></pre>"},{"location":"locations/","title":"Locations","text":""},{"location":"locations/#albert.collections.locations.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"locations/#albert.collections.locations.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"locations/#albert.collections.locations.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"locations/#albert.collections.locations.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"locations/#albert.collections.locations.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"locations/#albert.collections.locations.Location","title":"Location","text":"<p>               Bases: <code>BaseResource</code></p> <p>A location in Albert.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the location.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the location. Set when the location is retrieved from Albert.</p> <code>latitude</code> <code>float</code> <p>The latitude of the location.</p> <code>longitude</code> <code>float</code> <p>The longitude of the location.</p> <code>address</code> <code>str</code> <p>The address of the location.</p> <code>country</code> <code>str | None</code> <p>The country code of the location. Must be two characters long.</p>"},{"location":"locations/#albert.collections.locations.Location.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address: str\n</code></pre>"},{"location":"locations/#albert.collections.locations.Location.country","title":"country  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>country: str | None = Field(\n    None, max_length=2, min_length=2\n)\n</code></pre>"},{"location":"locations/#albert.collections.locations.Location.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(None, alias='albertId')\n</code></pre>"},{"location":"locations/#albert.collections.locations.Location.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = Field()\n</code></pre>"},{"location":"locations/#albert.collections.locations.Location.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = Field()\n</code></pre>"},{"location":"locations/#albert.collections.locations.Location.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"locations/#albert.collections.locations.LocationCollection","title":"LocationCollection","text":"<pre><code>LocationCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>LocationCollection is a collection class for managing Location entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Creates a new Location entity.</p> <code>delete</code> <p>Deletes a Location entity.</p> <code>get_by_id</code> <p>Retrieves a location by its ID.</p> <code>list</code> <p>Searches for locations matching the provided criteria.</p> <code>location_exists</code> <p>Determines if a location, with the same name, exists in the collection.</p> <code>update</code> <p>Update a Location entity.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the LocationCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{LocationCollection._api_version}/locations\"\n</code></pre>"},{"location":"locations/#albert.collections.locations.LocationCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/locations'\n</code></pre>"},{"location":"locations/#albert.collections.locations.LocationCollection.create","title":"create","text":"<pre><code>create(*, location: Location) -&gt; Location\n</code></pre> <p>Creates a new Location entity.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Location</code> <p>The Location object to create.</p> required <p>Returns:</p> Type Description <code>Location</code> <p>The created Location object.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def create(self, *, location: Location) -&gt; Location:\n    \"\"\"\n    Creates a new Location entity.\n\n    Parameters\n    ----------\n    location : Location\n        The Location object to create.\n\n    Returns\n    -------\n    Location\n        The created Location object.\n    \"\"\"\n    exists = self.location_exists(location=location)\n    if exists:\n        logging.warning(\n            f\"Location with name {location.name} matches an existing location. Returning the existing Location.\"\n        )\n        return exists\n\n    payload = location.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    response = self.session.post(self.base_path, json=payload)\n\n    return Location(**response.json())\n</code></pre>"},{"location":"locations/#albert.collections.locations.LocationCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a Location entity.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>Str</code> <p>The id of the Location object to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a Location entity.\n\n    Parameters\n    ----------\n    id : Str\n        The id of the Location object to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"locations/#albert.collections.locations.LocationCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Location\n</code></pre> <p>Retrieves a location by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the location to retrieve.</p> required <p>Returns:</p> Type Description <code>Location</code> <p>The Location object.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Location:\n    \"\"\"\n    Retrieves a location by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the location to retrieve.\n\n    Returns\n    -------\n    Location\n        The Location object.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return Location(**response.json())\n</code></pre>"},{"location":"locations/#albert.collections.locations.LocationCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    name: str | list[str] | None = None,\n    country: str | None = None,\n    exact_match: bool = False,\n    limit: int = 50,\n    start_key: str | None = None,\n) -&gt; Iterator[Location]\n</code></pre> <p>Searches for locations matching the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | list[str] | None</code> <p>The name or names of locations to search for, by default None</p> <code>None</code> <code>country</code> <code>str | None</code> <p>The country code of the country to filter the locations , by default None</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to return exact matches only, by default False</p> <code>False</code> <p>Yields:</p> Type Description <code>Iterator[Location]</code> <p>An iterator of Location objects matching the search criteria.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def list(\n    self,\n    *,\n    name: str | list[str] | None = None,\n    country: str | None = None,\n    exact_match: bool = False,\n    limit: int = 50,\n    start_key: str | None = None,\n) -&gt; Iterator[Location]:\n    \"\"\"Searches for locations matching the provided criteria.\n\n    Parameters\n    ----------\n    name : str | list[str] | None, optional\n        The name or names of locations to search for, by default None\n    country : str | None, optional\n        The country code of the country to filter the locations , by default None\n    exact_match : bool, optional\n        Whether to return exact matches only, by default False\n\n\n    Yields\n    ------\n    Iterator[Location]\n        An iterator of Location objects matching the search criteria.\n    \"\"\"\n    params = {\"limit\": limit, \"startKey\": start_key, \"country\": country}\n    if name:\n        params[\"name\"] = [name] if isinstance(name, str) else name\n        params[\"exactMatch\"] = json.dumps(exact_match)\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Location(**item) for item in items],\n    )\n</code></pre>"},{"location":"locations/#albert.collections.locations.LocationCollection.location_exists","title":"location_exists","text":"<pre><code>location_exists(*, location: Location) -&gt; Location | None\n</code></pre> <p>Determines if a location, with the same name, exists in the collection.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Location</code> <p>The Location object to check</p> required <p>Returns:</p> Type Description <code>Location | None</code> <p>The existing registered Location object if found, otherwise None.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def location_exists(self, *, location: Location) -&gt; Location | None:\n    \"\"\"Determines if a location, with the same name, exists in the collection.\n\n    Parameters\n    ----------\n    location : Location\n        The Location object to check\n\n    Returns\n    -------\n    Location | None\n        The existing registered Location object if found, otherwise None.\n    \"\"\"\n    hits = self.list(name=location.name)\n    if hits:\n        for hit in hits:\n            if hit and hit.name.lower() == location.name.lower():\n                return hit\n    return None\n</code></pre>"},{"location":"locations/#albert.collections.locations.LocationCollection.update","title":"update","text":"<pre><code>update(*, location: Location) -&gt; Location\n</code></pre> <p>Update a Location entity.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Location</code> <p>The Location object to update. The ID of the Location object must be provided.</p> required <p>Returns:</p> Type Description <code>Location</code> <p>The updated Location object as returned by the server.</p> Source code in <code>src/albert/collections/locations.py</code> <pre><code>def update(self, *, location: Location) -&gt; Location:\n    \"\"\"Update a Location entity.\n\n    Parameters\n    ----------\n    location : Location\n        The Location object to update. The ID of the Location object must be provided.\n\n    Returns\n    -------\n    Location\n        The updated Location object as returned by the server.\n    \"\"\"\n    # Fetch the current object state from the server or database\n    current_object = self.get_by_id(id=location.id)\n    # Generate the PATCH payload\n    patch_payload = self._generate_patch_payload(\n        existing=current_object,\n        updated=location,\n        stringify_values=True,\n    )\n    url = f\"{self.base_path}/{location.id}\"\n    self.session.patch(url, json=patch_payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=location.id)\n</code></pre>"},{"location":"lots/","title":"Lots","text":""},{"location":"lots/#albert.collections.lots.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"lots/#albert.collections.lots.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"lots/#albert.collections.lots.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"lots/#albert.collections.lots.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"lots/#albert.collections.lots.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot","title":"Lot","text":"<p>               Bases: <code>BaseResource</code></p> <p>A lot in Albert.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>LotId | None</code> <p>The Albert ID of the lot. Set when the lot is retrieved from Albert.</p> <code>inventory_id</code> <code>InventoryId</code> <p>The Albert ID of the inventory item associated with the lot.</p> <code>task_id</code> <code>str | None</code> <p>The Albert ID of the task associated with the creation of lot. Optional.</p> <code>notes</code> <code>str | None</code> <p>The notes associated with the lot. Optional.</p> <code>expiration_date</code> <code>str | None</code> <p>The expiration date of the lot. YYYY-MM-DD format. Optional.</p> <code>manufacturer_lot_number</code> <code>str | None</code> <p>The manufacturer lot number of the lot. Optional.</p> <code>storage_location</code> <code>StorageLocation | None</code> <p>The storage location of the lot. Optional.</p> <code>pack_size</code> <code>str | None</code> <p>The pack size of the lot. Optional. Used to calculate the cost per unit.</p> <code>initial_quantity</code> <code>NonNegativeFloat | None</code> <p>The initial quantity of the lot. Optional.</p> <code>cost</code> <code>NonNegativeFloat | None</code> <p>The cost of the lot. Optional.</p> <code>inventory_on_hand</code> <code>NonNegativeFloat</code> <p>The inventory on hand of the lot.</p> <code>owner</code> <code>list[User] | None</code> <p>The owners of the lot. Optional.</p> <code>lot_number</code> <code>str | None</code> <p>The lot number of the lot. Optional.</p> <code>external_barcode_id</code> <code>str | None</code> <p>The external barcode ID of the lot. Optional.</p> <code>metadata</code> <code>dict[str, str | list[EntityLink] | EntityLink] | None</code> <p>The metadata of the lot. Optional. Metadata allowed values can be found using the Custom Fields API.</p> <code>has_notes</code> <code>bool</code> <p>Whether the lot has notes. Read-only.</p> <code>has_attachments</code> <code>bool</code> <p>Whether the lot has attachments. Read-only.</p> <code>barcode_id</code> <code>str</code> <p>The barcode ID of the lot. Read-only.</p> <p>Methods:</p> Name Description <code>serialize_cost</code> <code>serialize_initial_quantity</code> <code>serialize_inventory_on_hand</code> <code>validate_has_attachments</code> <code>validate_has_notes</code>"},{"location":"lots/#albert.collections.lots.Lot.barcode_id","title":"barcode_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>barcode_id: str | None = Field(\n    default=None, alias=\"barcodeId\"\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.cost","title":"cost  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cost: NonNegativeFloat | None = Field(default=None)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.expiration_date","title":"expiration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>expiration_date: str | None = Field(\n    None, alias=\"expirationDate\"\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.external_barcode_id","title":"external_barcode_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>external_barcode_id: str | None = Field(\n    None, alias=\"externalBarcodeId\"\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.has_attachments","title":"has_attachments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>has_attachments: bool | None = Field(\n    default=None,\n    alias=\"hasAttachments\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.has_notes","title":"has_notes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>has_notes: bool | None = Field(\n    default=None,\n    alias=\"hasNotes\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: LotId | None = Field(None, alias='albertId')\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.initial_quantity","title":"initial_quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_quantity: NonNegativeFloat | None = Field(\n    default=None, alias=\"initialQuantity\"\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.inventory_id","title":"inventory_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_id: InventoryId = Field(alias='parentId')\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.inventory_on_hand","title":"inventory_on_hand  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_on_hand: float = Field(alias='inventoryOnHand')\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: SerializeAsEntityLink[Location] | None = Field(\n    default=None,\n    alias=\"Location\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.lot_number","title":"lot_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lot_number: str | None = Field(None, alias='lotNumber')\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.manufacturer_lot_number","title":"manufacturer_lot_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>manufacturer_lot_number: str | None = Field(\n    None, alias=\"manufacturerLotNumber\"\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] | None = Field(\n    alias=\"Metadata\", default=None\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.notes","title":"notes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>notes: str | None = Field(\n    default=None, exclude=True, frozen=True\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.owner","title":"owner  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>owner: list[SerializeAsEntityLink[User]] | None = Field(\n    default=None, alias=\"Owner\"\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.pack_size","title":"pack_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pack_size: str | None = Field(None, alias='packSize')\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.parent_category","title":"parent_category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_category: InventoryCategory | None = Field(\n    default=None,\n    alias=\"parentCategory\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.parent_name","title":"parent_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_name: str | None = Field(\n    default=None,\n    alias=\"parentName\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.parent_unit","title":"parent_unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_unit: str | None = Field(\n    default=None,\n    alias=\"parentUnit\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: LotStatus | None = Field(default=None)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.storage_location","title":"storage_location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>storage_location: (\n    SerializeAsEntityLink[StorageLocation] | None\n) = Field(alias=\"StorageLocation\", default=None)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.task_id","title":"task_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task_id: str | None = Field(default=None, alias='taskId')\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.serialize_cost","title":"serialize_cost","text":"<pre><code>serialize_cost(cost: NonNegativeFloat)\n</code></pre> Source code in <code>src/albert/resources/lots.py</code> <pre><code>@field_serializer(\"cost\", return_type=str)\ndef serialize_cost(self, cost: NonNegativeFloat):\n    return str(cost)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.serialize_initial_quantity","title":"serialize_initial_quantity","text":"<pre><code>serialize_initial_quantity(\n    initial_quantity: NonNegativeFloat,\n)\n</code></pre> Source code in <code>src/albert/resources/lots.py</code> <pre><code>@field_serializer(\"initial_quantity\", return_type=str)\ndef serialize_initial_quantity(self, initial_quantity: NonNegativeFloat):\n    return str(initial_quantity)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.serialize_inventory_on_hand","title":"serialize_inventory_on_hand","text":"<pre><code>serialize_inventory_on_hand(\n    inventory_on_hand: NonNegativeFloat,\n)\n</code></pre> Source code in <code>src/albert/resources/lots.py</code> <pre><code>@field_serializer(\"inventory_on_hand\", return_type=str)\ndef serialize_inventory_on_hand(self, inventory_on_hand: NonNegativeFloat):\n    return str(inventory_on_hand)\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.validate_has_attachments","title":"validate_has_attachments","text":"<pre><code>validate_has_attachments(value: Any) -&gt; Any\n</code></pre> Source code in <code>src/albert/resources/lots.py</code> <pre><code>@field_validator(\"has_attachments\", mode=\"before\")\ndef validate_has_attachments(cls, value: Any) -&gt; Any:\n    if value == \"1\":\n        return True\n    elif value == \"0\":\n        return False\n    return value\n</code></pre>"},{"location":"lots/#albert.collections.lots.Lot.validate_has_notes","title":"validate_has_notes","text":"<pre><code>validate_has_notes(value: Any) -&gt; Any\n</code></pre> Source code in <code>src/albert/resources/lots.py</code> <pre><code>@field_validator(\"has_notes\", mode=\"before\")\ndef validate_has_notes(cls, value: Any) -&gt; Any:\n    if value == \"1\":\n        return True\n    elif value == \"0\":\n        return False\n    return value\n</code></pre>"},{"location":"lots/#albert.collections.lots.LotCollection","title":"LotCollection","text":"<pre><code>LotCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>LotCollection is a collection class for managing Lot entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>An Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <code>delete</code> <p>Delete a lot by its ID.</p> <code>get_by_id</code> <p>Get a lot by its ID.</p> <code>get_by_ids</code> <p>Get a list of lots by their IDs.</p> <code>list</code> <p>Lists Lot entities with optional filters.</p> <code>update</code> <p>Update a lot.</p> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"A collection for interacting with Lots in Albert.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        An Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{LotCollection._api_version}/lots\"\n</code></pre>"},{"location":"lots/#albert.collections.lots.LotCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/lots'\n</code></pre>"},{"location":"lots/#albert.collections.lots.LotCollection.create","title":"create","text":"<pre><code>create(*, lots: list[Lot]) -&gt; list[Lot]\n</code></pre> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def create(self, *, lots: list[Lot]) -&gt; list[Lot]:\n    # TODO: Once thi endpoint is fixed, go back to passing the whole list at once\n    payload = [lot.model_dump(by_alias=True, exclude_none=True, mode=\"json\") for lot in lots]\n    all_lots = []\n    for lot in payload:\n        response = self.session.post(self.base_path, json=[lot])\n        all_lots.append(Lot(**response.json()[0]))\n    # response = self.session.post(self.base_path, json=payload)\n    # return [Lot(**lot) for lot in response.json().get(\"CreatedLots\", [])]\n    return all_lots\n</code></pre>"},{"location":"lots/#albert.collections.lots.LotCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a lot by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the lot to delete.</p> required Source code in <code>src/albert/collections/lots.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a lot by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the lot to delete.\n    \"\"\"\n    url = f\"{self.base_path}?id={id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"lots/#albert.collections.lots.LotCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Lot\n</code></pre> <p>Get a lot by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the lot to get.</p> required <p>Returns:</p> Type Description <code>Lot</code> <p>The lot with the provided ID.</p> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Lot:\n    \"\"\"Get a lot by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the lot to get.\n\n    Returns\n    -------\n    Lot\n        The lot with the provided ID.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return Lot(**response.json())\n</code></pre>"},{"location":"lots/#albert.collections.lots.LotCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(*, ids: list[str]) -&gt; list[Lot]\n</code></pre> <p>Get a list of lots by their IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>A list of lot IDs to get.</p> required <p>Returns:</p> Type Description <code>list[Lot]</code> <p>A list of lots with the provided IDs.</p> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def get_by_ids(self, *, ids: list[str]) -&gt; list[Lot]:\n    \"\"\"Get a list of lots by their IDs.\n\n    Parameters\n    ----------\n    ids : list[str]\n        A list of lot IDs to get.\n\n    Returns\n    -------\n    list[Lot]\n        A list of lots with the provided IDs.\n    \"\"\"\n    url = f\"{self.base_path}/ids\"\n    response = self.session.get(url, params={\"id\": ids})\n    return [Lot(**lot) for lot in response.json()[\"Items\"]]\n</code></pre>"},{"location":"lots/#albert.collections.lots.LotCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    start_key: str | None = None,\n    parent_id: str | None = None,\n    inventory_id: str | None = None,\n    barcode_id: str | None = None,\n    parent_id_category: str | None = None,\n    inventory_on_hand: str | None = None,\n    location_id: str | None = None,\n    exact_match: bool = False,\n    begins_with: bool = False,\n) -&gt; Iterator[Lot]\n</code></pre> <p>Lists Lot entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of Lots to return, by default 100.</p> <code>100</code> <code>start_key</code> <code>Optional[str]</code> <p>The primary key of the first item to evaluate for pagination.</p> <code>None</code> <code>parent_id</code> <code>Optional[str]</code> <p>Fetches list of lots for a parentId (inventory).</p> <code>None</code> <code>inventory_id</code> <code>Optional[str]</code> <p>Fetches list of lots for an inventory.</p> <code>None</code> <code>barcode_id</code> <code>Optional[str]</code> <p>Fetches list of lots for a barcodeId.</p> <code>None</code> <code>parent_id_category</code> <code>Optional[str]</code> <p>Fetches list of lots for a parentIdCategory (e.g., RawMaterials, Consumables).</p> <code>None</code> <code>inventory_on_hand</code> <code>Optional[str]</code> <p>Fetches records based on inventoryOnHand (lteZero, gtZero, eqZero).</p> <code>None</code> <code>location_id</code> <code>Optional[str]</code> <p>Fetches list of lots for a locationId.</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Determines if barcodeId field should be an exact match, by default False.</p> <code>False</code> <code>begins_with</code> <code>bool</code> <p>Determines if barcodeId begins with a certain value, by default False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Iterator[Lot]</code> <p>An iterator of Lot objects.</p> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    start_key: str | None = None,\n    parent_id: str | None = None,\n    inventory_id: str | None = None,\n    barcode_id: str | None = None,\n    parent_id_category: str | None = None,\n    inventory_on_hand: str | None = None,\n    location_id: str | None = None,\n    exact_match: bool = False,\n    begins_with: bool = False,\n) -&gt; Iterator[Lot]:\n    \"\"\"\n    Lists Lot entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of Lots to return, by default 100.\n    start_key : Optional[str], optional\n        The primary key of the first item to evaluate for pagination.\n    parent_id : Optional[str], optional\n        Fetches list of lots for a parentId (inventory).\n    inventory_id : Optional[str], optional\n        Fetches list of lots for an inventory.\n    barcode_id : Optional[str], optional\n        Fetches list of lots for a barcodeId.\n    parent_id_category : Optional[str], optional\n        Fetches list of lots for a parentIdCategory (e.g., RawMaterials, Consumables).\n    inventory_on_hand : Optional[str], optional\n        Fetches records based on inventoryOnHand (lteZero, gtZero, eqZero).\n    location_id : Optional[str], optional\n        Fetches list of lots for a locationId.\n    exact_match : bool, optional\n        Determines if barcodeId field should be an exact match, by default False.\n    begins_with : bool, optional\n        Determines if barcodeId begins with a certain value, by default False.\n\n    Yields\n    -------\n    Iterator[Lot]\n        An iterator of Lot objects.\n    \"\"\"\n    params = {\n        \"limit\": limit,\n        \"startKey\": start_key,\n        \"parentId\": parent_id,\n        \"inventoryId\": inventory_id,\n        \"barcodeId\": barcode_id,\n        \"parentIdCategory\": parent_id_category,\n        \"inventoryOnHand\": inventory_on_hand,\n        \"locationId\": location_id,\n        \"exactMatch\": json.dumps(exact_match),\n        \"beginsWith\": json.dumps(begins_with),\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Lot(**item) for item in items],\n    )\n</code></pre>"},{"location":"lots/#albert.collections.lots.LotCollection.update","title":"update","text":"<pre><code>update(*, lot: Lot) -&gt; Lot\n</code></pre> <p>Update a lot.</p> <p>Parameters:</p> Name Type Description Default <code>lot</code> <code>Lot</code> <p>The updated lot object.</p> required <p>Returns:</p> Type Description <code>Lot</code> <p>The updated lot object as returned by the server.</p> Source code in <code>src/albert/collections/lots.py</code> <pre><code>def update(self, *, lot: Lot) -&gt; Lot:\n    \"\"\"Update a lot.\n\n    Parameters\n    ----------\n    lot : Lot\n        The updated lot object.\n\n    Returns\n    -------\n    Lot\n        The updated lot object as returned by the server.\n    \"\"\"\n    existing_lot = self.get_by_id(id=lot.id)\n    patch_data = self._generate_patch_payload(existing=existing_lot, updated=lot)\n    url = f\"{self.base_path}/{lot.id}\"\n\n    self.session.patch(url, json=patch_data.model_dump(mode=\"json\", by_alias=True))\n\n    return self.get_by_id(id=lot.id)\n</code></pre>"},{"location":"notebooks/","title":"Notebooks","text":""},{"location":"notebooks/#albert.collections.notebooks.NotebookBlock","title":"NotebookBlock  <code>module-attribute</code>","text":"<pre><code>NotebookBlock = Annotated[\n    _NotebookBlockUnion, Field(discriminator=\"type\")\n]\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.AlbertException","title":"AlbertException","text":"<pre><code>AlbertException(message: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, message: str):\n    super().__init__(message)\n    self.message = message\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.AlbertException.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotFoundError","title":"NotFoundError","text":"<pre><code>NotFoundError(response: Response)\n</code></pre> <p>               Bases: <code>AlbertClientError</code></p> <p>HTTP Error due to a 404 Not Found response.</p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, response: requests.Response):\n    message = self._format_message(response)\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.Notebook","title":"Notebook","text":"<p>               Bases: <code>BaseResource</code></p>"},{"location":"notebooks/#albert.collections.notebooks.Notebook.blocks","title":"blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocks: list[NotebookBlock] = Field(default_factory=list)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.Notebook.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: NotebookId | None = Field(\n    default=None, alias=\"albertId\"\n)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.Notebook.links","title":"links  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>links: list[NotebookLink] | None = Field(default=None)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.Notebook.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(default='Untitled Notebook')\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.Notebook.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: ProjectId | TaskId = Field(..., alias=\"parentId\")\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.Notebook.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: datetime | None = Field(default=None)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCollection","title":"NotebookCollection","text":"<pre><code>NotebookCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>NotebookCollection is a collection class for managing Notebook entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>copy</code> <p>Create a copy of a Notebook into a specified parent</p> <code>create</code> <p>Create or return notebook for the provided notebook.</p> <code>delete</code> <p>Deletes a notebook by its ID.</p> <code>get_block_by_id</code> <p>Retrieve a Notebook Block by its ID.</p> <code>get_by_id</code> <p>Retrieve a Notebook by its ID.</p> <code>list_by_parent_id</code> <p>Retrieve a Notebook by parent ID.</p> <code>update</code> <p>Update a notebook.</p> <code>update_block_content</code> <p>Updates the block content of a Notebook. This does not update the notebook name (use .update for that).</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the NotebookCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{NotebookCollection._api_version}/notebooks\"\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/notebooks'\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCollection.copy","title":"copy","text":"<pre><code>copy(\n    *,\n    notebook_copy_info: NotebookCopyInfo,\n    type: NotebookCopyType,\n) -&gt; Notebook\n</code></pre> <p>Create a copy of a Notebook into a specified parent</p> <p>Parameters:</p> Name Type Description Default <code>notebook_copy_info</code> <code>NotebookCopyInfo</code> <p>The copy information for the Notebook copy</p> required <code>type</code> <code>NotebookCopyType</code> <p>Differentiate whether copy is for templates, task, project or restoreTemplate</p> required <p>Returns:</p> Type Description <code>Notebook</code> <p>The result of the copied Notebook.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def copy(self, *, notebook_copy_info: NotebookCopyInfo, type: NotebookCopyType) -&gt; Notebook:\n    \"\"\"Create a copy of a Notebook into a specified parent\n\n    Parameters\n    ----------\n    notebook_copy_info : NotebookCopyInfo\n        The copy information for the Notebook copy\n    type : NotebookCopyType\n        Differentiate whether copy is for templates, task, project or restoreTemplate\n\n    Returns\n    -------\n    Notebook\n        The result of the copied Notebook.\n    \"\"\"\n    response = self.session.post(\n        url=f\"{self.base_path}/copy\",\n        json=notebook_copy_info.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n        params={\"type\": type, \"parentId\": notebook_copy_info.parent_id},\n    )\n    return Notebook(**response.json())\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCollection.create","title":"create","text":"<pre><code>create(*, notebook: Notebook) -&gt; Notebook\n</code></pre> <p>Create or return notebook for the provided notebook. This endpoint automatically tries to find an existing notebook with the same parameter setpoints, and will either return the existing notebook or create a new one.</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>Notebook</code> <p>A list of Notebook objects to find or create.</p> required <p>Returns:</p> Type Description <code>Notebook</code> <p>A list of created or found Notebook objects.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def create(self, *, notebook: Notebook) -&gt; Notebook:\n    \"\"\"Create or return notebook for the provided notebook.\n    This endpoint automatically tries to find an existing notebook with the same parameter setpoints, and will either return the existing notebook or create a new one.\n\n    Parameters\n    ----------\n    notebook : Notebook\n        A list of Notebook objects to find or create.\n\n    Returns\n    -------\n    Notebook\n        A list of created or found Notebook objects.\n    \"\"\"\n    if notebook.blocks:\n        # This check keeps a user from corrupting the Notebook data.\n        msg = (\n            \"Cannot create a Notebook with pre-filled blocks. \"\n            \"Set `blocks=[]` (or do not set it) when creating it. \"\n            \"Use `.update_block_content()` afterward to add, update, or delete blocks.\"\n        )\n        raise AlbertException(msg)\n    response = self.session.post(\n        url=self.base_path,\n        json=notebook.model_dump(mode=\"json\", by_alias=True, exclude_none=True),\n        params={\"parentId\": notebook.parent_id},\n    )\n    return Notebook(**response.json())\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a notebook by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the notebook to delete.</p> required Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a notebook by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the notebook to delete.\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCollection.get_block_by_id","title":"get_block_by_id","text":"<pre><code>get_block_by_id(\n    *, notebook_id: str, block_id: str\n) -&gt; NotebookBlock\n</code></pre> <p>Retrieve a Notebook Block by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the Notebook Block to retrieve.</p> required <p>Returns:</p> Type Description <code>NotebookBlock</code> <p>The NotebookBlock object.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def get_block_by_id(self, *, notebook_id: str, block_id: str) -&gt; NotebookBlock:\n    \"\"\"Retrieve a Notebook Block by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the Notebook Block to retrieve.\n\n    Returns\n    -------\n    NotebookBlock\n        The NotebookBlock object.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{notebook_id}/blocks/{block_id}\")\n    return TypeAdapter(NotebookBlock).validate_python(response.json())\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Notebook\n</code></pre> <p>Retrieve a Notebook by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the Notebook to retrieve.</p> required <p>Returns:</p> Type Description <code>Notebook</code> <p>The Notebook object.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Notebook:\n    \"\"\"Retrieve a Notebook by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the Notebook to retrieve.\n\n    Returns\n    -------\n    Notebook\n        The Notebook object.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return Notebook(**response.json())\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCollection.list_by_parent_id","title":"list_by_parent_id","text":"<pre><code>list_by_parent_id(*, parent_id: str) -&gt; list[Notebook]\n</code></pre> <p>Retrieve a Notebook by parent ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the parent ID, e.g. task.</p> required <p>Returns:</p> Type Description <code>list[Notebook]</code> <p>list of notebook references.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def list_by_parent_id(self, *, parent_id: str) -&gt; list[Notebook]:\n    \"\"\"Retrieve a Notebook by parent ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the parent ID, e.g. task.\n\n    Returns\n    -------\n    list[Notebook]\n        list of notebook references.\n\n    \"\"\"\n\n    # search\n    response = self.session.get(f\"{self.base_path}/{parent_id}/search\")\n    # return\n    return [self.get_by_id(id=x[\"id\"]) for x in response.json()[\"Items\"]]\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCollection.update","title":"update","text":"<pre><code>update(*, notebook: Notebook) -&gt; Notebook\n</code></pre> <p>Update a notebook.</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>Notebook</code> <p>The updated notebook object.</p> required <p>Returns:</p> Type Description <code>Notebook</code> <p>The updated notebook object as returned by the server.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def update(self, *, notebook: Notebook) -&gt; Notebook:\n    \"\"\"Update a notebook.\n\n    Parameters\n    ----------\n    notebook : Notebook\n        The updated notebook object.\n\n    Returns\n    -------\n    Notebook\n        The updated notebook object as returned by the server.\n    \"\"\"\n    existing_notebook = self.get_by_id(id=notebook.id)\n    patch_data = self._generate_patch_payload(existing=existing_notebook, updated=notebook)\n    url = f\"{self.base_path}/{notebook.id}\"\n\n    self.session.patch(url, json=patch_data.model_dump(mode=\"json\", by_alias=True))\n\n    return self.get_by_id(id=notebook.id)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCollection.update_block_content","title":"update_block_content","text":"<pre><code>update_block_content(*, notebook: Notebook) -&gt; Notebook\n</code></pre> <p>Updates the block content of a Notebook. This does not update the notebook name (use .update for that). If a block in the Notebook does not already exist on Albert, it will be created. Note: The order of the Blocks in your Notebook matter and will be used in the updated Notebook!</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>Notebook</code> <p>The updated notebook object.</p> required <p>Returns:</p> Type Description <code>Notebook</code> <p>The updated notebook object as returned by the server.</p> Source code in <code>src/albert/collections/notebooks.py</code> <pre><code>def update_block_content(self, *, notebook: Notebook) -&gt; Notebook:\n    \"\"\"\n    Updates the block content of a Notebook. This does not update the notebook name (use .update for that).\n    If a block in the Notebook does not already exist on Albert, it will be created.\n    *Note: The order of the Blocks in your Notebook matter and will be used in the updated Notebook!*\n\n\n    Parameters\n    ----------\n    notebook : Notebook\n        The updated notebook object.\n\n    Returns\n    -------\n    Notebook\n        The updated notebook object as returned by the server.\n    \"\"\"\n    put_data = self._generate_put_block_payload(notebook=notebook)\n    url = f\"{self.base_path}/{notebook.id}/content\"\n\n    self.session.put(url, json=put_data.model_dump(mode=\"json\", by_alias=True))\n\n    return self.get_by_id(id=notebook.id)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyInfo","title":"NotebookCopyInfo","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyInfo.acl","title":"acl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acl: NotebookCopyACL | None = Field(default=None)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyInfo.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: NotebookId\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyInfo.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = Field(default=None)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyInfo.notebook_name","title":"notebook_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>notebook_name: str | None = Field(\n    default=None, alias=\"notebookName\"\n)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyInfo.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: str = Field(alias='parentId')\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyType","title":"NotebookCopyType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyType.GEN_TASK_TEMPLATE","title":"GEN_TASK_TEMPLATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GEN_TASK_TEMPLATE = 'genTaskTemplate'\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyType.PROJECT","title":"PROJECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROJECT = 'Project'\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyType.RESTORE_TEMPLATE","title":"RESTORE_TEMPLATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESTORE_TEMPLATE = 'restoreTemplate'\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyType.TASK","title":"TASK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TASK = 'Task'\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.NotebookCopyType.TEMPLATE","title":"TEMPLATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEMPLATE = 'template'\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.PutBlockDatum","title":"PutBlockDatum","text":"<p>               Bases: <code>BaseAlbertModel</code></p> <p>Methods:</p> Name Description <code>content_matches_type</code> <code>model_dump</code> <p>Shallow model_dump to exclude None values (None only removed from top level).</p>"},{"location":"notebooks/#albert.collections.notebooks.PutBlockDatum.content","title":"content  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content: NotebookContent | None = Field(default=None)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.PutBlockDatum.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.PutBlockDatum.operation","title":"operation  <code>instance-attribute</code>","text":"<pre><code>operation: PutOperation\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.PutBlockDatum.previous_block_id","title":"previous_block_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>previous_block_id: str | None = Field(\n    default=None, alias=\"previousBlockId\"\n)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.PutBlockDatum.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: BlockType | None = Field(\n    default=None, alias=\"blockType\"\n)\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.PutBlockDatum.content_matches_type","title":"content_matches_type","text":"<pre><code>content_matches_type() -&gt; PutBlockDatum\n</code></pre> Source code in <code>src/albert/resources/notebooks.py</code> <pre><code>@model_validator(mode=\"after\")\ndef content_matches_type(self) -&gt; \"PutBlockDatum\":\n    if self.content is None:\n        return self  # skip check if there's no content\n\n    content_type = allowed_notebook_contents.get(self.type)\n    if content_type and not isinstance(self.content, content_type):\n        msg = f\"The content type and block type do not match. [content_type={type(self.content)}, block_type={self.type}]\"\n        raise AlbertException(msg)\n    return self\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.PutBlockDatum.model_dump","title":"model_dump","text":"<pre><code>model_dump(**kwargs) -&gt; dict[str, Any]\n</code></pre> <p>Shallow model_dump to exclude None values (None only removed from top level). This ensures required attrs are not removed.</p> Source code in <code>src/albert/resources/notebooks.py</code> <pre><code>def model_dump(self, **kwargs) -&gt; dict[str, Any]:\n    \"\"\"\n    Shallow model_dump to exclude None values (None only removed from top level).\n    This ensures required attrs are not removed.\n    \"\"\"\n    base = super().model_dump(**kwargs)\n    return {k: v for k, v in base.items() if v is not None}\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.PutBlockPayload","title":"PutBlockPayload","text":"<p>               Bases: <code>BaseAlbertModel</code></p> <p>Methods:</p> Name Description <code>model_dump</code> <p>model_dump to ensure only top-level None attrs are removed on PutBlockDatum.</p>"},{"location":"notebooks/#albert.collections.notebooks.PutBlockPayload.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: list[PutBlockDatum]\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.PutBlockPayload.model_dump","title":"model_dump","text":"<pre><code>model_dump(**kwargs) -&gt; dict[str, Any]\n</code></pre> <p>model_dump to ensure only top-level None attrs are removed on PutBlockDatum.</p> Source code in <code>src/albert/resources/notebooks.py</code> <pre><code>def model_dump(self, **kwargs) -&gt; dict[str, Any]:\n    \"\"\"model_dump to ensure only top-level None attrs are removed on PutBlockDatum.\"\"\"\n    return {\"data\": [item.model_dump(**kwargs) for item in self.data]}\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.PutOperation","title":"PutOperation","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"notebooks/#albert.collections.notebooks.PutOperation.DELETE","title":"DELETE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DELETE = 'delete'\n</code></pre>"},{"location":"notebooks/#albert.collections.notebooks.PutOperation.UPDATE","title":"UPDATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UPDATE = 'update'\n</code></pre>"},{"location":"notes/","title":"Notes","text":""},{"location":"notes/#albert.collections.notes.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"notes/#albert.collections.notes.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"notes/#albert.collections.notes.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"notes/#albert.collections.notes.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"notes/#albert.collections.notes.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"notes/#albert.collections.notes.Note","title":"Note","text":"<p>               Bases: <code>BaseResource</code></p> <p>Represents a Note on the Albert Platform. Users can be mentioned in notes by using f-string and the User.to_note_mention() method. This allows for easy tagging and referencing of users within notes. example: f\"Hello {tagged_user.to_note_mention()}!\"</p>"},{"location":"notes/#albert.collections.notes.Note.attachments","title":"attachments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attachments: list[EntityLink] | None = Field(\n    default=None,\n    exclude=True,\n    frozen=True,\n    alias=\"Attachments\",\n)\n</code></pre>"},{"location":"notes/#albert.collections.notes.Note.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"notes/#albert.collections.notes.Note.note","title":"note  <code>instance-attribute</code>","text":"<pre><code>note: str\n</code></pre>"},{"location":"notes/#albert.collections.notes.Note.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: str = Field(..., alias='parentId')\n</code></pre>"},{"location":"notes/#albert.collections.notes.NotesCollection","title":"NotesCollection","text":"<pre><code>NotesCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>NotesCollection is a collection class for managing Note entities in the Albert platform.</p> <p>Methods:</p> Name Description <code>create</code> <p>Creates a new note.</p> <code>delete</code> <p>Deletes a note by its ID.</p> <code>get_by_id</code> <p>Retrieves a note by its ID.</p> <code>list</code> <p>Lists notes by their parent ID.</p> <code>update</code> <p>Updates a note.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{NotesCollection._api_version}/notes\"\n</code></pre>"},{"location":"notes/#albert.collections.notes.NotesCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/notes'\n</code></pre>"},{"location":"notes/#albert.collections.notes.NotesCollection.create","title":"create","text":"<pre><code>create(*, note: Note) -&gt; Note\n</code></pre> <p>Creates a new note.</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>str</code> <p>The note content.</p> required <p>Returns:</p> Type Description <code>Note</code> <p>The created note.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def create(self, *, note: Note) -&gt; Note:\n    \"\"\"\n    Creates a new note.\n\n    Parameters\n    ----------\n    note : str\n        The note content.\n\n    Returns\n    -------\n    Note\n        The created note.\n    \"\"\"\n    response = self.session.post(\n        self.base_path, json=note.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    )\n    return Note(**response.json())\n</code></pre>"},{"location":"notes/#albert.collections.notes.NotesCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a note by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the note to delete.</p> required Source code in <code>src/albert/collections/notes.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a note by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the note to delete.\n    \"\"\"\n    self.session.delete(f\"{self.base_path}/{id}\")\n</code></pre>"},{"location":"notes/#albert.collections.notes.NotesCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Note\n</code></pre> <p>Retrieves a note by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the note to retrieve.</p> required <p>Returns:</p> Type Description <code>Note</code> <p>The note if found, None otherwise.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Note:\n    \"\"\"\n    Retrieves a note by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the note to retrieve.\n\n    Returns\n    -------\n    Note\n        The note if found, None otherwise.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return Note(**response.json())\n</code></pre>"},{"location":"notes/#albert.collections.notes.NotesCollection.list","title":"list","text":"<pre><code>list(\n    *, parent_id: str, order_by: OrderBy = DESCENDING\n) -&gt; list[Note]\n</code></pre> <p>Lists notes by their parent ID.</p> <p>Parameters:</p> Name Type Description Default <code>parent_id</code> <code>str</code> <p>The parent ID of the notes to list.</p> required <code>order_by</code> <code>OrderBy</code> <p>The order to list notes in, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <p>Returns:</p> Type Description <code>List[Note]</code> <p>The list of notes.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def list(self, *, parent_id: str, order_by: OrderBy = OrderBy.DESCENDING) -&gt; list[Note]:\n    \"\"\"\n    Lists notes by their parent ID.\n\n    Parameters\n    ----------\n    parent_id : str\n        The parent ID of the notes to list.\n    order_by : OrderBy, optional\n        The order to list notes in, by default OrderBy.DESCENDING.\n\n    Returns\n    -------\n    List[Note]\n        The list of notes.\n    \"\"\"\n\n    params = {\"parentId\": parent_id, \"orderBy\": order_by.value}\n    return AlbertPaginator(\n        session=self.session,\n        path=self.base_path,\n        mode=PaginationMode.KEY,\n        params=params,\n        deserialize=lambda items: [Note(**item) for item in items],\n    )\n</code></pre>"},{"location":"notes/#albert.collections.notes.NotesCollection.update","title":"update","text":"<pre><code>update(*, note: Note) -&gt; Note\n</code></pre> <p>Updates a note.</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>Note</code> <p>The note to update. The note must have an ID.</p> required <p>Returns:</p> Type Description <code>Note</code> <p>The updated note as returned by the server.</p> Source code in <code>src/albert/collections/notes.py</code> <pre><code>def update(self, *, note: Note) -&gt; Note:\n    \"\"\"Updates a note.\n\n    Parameters\n    ----------\n    note : Note\n        The note to update. The note must have an ID.\n\n    Returns\n    -------\n    Note\n        The updated note as returned by the server.\n    \"\"\"\n    patch = self._generate_patch_payload(\n        existing=self.get_by_id(id=note.id), updated=note, generate_metadata_diff=False\n    )\n    self.session.patch(\n        f\"{self.base_path}/{note.id}\",\n        json=patch.model_dump(mode=\"json\", by_alias=True, exclude_unset=True),\n    )\n    return self.get_by_id(id=note.id)\n</code></pre>"},{"location":"notes/#albert.collections.notes.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"notes/#albert.collections.notes.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"notes/#albert.collections.notes.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"parameter_groups/","title":"Parameter Groups","text":""},{"location":"parameter_groups/#albert.collections.parameter_groups.AlbertHTTPError","title":"AlbertHTTPError","text":"<pre><code>AlbertHTTPError(response: Response)\n</code></pre> <p>               Bases: <code>AlbertException</code></p> <p>Base class for all erors due to HTTP responses.</p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, response: requests.Response):\n    message = self._format_message(response)\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.AlbertHTTPError.response","title":"response  <code>instance-attribute</code>","text":"<pre><code>response = response\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.EnumValidationValue","title":"EnumValidationValue","text":"<p>               Bases: <code>BaseAlbertModel</code></p> <p>Represents a value for an enum type validation.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>The text of the enum value.</p> <code>id</code> <code>str | None</code> <p>The ID of the enum value. If not provided, the ID will be generated upon creation.</p>"},{"location":"parameter_groups/#albert.collections.parameter_groups.EnumValidationValue.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.EnumValidationValue.original_text","title":"original_text  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>original_text: str | None = Field(\n    default=None,\n    exclude=True,\n    frozen=True,\n    alias=\"originalText\",\n)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.EnumValidationValue.text","title":"text  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>text: str = Field()\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"parameter_groups/#albert.collections.parameter_groups.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.PGPatchDatum","title":"PGPatchDatum","text":"<p>               Bases: <code>PatchDatum</code></p>"},{"location":"parameter_groups/#albert.collections.parameter_groups.PGPatchDatum.rowId","title":"rowId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rowId: str | None = Field(default=None)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.PGPatchPayload","title":"PGPatchPayload","text":"<p>               Bases: <code>PatchPayload</code></p> <p>A payload for a PATCH request to update a parameter group.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>list[PGPatchDatum]</code> <p>The data to be updated in the parameter group.</p>"},{"location":"parameter_groups/#albert.collections.parameter_groups.PGPatchPayload.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: list[PGPatchDatum | PatchDatum] = Field(\n    default_factory=list\n)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.PGType","title":"PGType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of a parameter group</p>"},{"location":"parameter_groups/#albert.collections.parameter_groups.PGType.BATCH","title":"BATCH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATCH = 'batch'\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.PGType.GENERAL","title":"GENERAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERAL = 'general'\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.PGType.PROPERTY","title":"PROPERTY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPERTY = 'property'\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroup","title":"ParameterGroup","text":"<p>               Bases: <code>BaseTaggedEntity</code></p> <p>Use 'Standards' key in metadata to store standards</p>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroup.acl","title":"acl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acl: list[SerializeAsEntityLink[User]] | None = Field(\n    default=None, alias=\"ACL\"\n)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroup.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = Field(default=None)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroup.documents","title":"documents  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>documents: list[EntityLink] = Field(\n    default_factory=list, exclude=True, frozen=True\n)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroup.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(None, alias='albertId')\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroup.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] = Field(\n    alias=\"Metadata\", default_factory=dict\n)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroup.parameters","title":"parameters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parameters: list[ParameterValue] = Field(\n    default_factory=list, alias=\"Parameters\"\n)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroup.security_class","title":"security_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>security_class: SecurityClass = Field(\n    default=RESTRICTED, alias=\"class\"\n)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroup.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: PGType | None = Field(default=None)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroup.verified","title":"verified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verified: bool = Field(\n    default=False, exclude=True, frozen=True\n)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroupCollection","title":"ParameterGroupCollection","text":"<pre><code>ParameterGroupCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ParameterGroupCollection is a collection class for managing ParameterGroup entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session to use for making requests.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new parameter group.</p> <code>delete</code> <p>Delete a parameter group by its ID.</p> <code>get_by_id</code> <p>Get a parameter group by its ID.</p> <code>get_by_ids</code> <code>get_by_name</code> <p>Get a parameter group by its name.</p> <code>list</code> <p>Search for Parameter Groups matching the given criteria.</p> <code>update</code> <p>Update a parameter group.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"A collection for interacting with Albert parameter groups.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session to use for making requests.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ParameterGroupCollection._api_version}/parametergroups\"\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroupCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/parametergroups'\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroupCollection.create","title":"create","text":"<pre><code>create(\n    *, parameter_group: ParameterGroup\n) -&gt; ParameterGroup\n</code></pre> <p>Create a new parameter group.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_group</code> <code>ParameterGroup</code> <p>The parameter group to create.</p> required <p>Returns:</p> Type Description <code>ParameterGroup</code> <p>The created parameter group.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def create(self, *, parameter_group: ParameterGroup) -&gt; ParameterGroup:\n    \"\"\"Create a new parameter group.\n\n    Parameters\n    ----------\n    parameter_group : ParameterGroup\n        The parameter group to create.\n\n    Returns\n    -------\n    ParameterGroup\n        The created parameter group.\n    \"\"\"\n\n    response = self.session.post(\n        self.base_path,\n        json=parameter_group.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return ParameterGroup(**response.json())\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroupCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a parameter group by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the parameter group to delete</p> required Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a parameter group by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the parameter group to delete\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    self.session.delete(path)\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroupCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; ParameterGroup\n</code></pre> <p>Get a parameter group by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the parameter group to retrieve.</p> required <p>Returns:</p> Type Description <code>ParameterGroup</code> <p>The parameter group with the given ID.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; ParameterGroup:\n    \"\"\"Get a parameter group by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the parameter group to retrieve.\n\n    Returns\n    -------\n    ParameterGroup\n        The parameter group with the given ID.\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    response = self.session.get(path)\n    return ParameterGroup(**response.json())\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroupCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(*, ids: list[str]) -&gt; ParameterGroup\n</code></pre> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def get_by_ids(self, *, ids: list[str]) -&gt; ParameterGroup:\n    url = f\"{self.base_path}/ids\"\n    batches = [ids[i : i + 100] for i in range(0, len(ids), 100)]\n    return [\n        ParameterGroup(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()[\"Items\"]\n    ]\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroupCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(*, name: str) -&gt; ParameterGroup | None\n</code></pre> <p>Get a parameter group by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter group to retrieve.</p> required <p>Returns:</p> Type Description <code>ParameterGroup | None</code> <p>The parameter group with the given name, or None if not found.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def get_by_name(self, *, name: str) -&gt; ParameterGroup | None:\n    \"\"\"Get a parameter group by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the parameter group to retrieve.\n\n    Returns\n    -------\n    ParameterGroup | None\n        The parameter group with the given name, or None if not found.\n    \"\"\"\n    matches = self.list(text=name)\n    for m in matches:\n        if m.name.lower() == name.lower():\n            return m\n    return None\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroupCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    text: str | None = None,\n    types: PGType | list[PGType] | None = None,\n    order_by: OrderBy = DESCENDING,\n    limit: int = 25,\n    offset: int | None = None,\n) -&gt; Iterator[ParameterGroup]\n</code></pre> <p>Search for Parameter Groups matching the given criteria.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Text to search for, by default None</p> <code>None</code> <code>types</code> <code>PGType | list[PGType] | None</code> <p>Filer the returned Parameter Groups by Type, by default None</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order in which to return results, by default OrderBy.DESCENDING</p> <code>DESCENDING</code> <p>Yields:</p> Type Description <code>Iterator[ParameterGroup]</code> <p>An iterator of Parameter Groups matching the given criteria.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def list(\n    self,\n    *,\n    text: str | None = None,\n    types: PGType | list[PGType] | None = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    limit: int = 25,\n    offset: int | None = None,\n) -&gt; Iterator[ParameterGroup]:\n    \"\"\"Search for Parameter Groups matching the given criteria.\n\n    Parameters\n    ----------\n    text : str | None, optional\n        Text to search for, by default None\n    types : PGType | list[PGType] | None, optional\n        Filer the returned Parameter Groups by Type, by default None\n    order_by : OrderBy, optional\n        The order in which to return results, by default OrderBy.DESCENDING\n\n    Yields\n    ------\n    Iterator[ParameterGroup]\n        An iterator of Parameter Groups matching the given criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[ParameterGroup]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:  # pragma: no cover\n                logger.warning(f\"Error fetching parameter group {id}: {e}\")\n        # Currently, the API is not returning metadata for the list_by_ids endpoint, so we need to fetch individually until that is fixed\n        # return self.get_by_ids(ids=[x[\"albertId\"] for x in items])\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"order\": order_by.value,\n        \"text\": text,\n        \"types\": [types] if isinstance(types, PGType) else types,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"parameter_groups/#albert.collections.parameter_groups.ParameterGroupCollection.update","title":"update","text":"<pre><code>update(\n    *, parameter_group: ParameterGroup\n) -&gt; ParameterGroup\n</code></pre> <p>Update a parameter group.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_group</code> <code>ParameterGroup</code> <p>The updated ParameterGroup. The ParameterGroup must have an ID.</p> required <p>Returns:</p> Type Description <code>ParameterGroup</code> <p>The updated ParameterGroup as returned by the server.</p> Source code in <code>src/albert/collections/parameter_groups.py</code> <pre><code>def update(self, *, parameter_group: ParameterGroup) -&gt; ParameterGroup:\n    \"\"\"Update a parameter group.\n\n    Parameters\n    ----------\n    parameter_group : ParameterGroup\n        The updated ParameterGroup. The ParameterGroup must have an ID.\n\n    Returns\n    -------\n    ParameterGroup\n        The updated ParameterGroup as returned by the server.\n    \"\"\"\n\n    existing = self.get_by_id(id=parameter_group.id)\n    path = f\"{self.base_path}/{existing.id}\"\n\n    payload = self._generate_patch_payload(existing=existing, updated=parameter_group)\n    # need to use a different payload for the special update parameters\n    payload = PGPatchPayload(\n        data=payload.data,\n    )\n\n    # Handle special update parameters\n    special_patches, special_enum_patches, new_param_patches = (\n        self._handle_special_update_parameters(existing=existing, updated=parameter_group)\n    )\n\n    payload.data.extend(special_patches)\n    if len(payload.data) &gt; 0:\n        self.session.patch(\n            path, json=payload.model_dump(mode=\"json\", by_alias=True, exclude_none=True)\n        )\n\n    # handle adding new parameters\n    if len(new_param_patches) &gt; 0:\n        self.session.put(\n            f\"{self.base_path}/{existing.id}/parameters\",\n            json={\"Parameters\": new_param_patches},\n        )\n    # Handle special enum update parameters\n    for sequence, enum_patches in special_enum_patches.items():\n        if len(enum_patches) == 0:\n            continue\n        enum_path = f\"{self.base_path}/{existing.id}/parameters/{sequence}/enums\"\n        self.session.put(enum_path, json=enum_patches)\n    return self.get_by_id(id=parameter_group.id)\n</code></pre>"},{"location":"parameters/","title":"Parameters","text":""},{"location":"parameters/#albert.collections.parameters.AlbertHTTPError","title":"AlbertHTTPError","text":"<pre><code>AlbertHTTPError(response: Response)\n</code></pre> <p>               Bases: <code>AlbertException</code></p> <p>Base class for all erors due to HTTP responses.</p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, response: requests.Response):\n    message = self._format_message(response)\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.AlbertHTTPError.response","title":"response  <code>instance-attribute</code>","text":"<pre><code>response = response\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"parameters/#albert.collections.parameters.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.Parameter","title":"Parameter","text":"<p>               Bases: <code>BaseResource</code></p> <p>A parameter in Albert.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the parameter. Names must be unique.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the parameter. Set when the parameter is retrieved from Albert.</p> <code>category</code> <code>ParameterCategory</code> <p>The category of the parameter. Allowed values are <code>Normal</code> and <code>Special</code>. Read-only.</p> <code>rank</code> <code>int</code> <p>The rank of the returned parameter. Read-only.</p>"},{"location":"parameters/#albert.collections.parameters.Parameter.category","title":"category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category: ParameterCategory | None = Field(\n    default=None, exclude=True, frozen=True\n)\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.Parameter.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(alias='albertId', default=None)\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.Parameter.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] | None = Field(\n    alias=\"Metadata\", default=None\n)\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.Parameter.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.Parameter.rank","title":"rank  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rank: int | None = Field(\n    default=None, exclude=True, frozen=True\n)\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.ParameterCollection","title":"ParameterCollection","text":"<pre><code>ParameterCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ParameterCollection is a collection class for managing Parameter entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new parameter.</p> <code>delete</code> <p>Delete a parameter by its ID.</p> <code>get_by_id</code> <p>Retrieve a parameter by its ID.</p> <code>list</code> <p>Lists parameters that match the provided criteria.</p> <code>update</code> <p>Update a parameter.</p> Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initializes the ParameterCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ParameterCollection._api_version}/parameters\"\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.ParameterCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/parameters'\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.ParameterCollection.create","title":"create","text":"<pre><code>create(*, parameter: Parameter) -&gt; Parameter\n</code></pre> <p>Create a new parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>Parameter</code> <p>The parameter to create.</p> required <p>Returns:</p> Type Description <code>Parameter</code> <p>Returns the created parameter or the existing parameter if it already exists.</p> Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def create(self, *, parameter: Parameter) -&gt; Parameter:\n    \"\"\"Create a new parameter.\n\n    Parameters\n    ----------\n    parameter : Parameter\n        The parameter to create.\n\n    Returns\n    -------\n    Parameter\n        Returns the created parameter or the existing parameter if it already exists.\n    \"\"\"\n    match = next(self.list(names=parameter.name, exact_match=True), None)\n    if match is not None:\n        logging.warning(\n            f\"Parameter with name {parameter.name} already exists. Returning existing parameter.\"\n        )\n        return match\n    response = self.session.post(\n        self.base_path,\n        json=parameter.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return Parameter(**response.json())\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.ParameterCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a parameter by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the parameter to delete.</p> required Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a parameter by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the parameter to delete.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.ParameterCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Parameter\n</code></pre> <p>Retrieve a parameter by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the parameter to retrieve.</p> required <p>Returns:</p> Type Description <code>Parameter</code> <p>The parameter with the given ID.</p> Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Parameter:\n    \"\"\"Retrieve a parameter by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the parameter to retrieve.\n\n    Returns\n    -------\n    Parameter\n        The parameter with the given ID.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return Parameter(**response.json())\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.ParameterCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    ids: list[str] | None = None,\n    names: str | list[str] = None,\n    exact_match: bool = False,\n    order_by: OrderBy = DESCENDING,\n    start_key: str | None = None,\n    limit: int = 50,\n) -&gt; Iterator[Parameter]\n</code></pre> <p>Lists parameters that match the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str] | None</code> <p>A list of parameter IDs to retrieve, by default None</p> <code>None</code> <code>names</code> <code>str | list[str]</code> <p>A list of parameter names to retrieve, by default None</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default False</p> <code>False</code> <code>order_by</code> <code>OrderBy</code> <p>The order in which to return results, by default OrderBy.DESCENDING</p> <code>DESCENDING</code> <p>Yields:</p> Type Description <code>Iterator[Parameter]</code> <p>An iterator of Parameters matching the given criteria.</p> Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def list(\n    self,\n    *,\n    ids: list[str] | None = None,\n    names: str | list[str] = None,\n    exact_match: bool = False,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    start_key: str | None = None,\n    limit: int = 50,\n) -&gt; Iterator[Parameter]:\n    \"\"\"Lists parameters that match the provided criteria.\n\n    Parameters\n    ----------\n    ids : list[str] | None, optional\n        A list of parameter IDs to retrieve, by default None\n    names : str | list[str], optional\n        A list of parameter names to retrieve, by default None\n    exact_match : bool, optional\n        Whether to match the name exactly, by default False\n    order_by : OrderBy, optional\n        The order in which to return results, by default OrderBy.DESCENDING\n\n    Yields\n    ------\n    Iterator[Parameter]\n        An iterator of Parameters matching the given criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[Parameter]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching Parameter '{id}': {e}\")\n\n    params = {\"limit\": limit, \"orderBy\": order_by, \"parameters\": ids, \"startKey\": start_key}\n    if names:\n        params[\"name\"] = [names] if isinstance(names, str) else names\n        params[\"exactMatch\"] = json.dumps(exact_match)\n\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"parameters/#albert.collections.parameters.ParameterCollection.update","title":"update","text":"<pre><code>update(*, parameter: Parameter) -&gt; Parameter\n</code></pre> <p>Update a parameter.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>Parameter</code> <p>The updated parameter to save. The parameter must have an ID.</p> required <p>Returns:</p> Type Description <code>Parameter</code> <p>The updated parameter as returned by the server.</p> Source code in <code>src/albert/collections/parameters.py</code> <pre><code>def update(self, *, parameter: Parameter) -&gt; Parameter:\n    \"\"\"Update a parameter.\n\n    Parameters\n    ----------\n    parameter : Parameter\n        The updated parameter to save. The parameter must have an ID.\n\n    Returns\n    -------\n    Parameter\n        The updated parameter as returned by the server.\n    \"\"\"\n    existing = self.get_by_id(id=parameter.id)\n    payload = self._generate_patch_payload(\n        existing=existing,\n        updated=parameter,\n    )\n    payload_dump = payload.model_dump(mode=\"json\", by_alias=True)\n    for i, change in enumerate(payload_dump[\"data\"]):\n        if not self._is_metadata_item_list(\n            existing_object=existing,\n            updated_object=parameter,\n            metadata_field=change[\"attribute\"],\n        ):\n            change[\"operation\"] = \"update\"\n            if \"newValue\" in change and change[\"newValue\"] is None:\n                del change[\"newValue\"]\n            if \"oldValue\" in change and change[\"oldValue\"] is None:\n                del change[\"oldValue\"]\n            payload_dump[\"data\"][i] = change\n    if len(payload_dump[\"data\"]) == 0:\n        return parameter\n    for e in payload_dump[\"data\"]:\n        self.session.patch(\n            f\"{self.base_path}/{parameter.id}\",\n            json={\"data\": [e]},\n        )\n    return self.get_by_id(id=parameter.id)\n</code></pre>"},{"location":"pricings/","title":"Pricings","text":""},{"location":"pricings/#albert.collections.pricings.InventoryId","title":"InventoryId  <code>module-attribute</code>","text":"<pre><code>InventoryId = Annotated[\n    str, AfterValidator(ensure_inventory_id)\n]\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.InventoryPricings","title":"InventoryPricings","text":"<p>               Bases: <code>BaseAlbertModel</code></p> <p>Pricings for a given InventoryItem.</p> <p>Attributes:</p> Name Type Description <code>inventory_id</code> <code>Inventory</code> <p>The inventory ID the pricings belong to.</p> <code>pricings</code> <code>list[Pricing]</code> <p>The list of pricings.</p>"},{"location":"pricings/#albert.collections.pricings.InventoryPricings.inventory_id","title":"inventory_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_id: InventoryId = Field(..., alias='id')\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.InventoryPricings.pricings","title":"pricings  <code>instance-attribute</code>","text":"<pre><code>pricings: list[Pricing]\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"pricings/#albert.collections.pricings.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing","title":"Pricing","text":"<p>               Bases: <code>BaseResource</code></p> <p>A Price of a given InventoryItem at a given Location.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str | None</code> <p>The Albert ID of the pricing. Set when the pricing is retrieved from Albert.</p> <code>inventory_id</code> <code>str</code> <p>The Albert ID of the inventory item.</p> <code>company</code> <code>Company</code> <p>The company that the pricing belongs to.</p> <code>location</code> <code>Location</code> <p>The location that the pricing belongs to.</p> <code>description</code> <code>str | None</code> <p>The description of the pricing. Optional.</p> <code>pack_size</code> <code>str | None</code> <p>The pack size of the pricing. Optional. Used to calculate the cost per unit.</p> <code>price</code> <code>float</code> <p>The price of the pricing IN CURRENCY/ KG or CURRENCY/L! Must do the conversion! Depends on InventoryItem's unit of measure.</p> <code>currency</code> <code>str</code> <p>The currency of the pricing. Defaults to <code>USD</code>.</p> <code>fob</code> <code>str | None</code> <p>The FOB of the pricing. Optional.</p> <code>lead_time</code> <code>int | None</code> <p>The lead time of the pricing. Optional.</p> <code>lead_time_unit</code> <code>LeadTimeUnit | None</code> <p>The unit of measure for the provided lead time. Optional.</p> <code>expiration_date</code> <code>str | None</code> <p>The expiration date of the pricing. YYYY-MM-DD format.</p>"},{"location":"pricings/#albert.collections.pricings.Pricing.company","title":"company  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>company: SerializeAsEntityLink[Company] = Field(\n    alias=\"Company\"\n)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.currency","title":"currency  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>currency: str = Field(default='USD', alias='currency')\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.default","title":"default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default: int | None = Field(\n    default=None, exclude=True, frozen=True\n)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = Field(default=None)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.expiration_date","title":"expiration_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>expiration_date: str | None = Field(\n    default=None, alias=\"expirationDate\"\n)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.fob","title":"fob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fob: str | None = Field(default=None)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None, alias='albertId')\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.inventory_id","title":"inventory_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_id: str | None = Field(\n    default=None, alias=\"parentId\"\n)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.lead_time","title":"lead_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lead_time: int | None = Field(\n    default=None, alias=\"leadTime\"\n)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.lead_time_unit","title":"lead_time_unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lead_time_unit: LeadTimeUnit | None = Field(\n    default=None, alias=\"leadTimeUnit\"\n)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: SerializeAsEntityLink[Location] = Field(\n    alias=\"Location\"\n)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.pack_size","title":"pack_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pack_size: str | None = Field(\n    default=None, alias=\"packSize\"\n)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.Pricing.price","title":"price  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>price: float = Field(ge=0, le=9999999999)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.PricingBy","title":"PricingBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"pricings/#albert.collections.pricings.PricingBy.COMPANY","title":"COMPANY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COMPANY = 'Company'\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.PricingBy.LOCATION","title":"LOCATION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LOCATION = 'Location'\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.PricingCollection","title":"PricingCollection","text":"<pre><code>PricingCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>PricingCollection is a collection class for managing Pricing entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Creates a new Pricing entity.</p> <code>delete</code> <p>Deletes a Pricing entity by its ID.</p> <code>get_by_id</code> <p>Retrieves a Pricing entity by its ID.</p> <code>get_by_inventory_id</code> <p>Returns a list of Pricing entities for the given inventory ID as per the provided parameters.</p> <code>get_by_inventory_ids</code> <p>Returns a list of Pricing resources for each parent inventory ID.</p> <code>update</code> <p>Updates a Pricing entity.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initializes the PricingCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{PricingCollection._api_version}/pricings\"\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.PricingCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/pricings'\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.PricingCollection.create","title":"create","text":"<pre><code>create(*, pricing: Pricing) -&gt; Pricing\n</code></pre> <p>Creates a new Pricing entity.</p> <p>Parameters:</p> Name Type Description Default <code>pricing</code> <code>Pricing</code> <p>The Pricing entity to create.</p> required <p>Returns:</p> Type Description <code>Pricing</code> <p>The created Pricing entity.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def create(self, *, pricing: Pricing) -&gt; Pricing:\n    \"\"\"Creates a new Pricing entity.\n\n    Parameters\n    ----------\n    pricing : Pricing\n        The Pricing entity to create.\n\n    Returns\n    -------\n    Pricing\n        The created Pricing entity.\n    \"\"\"\n    payload = pricing.model_dump(by_alias=True, exclude_none=True, mode=\"json\")\n    response = self.session.post(self.base_path, json=payload)\n    return Pricing(**response.json())\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.PricingCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a Pricing entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the Pricing entity to delete.</p> required Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Deletes a Pricing entity by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the Pricing entity to delete.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.PricingCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Pricing\n</code></pre> <p>Retrieves a Pricing entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the Pricing entity to retrieve.</p> required <p>Returns:</p> Type Description <code>Pricing</code> <p>The Pricing entity if found, None otherwise.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Pricing:\n    \"\"\"Retrieves a Pricing entity by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the Pricing entity to retrieve.\n\n    Returns\n    -------\n    Pricing\n        The Pricing entity if found, None otherwise.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return Pricing(**response.json())\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.PricingCollection.get_by_inventory_id","title":"get_by_inventory_id","text":"<pre><code>get_by_inventory_id(\n    *,\n    inventory_id: str,\n    group_by: PricingBy | None = None,\n    filter_by: PricingBy | None = None,\n    filter_id: str | None = None,\n    order_by: OrderBy | None = None,\n) -&gt; list[Pricing]\n</code></pre> <p>Returns a list of Pricing entities for the given inventory ID as per the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>str</code> <p>The ID of the inventory to retrieve pricings for.</p> required <code>group_by</code> <code>PricingBy | None</code> <p>Grouping by PricingBy, by default None</p> <code>None</code> <code>filter_by</code> <code>PricingBy | None</code> <p>Filter by PricingBy, by default None</p> <code>None</code> <code>filter_id</code> <code>str | None</code> <p>The string to use as the filter, by default None</p> <code>None</code> <code>order_by</code> <code>OrderBy | None</code> <p>The order to sort the results by, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Pricing]</code> <p>A list of Pricing entities matching the provided parameters.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def get_by_inventory_id(\n    self,\n    *,\n    inventory_id: str,\n    group_by: PricingBy | None = None,\n    filter_by: PricingBy | None = None,\n    filter_id: str | None = None,\n    order_by: OrderBy | None = None,\n) -&gt; list[Pricing]:\n    \"\"\"Returns a list of Pricing entities for the given inventory ID as per the provided parameters.\n\n    Parameters\n    ----------\n    inventory_id : str\n        The ID of the inventory to retrieve pricings for.\n    group_by : PricingBy | None, optional\n        Grouping by PricingBy, by default None\n    filter_by : PricingBy | None, optional\n        Filter by PricingBy, by default None\n    filter_id : str | None, optional\n        The string to use as the filter, by default None\n    order_by : OrderBy | None, optional\n        The order to sort the results by, by default None\n\n    Returns\n    -------\n    list[Pricing]\n        A list of Pricing entities matching the provided parameters.\n    \"\"\"\n    params = {\n        \"parentId\": inventory_id,\n        \"groupBy\": group_by,\n        \"filterBy\": filter_by,\n        \"id\": filter_id,\n        \"orderBy\": order_by,\n    }\n    params = {k: v for k, v in params.items() if v is not None}\n    response = self.session.get(self.base_path, params=params)\n    items = response.json().get(\"Items\", [])\n    return [Pricing(**x) for x in items]\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.PricingCollection.get_by_inventory_ids","title":"get_by_inventory_ids","text":"<pre><code>get_by_inventory_ids(\n    *, inventory_ids: list[InventoryId]\n) -&gt; list[InventoryPricings]\n</code></pre> <p>Returns a list of Pricing resources for each parent inventory ID.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_ids</code> <code>list[str]</code> <p>The list of inventory IDs to retrieve pricings for.</p> required <p>Returns:</p> Type Description <code>list[InventoryPricing]</code> <p>A list of InventoryPricing objects matching the provided inventory.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>@validate_call\ndef get_by_inventory_ids(self, *, inventory_ids: list[InventoryId]) -&gt; list[InventoryPricings]:\n    \"\"\"Returns a list of Pricing resources for each parent inventory ID.\n\n    Parameters\n    ----------\n    inventory_ids : list[str]\n        The list of inventory IDs to retrieve pricings for.\n\n    Returns\n    -------\n    list[InventoryPricing]\n        A list of InventoryPricing objects matching the provided inventory.\n    \"\"\"\n    params = {\"id\": inventory_ids}\n    response = self.session.get(f\"{self.base_path}/ids\", params=params)\n    return [InventoryPricings(**x) for x in response.json()[\"Items\"]]\n</code></pre>"},{"location":"pricings/#albert.collections.pricings.PricingCollection.update","title":"update","text":"<pre><code>update(*, pricing: Pricing) -&gt; Pricing\n</code></pre> <p>Updates a Pricing entity.</p> <p>Parameters:</p> Name Type Description Default <code>pricing</code> <code>Pricing</code> <p>The updated Pricing entity.</p> required <p>Returns:</p> Type Description <code>Pricing</code> <p>The updated Pricing entity as it appears in Albert.</p> Source code in <code>src/albert/collections/pricings.py</code> <pre><code>def update(self, *, pricing: Pricing) -&gt; Pricing:\n    \"\"\"Updates a Pricing entity.\n\n    Parameters\n    ----------\n    pricing : Pricing\n        The updated Pricing entity.\n\n    Returns\n    -------\n    Pricing\n        The updated Pricing entity as it appears in Albert.\n    \"\"\"\n    current_pricing = self.get_by_id(id=pricing.id)\n    patch_payload = self._pricing_patch_payload(existing=current_pricing, updated=pricing)\n    self.session.patch(\n        url=f\"{self.base_path}/{pricing.id}\",\n        json=patch_payload.model_dump(mode=\"json\", by_alias=True),\n    )\n    return self.get_by_id(id=pricing.id)\n</code></pre>"},{"location":"product_design/","title":"Product Design","text":""},{"location":"product_design/#albert.collections.product_design.InventoryId","title":"InventoryId  <code>module-attribute</code>","text":"<pre><code>InventoryId = Annotated[\n    str, AfterValidator(ensure_inventory_id)\n]\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.ProductDesignCollection","title":"ProductDesignCollection","text":"<pre><code>ProductDesignCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ProductDesignCollection is a collection class for managing Product Design entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>get_unpacked_products</code> <p>Get unpacked products by inventory IDs.</p> Source code in <code>src/albert/collections/product_design.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CasCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ProductDesignCollection._api_version}/productdesign\"\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.ProductDesignCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/productdesign'\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.ProductDesignCollection.get_unpacked_products","title":"get_unpacked_products","text":"<pre><code>get_unpacked_products(\n    *,\n    inventory_ids: list[InventoryId],\n    unpack_id: Literal[\n        \"DESIGN\", \"PREDICTION\"\n    ] = \"PREDICTION\",\n) -&gt; list[UnpackedProductDesign]\n</code></pre> <p>Get unpacked products by inventory IDs.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_ids</code> <code>list[InventoryId]</code> <p>The inventory ids to get unpacked formulas for.</p> required <code>unpack_id</code> <code>Literal['DESIGN', 'PREDICTION']</code> <p>The ID for the unpack operation.</p> <code>'PREDICTION'</code> <p>Returns:</p> Type Description <code>list[UnpackedProductDesign]</code> <p>The unpacked products/formulas.</p> Source code in <code>src/albert/collections/product_design.py</code> <pre><code>@validate_call\ndef get_unpacked_products(\n    self,\n    *,\n    inventory_ids: list[InventoryId],\n    unpack_id: Literal[\"DESIGN\", \"PREDICTION\"] = \"PREDICTION\",\n) -&gt; list[UnpackedProductDesign]:\n    \"\"\"\n    Get unpacked products by inventory IDs.\n\n    Parameters\n    ----------\n    inventory_ids : list[InventoryId]\n        The inventory ids to get unpacked formulas for.\n    unpack_id: Literal[\"DESIGN\", \"PREDICTION\"]\n        The ID for the unpack operation.\n\n    Returns\n    -------\n    list[UnpackedProductDesign]\n        The unpacked products/formulas.\n    \"\"\"\n    url = f\"{self.base_path}/{unpack_id}/unpack\"\n    batches = [inventory_ids[i : i + 50] for i in range(0, len(inventory_ids), 50)]\n    return [\n        UnpackedProductDesign(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"formulaId\": batch}).json()\n    ]\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.UnpackedProductDesign","title":"UnpackedProductDesign","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"product_design/#albert.collections.product_design.UnpackedProductDesign.cas_level_substances","title":"cas_level_substances  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cas_level_substances: list[CasLevelSubstance] | None = (\n    Field(default=None, alias=\"casLevelSubstances\")\n)\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.UnpackedProductDesign.inventories","title":"inventories  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventories: list[UnpackedInventory] | None = Field(\n    default=None, alias=\"Inventories\"\n)\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.UnpackedProductDesign.inventory_list","title":"inventory_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_list: list[UnpackedInventoryListItem] | None = (\n    Field(default=None, alias=\"inventoryList\")\n)\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.UnpackedProductDesign.inventory_sds_list","title":"inventory_sds_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_sds_list: list[UnpackedInventorySDS] | None = (\n    Field(default=None, alias=\"inventorySDSList\")\n)\n</code></pre>"},{"location":"product_design/#albert.collections.product_design.UnpackedProductDesign.normalized_cas_list","title":"normalized_cas_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>normalized_cas_list: list[NormalizedCAS] | None = Field(\n    default=None, alias=\"normalizedCasList\"\n)\n</code></pre>"},{"location":"projects/","title":"Projects","text":""},{"location":"projects/#albert.collections.projects.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"projects/#albert.collections.projects.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"projects/#albert.collections.projects.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"projects/#albert.collections.projects.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"projects/#albert.collections.projects.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"projects/#albert.collections.projects.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"projects/#albert.collections.projects.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"projects/#albert.collections.projects.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project","title":"Project","text":"<p>               Bases: <code>BaseResource</code></p> <p>A project in Albert.</p> <p>Attributes:</p> Name Type Description <code>description</code> <code>str</code> <p>The description of the project. Used as the name of the project as well.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the project. Set when the project is retrieved from Albert.</p> <code>locations</code> <code>list[Location] | None</code> <p>The locations associated with the project. Optional.</p> <code>project_class</code> <code>ProjectClass</code> <p>The class of the project. Defaults to PRIVATE.</p> <code>metadata</code> <code>dict[str, str | list[EntityLink] | EntityLink] | None</code> <p>The metadata of the project. Optional. Metadata allowed values can be found using the Custom Fields API.</p> <code>prefix</code> <code>str | None</code> <p>The prefix of the project. Optional.</p> <code>acl</code> <code>list[ACL] | None</code> <p>The ACL of the project. Optional.</p> <code>task_config</code> <code>list[TaskConfig] | None</code> <p>The task configuration of the project. Optional.</p> <code>grid</code> <code>GridDefault | None</code> <p>The default grid of the project. Optional.</p> <code>state</code> <code>State | None</code> <p>The state/status of the project. Allowed states are customizeable using the entitystatus API. Optional.</p> <code>application_engineering_inventory_ids</code> <code>list[str] | None</code> <p>Inventory Ids to be added as application engineering. Optional.</p> <p>Methods:</p> Name Description <code>validate_status</code> <p>Somehow, some statuses are capitalized in the API response. This ensures they are always lowercase.</p>"},{"location":"projects/#albert.collections.projects.Project.acl","title":"acl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acl: list[ACL] | None = Field(\n    default_factory=list, alias=\"ACL\"\n)\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.application_engineering_inventory_ids","title":"application_engineering_inventory_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>application_engineering_inventory_ids: list[str] | None = (\n    Field(\n        default=None,\n        alias=\"appEngg\",\n        description=\"Inventory Ids to be added as application engineering\",\n    )\n)\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = Field(min_length=1, max_length=2000)\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.grid","title":"grid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>grid: GridDefault | None = None\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(None, alias='albertId')\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.locations","title":"locations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>locations: list[SerializeAsEntityLink[Location]] | None = (\n    Field(\n        default=None,\n        min_length=1,\n        max_length=20,\n        alias=\"Locations\",\n    )\n)\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] | None = Field(\n    alias=\"Metadata\", default=None\n)\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.old_api_params","title":"old_api_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>old_api_params: dict | None = None\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix: str | None = Field(default=None)\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.project_class","title":"project_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>project_class: ProjectClass | None = Field(\n    default=PRIVATE, alias=\"class\"\n)\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: State | None = Field(default=None, exclude=True)\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: str | None = Field(\n    default=None, exclude=True, frozen=True\n)\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.task_config","title":"task_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task_config: list[TaskConfig] | None = Field(\n    default_factory=list\n)\n</code></pre>"},{"location":"projects/#albert.collections.projects.Project.validate_status","title":"validate_status","text":"<pre><code>validate_status(value)\n</code></pre> <p>Somehow, some statuses are capitalized in the API response. This ensures they are always lowercase.</p> Source code in <code>src/albert/resources/projects.py</code> <pre><code>@field_validator(\"status\", mode=\"before\")\ndef validate_status(cls, value):\n    \"\"\"Somehow, some statuses are capitalized in the API response. This ensures they are always lowercase.\"\"\"\n    if isinstance(value, str):\n        return value.lower()\n    return value\n</code></pre>"},{"location":"projects/#albert.collections.projects.ProjectCollection","title":"ProjectCollection","text":"<pre><code>ProjectCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ProjectCollection is a collection class for managing Project entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new project.</p> <code>delete</code> <p>Delete a project by its ID.</p> <code>get_by_id</code> <p>Retrieve a project by its ID.</p> <code>list</code> <p>List projects with optional filters.</p> <code>update</code> <p>Update a project.</p> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initialize a ProjectCollection object.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ProjectCollection._api_version}/projects\"\n</code></pre>"},{"location":"projects/#albert.collections.projects.ProjectCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/projects'\n</code></pre>"},{"location":"projects/#albert.collections.projects.ProjectCollection.create","title":"create","text":"<pre><code>create(*, project: Project) -&gt; Project\n</code></pre> <p>Create a new project.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>The project to create.</p> required <p>Returns:</p> Type Description <code>Optional[Project]</code> <p>The created project object if successful, None otherwise.</p> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def create(self, *, project: Project) -&gt; Project:\n    \"\"\"\n    Create a new project.\n\n    Parameters\n    ----------\n    project : Project\n        The project to create.\n\n    Returns\n    -------\n    Optional[Project]\n        The created project object if successful, None otherwise.\n    \"\"\"\n    response = self.session.post(\n        self.base_path, json=project.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    )\n    return Project(**response.json())\n</code></pre>"},{"location":"projects/#albert.collections.projects.ProjectCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a project by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the project to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Delete a project by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the project to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"projects/#albert.collections.projects.ProjectCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Project\n</code></pre> <p>Retrieve a project by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the project to retrieve.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The project object if found</p> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Project:\n    \"\"\"\n    Retrieve a project by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the project to retrieve.\n\n    Returns\n    -------\n    Project\n        The project object if found\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n\n    return Project(**response.json())\n</code></pre>"},{"location":"projects/#albert.collections.projects.ProjectCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    text: str = None,\n    status: list[str] = None,\n    market_segment: list[str] = None,\n    application: list[str] = None,\n    technology: list[str] = None,\n    created_by: list[str] = None,\n    location: list[str] = None,\n    from_created_at: str = None,\n    to_created_at: str = None,\n    facet_field: str = None,\n    facet_text: str = None,\n    contains_field: list[str] = None,\n    contains_text: list[str] = None,\n    linked_to: str = None,\n    my_projects: bool = None,\n    my_role: list[str] = None,\n    order_by: OrderBy = DESCENDING,\n    sort_by: str = None,\n    limit: int = 50,\n) -&gt; Iterator[Project]\n</code></pre> <p>List projects with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Search any test in the project.</p> <code>None</code> <code>status</code> <code>list[str]</code> <p>The status filter for the projects.</p> <code>None</code> <code>market_segment</code> <code>list[str]</code> <p>The market segment filter for the projects.</p> <code>None</code> <code>application</code> <code>list[str]</code> <p>The application filter for the projects.</p> <code>None</code> <code>technology</code> <code>list[str]</code> <p>The technology filter for the projects.</p> <code>None</code> <code>created_by</code> <code>list[str]</code> <p>The name of the user who created the project.</p> <code>None</code> <code>location</code> <code>list[str]</code> <p>The location filter for the projects.</p> <code>None</code> <code>from_created_at</code> <code>str</code> <p>The start date filter for the projects.</p> <code>None</code> <code>to_created_at</code> <code>str</code> <p>The end date filter for the projects.</p> <code>None</code> <code>facet_field</code> <code>str</code> <p>The facet field for the projects.</p> <code>None</code> <code>facet_text</code> <code>str</code> <p>The facet text for the projects.</p> <code>None</code> <code>contains_field</code> <code>list[str]</code> <p>To power project facets search</p> <code>None</code> <code>contains_text</code> <code>list[str]</code> <p>To power project facets search</p> <code>None</code> <code>linked_to</code> <code>str</code> <p>To pass text for linked to dropdown search in Task creation flow.</p> <code>None</code> <code>my_projects</code> <code>bool</code> <p>Return Projects owned by you.</p> <code>None</code> <code>my_role</code> <code>list[str]</code> <p>Filter Projects to ones which you have a specific role in.</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order in which to retrieve items (default is OrderBy.DESCENDING).</p> <code>DESCENDING</code> <code>sort_by</code> <code>str</code> <p>The field to sort by.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Project]</code> <p>An iterator of Project resources.</p> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def list(\n    self,\n    *,\n    text: str = None,\n    status: list[str] = None,\n    market_segment: list[str] = None,\n    application: list[str] = None,\n    technology: list[str] = None,\n    created_by: list[str] = None,\n    location: list[str] = None,\n    from_created_at: str = None,\n    to_created_at: str = None,\n    facet_field: str = None,\n    facet_text: str = None,\n    contains_field: list[str] = None,\n    contains_text: list[str] = None,\n    linked_to: str = None,\n    my_projects: bool = None,\n    my_role: list[str] = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    sort_by: str = None,\n    limit: int = 50,\n) -&gt; Iterator[Project]:\n    \"\"\"\n    List projects with optional filters.\n\n    Parameters\n    ----------\n    text : str, optional\n        Search any test in the project.\n    status : list[str], optional\n        The status filter for the projects.\n    market_segment : list[str], optional\n        The market segment filter for the projects.\n    application : list[str], optional\n        The application filter for the projects.\n    technology : list[str], optional\n        The technology filter for the projects.\n    created_by : list[str], optional\n        The name of the user who created the project.\n    location : list[str], optional\n        The location filter for the projects.\n    from_created_at : str, optional\n        The start date filter for the projects.\n    to_created_at : str, optional\n        The end date filter for the projects.\n    facet_field : str, optional\n        The facet field for the projects.\n    facet_text : str, optional\n        The facet text for the projects.\n    contains_field : list[str], optional\n        To power project facets search\n    contains_text : list[str], optional\n        To power project facets search\n    linked_to : str, optional\n        To pass text for linked to dropdown search in Task creation flow.\n    my_projects : bool, optional\n        Return Projects owned by you.\n    my_role : list[str], optional\n        Filter Projects to ones which you have a specific role in.\n    order_by : OrderBy, optional\n        The order in which to retrieve items (default is OrderBy.DESCENDING).\n    sort_by : str, optional\n        The field to sort by.\n\n    Returns\n    ------\n    Iterator[Project]\n        An iterator of Project resources.\n    \"\"\"\n    params = {\n        \"limit\": limit,\n        \"order\": order_by.value,\n        \"text\": text,\n        \"sortBy\": sort_by,\n        \"status\": status,\n        \"marketSegment\": market_segment,\n        \"application\": application,\n        \"technology\": technology,\n        \"createdBy\": created_by,\n        \"location\": location,\n        \"fromCreatedAt\": from_created_at,\n        \"toCreatedAt\": to_created_at,\n        \"facetField\": facet_field,\n        \"facetText\": facet_text,\n        \"containsField\": contains_field,\n        \"containsText\": contains_text,\n        \"linkedTo\": linked_to,\n        \"myProjects\": my_projects,\n        \"myRole\": my_role,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Project(**item) for item in items],\n    )\n</code></pre>"},{"location":"projects/#albert.collections.projects.ProjectCollection.update","title":"update","text":"<pre><code>update(*, project: Project) -&gt; Project\n</code></pre> <p>Update a project.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>The updated project object.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The updated project object as returned by the server.</p> Source code in <code>src/albert/collections/projects.py</code> <pre><code>def update(self, *, project: Project) -&gt; Project:\n    \"\"\"Update a project.\n\n    Parameters\n    ----------\n    project : Project\n        The updated project object.\n\n    Returns\n    -------\n    Project\n        The updated project object as returned by the server.\n    \"\"\"\n    existing_project = self.get_by_id(id=project.id)\n    patch_data = self._generate_patch_payload(existing=existing_project, updated=project)\n    url = f\"{self.base_path}/{project.id}\"\n\n    self.session.patch(url, json=patch_data.model_dump(mode=\"json\", by_alias=True))\n\n    return self.get_by_id(id=project.id)\n</code></pre>"},{"location":"property_data/","title":"Property Data","text":""},{"location":"property_data/#albert.collections.property_data.BlockId","title":"BlockId  <code>module-attribute</code>","text":"<pre><code>BlockId = Annotated[str, AfterValidator(ensure_block_id)]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.DataColumnId","title":"DataColumnId  <code>module-attribute</code>","text":"<pre><code>DataColumnId = Annotated[\n    str, AfterValidator(ensure_data_column_id)\n]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.DataTemplateId","title":"DataTemplateId  <code>module-attribute</code>","text":"<pre><code>DataTemplateId = Annotated[\n    str, AfterValidator(ensure_datatemplate_id)\n]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.IntervalId","title":"IntervalId  <code>module-attribute</code>","text":"<pre><code>IntervalId = Annotated[\n    str, AfterValidator(ensure_interval_id)\n]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.InventoryId","title":"InventoryId  <code>module-attribute</code>","text":"<pre><code>InventoryId = Annotated[\n    str, AfterValidator(ensure_inventory_id)\n]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.LotId","title":"LotId  <code>module-attribute</code>","text":"<pre><code>LotId = Annotated[str, AfterValidator(ensure_lot_id)]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.SearchInventoryId","title":"SearchInventoryId  <code>module-attribute</code>","text":"<pre><code>SearchInventoryId = Annotated[\n    str, AfterValidator(ensure_search_inventory_id)\n]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.SearchProjectId","title":"SearchProjectId  <code>module-attribute</code>","text":"<pre><code>SearchProjectId = Annotated[\n    str, AfterValidator(ensure_project_search_id)\n]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskId","title":"TaskId  <code>module-attribute</code>","text":"<pre><code>TaskId = Annotated[str, AfterValidator(ensure_task_id)]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.UserId","title":"UserId  <code>module-attribute</code>","text":"<pre><code>UserId = Annotated[str, AfterValidator(ensure_user_id)]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.BulkPropertyData","title":"BulkPropertyData","text":"<p>               Bases: <code>BaseAlbertModel</code></p> <p>A Simple Data Structure representing all the columns of data in a block's data column.</p> <p>Methods:</p> Name Description <code>from_dataframe</code> <p>Converts a DataFrame to a BulkPropertyData object.</p>"},{"location":"property_data/#albert.collections.property_data.BulkPropertyData.columns","title":"columns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>columns: list[BulkPropertyDataColumn] = Field(\n    default_factory=list,\n    description=\"The columns of data in the block's data column.\",\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.BulkPropertyData.from_dataframe","title":"from_dataframe  <code>classmethod</code>","text":"<pre><code>from_dataframe(df: DataFrame) -&gt; BulkPropertyData\n</code></pre> <p>Converts a DataFrame to a BulkPropertyData object.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to convert.</p> required <p>Returns:</p> Type Description <code>BulkPropertyData</code> <p>The BulkPropertyData object that represents the data in the DataFrame.</p> Source code in <code>src/albert/resources/property_data.py</code> <pre><code>@classmethod\ndef from_dataframe(cls, df: pd.DataFrame) -&gt; \"BulkPropertyData\":\n    \"\"\"\n    Converts a DataFrame to a BulkPropertyData object.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        The DataFrame to convert.\n\n    Returns\n    -------\n    BulkPropertyData\n        The BulkPropertyData object that represents the data in the DataFrame.\n    \"\"\"\n    # Convert all the values to strings, since all albert values are string typed in Albert\n    df = df.fillna(\"\").astype(str)\n    columns = []\n    for column in df.columns:\n        data_column = BulkPropertyDataColumn(\n            data_column_name=column, data_series=df[column].tolist()\n        )\n        columns.append(data_column)\n    return BulkPropertyData(columns=columns)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.CheckPropertyData","title":"CheckPropertyData","text":"<p>               Bases: <code>BaseResource</code></p>"},{"location":"property_data/#albert.collections.property_data.CheckPropertyData.block_id","title":"block_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block_id: str | None = Field(default=None, alias='blockId')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.CheckPropertyData.data_exists","title":"data_exists  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_exists: bool | None = Field(\n    default=None, alias=\"dataExist\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.CheckPropertyData.interval_id","title":"interval_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interval_id: str | None = Field(\n    default=None, alias=\"interval\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.CheckPropertyData.inventory_id","title":"inventory_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_id: str | None = Field(\n    default=None, alias=\"inventoryId\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.CheckPropertyData.lot_id","title":"lot_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lot_id: str | None = Field(default=None, alias='lotId')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.CheckPropertyData.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str | None = Field(default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.DataEntity","title":"DataEntity","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"property_data/#albert.collections.property_data.DataEntity.INVENTORY","title":"INVENTORY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INVENTORY = 'inventory'\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.DataEntity.TASK","title":"TASK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TASK = 'task'\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.DataEntity.WORKFLOW","title":"WORKFLOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WORKFLOW = 'workflow'\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.EntityLink","title":"EntityLink","text":"<p>               Bases: <code>BaseAlbertModel</code></p> <p>Methods:</p> Name Description <code>to_entity_link</code>"},{"location":"property_data/#albert.collections.property_data.EntityLink.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.EntityLink.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = Field(default=None, exclude=True)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.EntityLink.to_entity_link","title":"to_entity_link","text":"<pre><code>to_entity_link() -&gt; EntityLink\n</code></pre> Source code in <code>src/albert/resources/base.py</code> <pre><code>def to_entity_link(self) -&gt; \"EntityLink\":\n    # Convience method to return self, so you can call this method on objects that are already entity links\n    return self\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.InventoryDataColumn","title":"InventoryDataColumn","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"property_data/#albert.collections.property_data.InventoryDataColumn.data_column_id","title":"data_column_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_column_id: DataColumnId | None = Field(\n    alias=\"id\", default=None\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.InventoryDataColumn.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str | None = Field(default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.InventoryPropertyData","title":"InventoryPropertyData","text":"<p>               Bases: <code>BaseResource</code></p>"},{"location":"property_data/#albert.collections.property_data.InventoryPropertyData.custom_property_data","title":"custom_property_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_property_data: list[CustomData] = Field(\n    default_factory=list, alias=\"NoTask\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.InventoryPropertyData.inventory_id","title":"inventory_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_id: str = Field(alias='inventoryId')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.InventoryPropertyData.inventory_name","title":"inventory_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_name: str | None = Field(\n    default=None, alias=\"inventoryName\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.InventoryPropertyData.task_property_data","title":"task_property_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task_property_data: list[TaskData] = Field(\n    default_factory=list, alias=\"Task\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.InventoryPropertyDataCreate","title":"InventoryPropertyDataCreate","text":"<p>               Bases: <code>BaseResource</code></p>"},{"location":"property_data/#albert.collections.property_data.InventoryPropertyDataCreate.data_columns","title":"data_columns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_columns: list[InventoryDataColumn] = Field(\n    default_factory=list, max_length=1, alias=\"DataColumn\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.InventoryPropertyDataCreate.entity","title":"entity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entity: Literal[INVENTORY] = Field(default=INVENTORY)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.InventoryPropertyDataCreate.inventory_id","title":"inventory_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_id: InventoryId = Field(alias='parentId')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.InventoryPropertyDataCreate.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: PropertyDataStatus | None = Field(default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.NotFoundError","title":"NotFoundError","text":"<pre><code>NotFoundError(response: Response)\n</code></pre> <p>               Bases: <code>AlbertClientError</code></p> <p>HTTP Error due to a 404 Not Found response.</p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, response: requests.Response):\n    message = self._format_message(response)\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"property_data/#albert.collections.property_data.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection","title":"PropertyDataCollection","text":"<pre><code>PropertyDataCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>PropertyDataCollection is a collection class for managing Property Data entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>add_properties_to_inventory</code> <p>Add new properties to an inventory item.</p> <code>add_properties_to_task</code> <p>Add new task properties for a given task.</p> <code>bulk_delete_task_data</code> <p>Bulk delete task data for a given task.</p> <code>bulk_load_task_properties</code> <p>Bulk load task properties for a given task. WARNING: This will overwrite any existing properties!</p> <code>check_block_interval_for_data</code> <p>Check if a specific block interval has data.</p> <code>check_for_task_data</code> <p>Checks if a task has data.</p> <code>get_all_task_properties</code> <p>Returns all the properties for a specific task.</p> <code>get_properties_on_inventory</code> <p>Returns all the properties of an inventory item.</p> <code>get_task_block_properties</code> <p>Returns all the properties within a Property Task block for a specific inventory item.</p> <code>search</code> <p>Search for property data with various filtering options.</p> <code>update_or_create_task_properties</code> <p>Update or create task properties for a given task.</p> <code>update_property_on_inventory</code> <p>Update a property on an inventory item.</p> <code>update_property_on_task</code> <p>Updates a specific property on a task.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the CompanyCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{PropertyDataCollection._api_version}/propertydata\"\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/propertydata'\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.add_properties_to_inventory","title":"add_properties_to_inventory","text":"<pre><code>add_properties_to_inventory(\n    *,\n    inventory_id: InventoryId,\n    properties: list[InventoryDataColumn],\n) -&gt; list[InventoryPropertyDataCreate]\n</code></pre> <p>Add new properties to an inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory item to add properties to.</p> required <code>properties</code> <code>list[InventoryDataColumn]</code> <p>The properties to add.</p> required <p>Returns:</p> Type Description <code>list[InventoryPropertyDataCreate]</code> <p>The registered properties.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef add_properties_to_inventory(\n    self, *, inventory_id: InventoryId, properties: list[InventoryDataColumn]\n) -&gt; list[InventoryPropertyDataCreate]:\n    \"\"\"Add new properties to an inventory item.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory item to add properties to.\n    properties : list[InventoryDataColumn]\n        The properties to add.\n\n    Returns\n    -------\n    list[InventoryPropertyDataCreate]\n        The registered properties.\n    \"\"\"\n    returned = []\n    for p in properties:\n        # Can only add one at a time.\n        create_object = InventoryPropertyDataCreate(\n            inventory_id=inventory_id, data_columns=[p]\n        )\n        response = self.session.post(\n            self.base_path,\n            json=create_object.model_dump(exclude_none=True, by_alias=True, mode=\"json\"),\n        )\n        response_json = response.json()\n        logger.info(response_json.get(\"message\", None))\n        returned.append(InventoryPropertyDataCreate(**response_json))\n    return returned\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.add_properties_to_task","title":"add_properties_to_task","text":"<pre><code>add_properties_to_task(\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n    properties: list[TaskPropertyCreate],\n)\n</code></pre> <p>Add new task properties for a given task.</p> <p>This method only works for new values. If a trial number is provided in the TaskPropertyCreate, it must relate to an existing trial. New trials must be added with no trial number provided. Do not try to create multiple new trials in one call as this will lead to unexpected behavior. Build out new trials in a loop if many new trials are needed.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory.</p> required <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>block_id</code> <code>BlockId</code> <p>The ID of the block.</p> required <code>lot_id</code> <code>LotId</code> <p>The ID of the lot, by default None.</p> <code>None</code> <code>properties</code> <code>list[TaskPropertyCreate]</code> <p>A list of TaskPropertyCreate objects representing the properties to add.</p> required <p>Returns:</p> Type Description <code>list[TaskPropertyData]</code> <p>The newly created task properties.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef add_properties_to_task(\n    self,\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n    properties: list[TaskPropertyCreate],\n):\n    \"\"\"\n    Add new task properties for a given task.\n\n    This method only works for new values. If a trial number is provided in the TaskPropertyCreate,\n    it must relate to an existing trial. New trials must be added with no trial number provided.\n    Do not try to create multiple new trials in one call as this will lead to unexpected behavior.\n    Build out new trials in a loop if many new trials are needed.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory.\n    task_id : TaskId\n        The ID of the task.\n    block_id : BlockId\n        The ID of the block.\n    lot_id : LotId, optional\n        The ID of the lot, by default None.\n    properties : list[TaskPropertyCreate]\n        A list of TaskPropertyCreate objects representing the properties to add.\n\n    Returns\n    -------\n    list[TaskPropertyData]\n        The newly created task properties.\n    \"\"\"\n    params = {\n        \"blockId\": block_id,\n        \"inventoryId\": inventory_id,\n        \"lotId\": lot_id,\n        \"autoCalculate\": \"true\",\n        \"history\": \"true\",\n    }\n    params = {k: v for k, v in params.items() if v is not None}\n    response = self.session.post(\n        url=f\"{self.base_path}/{task_id}\",\n        json=[x.model_dump(exclude_none=True, by_alias=True, mode=\"json\") for x in properties],\n        params=params,\n    )\n\n    registered_properties = [\n        TaskPropertyCreate(**x) for x in response.json() if \"DataTemplate\" in x\n    ]\n    existing_data_rows = self.get_task_block_properties(\n        inventory_id=inventory_id, task_id=task_id, block_id=block_id, lot_id=lot_id\n    )\n    patches = self._form_calculated_task_property_patches(\n        existing_data_rows=existing_data_rows, properties=registered_properties\n    )\n    if len(patches) &gt; 0:\n        return self.update_property_on_task(task_id=task_id, patch_payload=patches)\n    else:\n        return self.get_all_task_properties(task_id=task_id)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.bulk_delete_task_data","title":"bulk_delete_task_data","text":"<pre><code>bulk_delete_task_data(\n    *,\n    task_id: TaskId,\n    block_id: BlockId,\n    inventory_id: InventoryId,\n    lot_id: LotId | None = None,\n    interval_id=None,\n) -&gt; None\n</code></pre> <p>Bulk delete task data for a given task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>block_id</code> <code>BlockId</code> <p>The ID of the block.</p> required <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory.</p> required <code>lot_id</code> <code>LotId</code> <p>The ID of the lot, by default None.</p> <code>None</code> <code>interval_id</code> <code>IntervalId</code> <p>The ID of the interval, by default None. If provided, will delete data for this specific interval.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>def bulk_delete_task_data(\n    self,\n    *,\n    task_id: TaskId,\n    block_id: BlockId,\n    inventory_id: InventoryId,\n    lot_id: LotId | None = None,\n    interval_id=None,\n) -&gt; None:\n    \"\"\"\n    Bulk delete task data for a given task.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task.\n    block_id : BlockId\n        The ID of the block.\n    inventory_id : InventoryId\n        The ID of the inventory.\n    lot_id : LotId, optional\n        The ID of the lot, by default None.\n    interval_id : IntervalId, optional\n        The ID of the interval, by default None. If provided, will delete data for this specific interval.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    params = {\n        \"inventoryId\": inventory_id,\n        \"blockId\": block_id,\n        \"lotId\": lot_id,\n        \"intervalRow\": interval_id if interval_id != \"default\" else None,\n    }\n    params = {k: v for k, v in params.items() if v is not None}\n    self.session.delete(f\"{self.base_path}/{task_id}\", params=params)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.bulk_load_task_properties","title":"bulk_load_task_properties","text":"<pre><code>bulk_load_task_properties(\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    property_data: BulkPropertyData,\n    interval=\"default\",\n    lot_id: LotId = None,\n) -&gt; list[TaskPropertyData]\n</code></pre> <p>Bulk load task properties for a given task. WARNING: This will overwrite any existing properties! BulkPropertyData column names must exactly match the names of the data columns (Case Sensitive).</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory.</p> required <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>block_id</code> <code>BlockId</code> <p>The ID of the block.</p> required <code>lot_id</code> <code>LotId</code> <p>The ID of the lot, by default None.</p> <code>None</code> <code>interval</code> <code>str</code> <p>The interval to use for the properties, by default \"default\". Can be obtained using Workflow.get_interval_id().</p> <code>'default'</code> <code>property_data</code> <code>BulkPropertyData</code> <p>A list of columnwise data containing all your rows of data for a single interval. Can be created using BulkPropertyData.from_dataframe().</p> required <p>Returns:</p> Type Description <code>list[TaskPropertyData]</code> <p>The updated or newly created task properties.</p> Example <pre><code>from albert.resources.property_data import BulkPropertyData\n\ndata = BulkPropertyData.from_dataframe(df=my_dataframe)\nres = client.property_data.bulk_load_task_properties(\n    block_id=\"BLK1\",\n    inventory_id=\"INVEXP102748-042\",\n    property_data=data,\n    task_id=\"TASFOR291760\",\n)\n\n[TaskPropertyData(id=\"TASFOR291760\", ...)]\n</code></pre> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>def bulk_load_task_properties(\n    self,\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    property_data: BulkPropertyData,\n    interval=\"default\",\n    lot_id: LotId = None,\n) -&gt; list[TaskPropertyData]:\n    \"\"\"\n    Bulk load task properties for a given task. WARNING: This will overwrite any existing properties!\n    BulkPropertyData column names must exactly match the names of the data columns (Case Sensitive).\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory.\n    task_id : TaskId\n        The ID of the task.\n    block_id : BlockId\n        The ID of the block.\n    lot_id : LotId, optional\n        The ID of the lot, by default None.\n    interval : str, optional\n        The interval to use for the properties, by default \"default\". Can be obtained using Workflow.get_interval_id().\n    property_data : BulkPropertyData\n        A list of columnwise data containing all your rows of data for a single interval. Can be created using BulkPropertyData.from_dataframe().\n\n    Returns\n    -------\n    list[TaskPropertyData]\n        The updated or newly created task properties.\n\n    Example\n    -------\n\n    ```python\n    from albert.resources.property_data import BulkPropertyData\n\n    data = BulkPropertyData.from_dataframe(df=my_dataframe)\n    res = client.property_data.bulk_load_task_properties(\n        block_id=\"BLK1\",\n        inventory_id=\"INVEXP102748-042\",\n        property_data=data,\n        task_id=\"TASFOR291760\",\n    )\n\n    [TaskPropertyData(id=\"TASFOR291760\", ...)]\n    ```\n    \"\"\"\n    property_df = pd.DataFrame(\n        {x.data_column_name: x.data_series for x in property_data.columns}\n    )\n\n    def _get_column_map(dataframe: pd.DataFrame, property_data: TaskPropertyData):\n        data_col_info = property_data.data[0].trials[0].data_columns  # PropertyValue\n        column_map = {}\n        for col in dataframe.columns:\n            column = [x for x in data_col_info if x.name == col]\n            if len(column) == 1:\n                column_map[col] = column[0]\n            else:\n                raise ValueError(\n                    f\"Column '{col}' not found in block data columns or multiple matches found.\"\n                )\n        return column_map\n\n    def _df_to_task_prop_create_list(\n        dataframe: pd.DataFrame,\n        column_map: dict[str, PropertyValue],\n        data_template_id: DataTemplateId,\n    ) -&gt; list[TaskPropertyCreate]:\n        task_prop_create_list = []\n        for i, row in dataframe.iterrows():\n            for col_name, col_info in column_map.items():\n                if col_name not in dataframe.columns:\n                    raise ValueError(f\"Column '{col_name}' not found in DataFrame.\")\n\n                task_prop_create = TaskPropertyCreate(\n                    data_column=TaskDataColumn(\n                        data_column_id=col_info.id,\n                        column_sequence=col_info.sequence,\n                    ),\n                    value=str(row[col_name]),\n                    visible_trial_number=i + 1,\n                    interval_combination=interval,\n                    data_template=EntityLink(id=data_template_id),\n                )\n                task_prop_create_list.append(task_prop_create)\n        return task_prop_create_list\n\n    task_prop_data = self.get_task_block_properties(\n        inventory_id=inventory_id, task_id=task_id, block_id=block_id, lot_id=lot_id\n    )\n    column_map = _get_column_map(property_df, task_prop_data)\n    all_task_prop_create = _df_to_task_prop_create_list(\n        dataframe=property_df,\n        column_map=column_map,\n        data_template_id=task_prop_data.data_template.id,\n    )\n    with suppress(NotFoundError):\n        # This is expected if the task is new and has no data yet.\n        self.bulk_delete_task_data(\n            task_id=task_id,\n            block_id=block_id,\n            inventory_id=inventory_id,\n            lot_id=lot_id,\n            interval_id=interval,\n        )\n    return self.add_properties_to_task(\n        inventory_id=inventory_id,\n        task_id=task_id,\n        block_id=block_id,\n        lot_id=lot_id,\n        properties=all_task_prop_create,\n    )\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.check_block_interval_for_data","title":"check_block_interval_for_data","text":"<pre><code>check_block_interval_for_data(\n    *,\n    block_id: BlockId,\n    task_id: TaskId,\n    interval_id: IntervalId,\n) -&gt; CheckPropertyData\n</code></pre> <p>Check if a specific block interval has data.</p> <p>Parameters:</p> Name Type Description Default <code>block_id</code> <code>BlockId</code> <p>The ID of the block.</p> required <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>interval_id</code> <code>IntervalId</code> <p>The ID of the interval.</p> required <p>Returns:</p> Type Description <code>CheckPropertyData</code> <p>description</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef check_block_interval_for_data(\n    self, *, block_id: BlockId, task_id: TaskId, interval_id: IntervalId\n) -&gt; CheckPropertyData:\n    \"\"\"Check if a specific block interval has data.\n\n    Parameters\n    ----------\n    block_id : BlockId\n        The ID of the block.\n    task_id : TaskId\n        The ID of the task.\n    interval_id : IntervalId\n        The ID of the interval.\n\n    Returns\n    -------\n    CheckPropertyData\n        _description_\n    \"\"\"\n    params = {\n        \"entity\": \"block\",\n        \"action\": \"checkdata\",\n        \"id\": block_id,\n        \"parentId\": task_id,\n        \"intervalId\": interval_id,\n    }\n\n    response = self.session.get(url=self.base_path, params=params)\n    return CheckPropertyData(response.json())\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.check_for_task_data","title":"check_for_task_data","text":"<pre><code>check_for_task_data(\n    *, task_id: TaskId\n) -&gt; list[CheckPropertyData]\n</code></pre> <p>Checks if a task has data.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task to check for data.</p> required <p>Returns:</p> Type Description <code>list[CheckPropertyData]</code> <p>A list of CheckPropertyData objects representing the data status of each block + inventory item of the task.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef check_for_task_data(self, *, task_id: TaskId) -&gt; list[CheckPropertyData]:\n    \"\"\"Checks if a task has data.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task to check for data.\n\n    Returns\n    -------\n    list[CheckPropertyData]\n        A list of CheckPropertyData objects representing the data status of each block + inventory item of the task.\n    \"\"\"\n    task_info = self._get_task_from_id(id=task_id)\n\n    params = {\n        \"entity\": \"block\",\n        \"action\": \"checkdata\",\n        \"parentId\": task_id,\n        \"id\": [x.id for x in task_info.blocks],\n    }\n\n    response = self.session.get(url=self.base_path, params=params)\n    return [CheckPropertyData(**x) for x in response.json()]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.get_all_task_properties","title":"get_all_task_properties","text":"<pre><code>get_all_task_properties(\n    *, task_id: TaskId\n) -&gt; list[TaskPropertyData]\n</code></pre> <p>Returns all the properties for a specific task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task to retrieve properties for.</p> required <p>Returns:</p> Type Description <code>list[TaskPropertyData]</code> <p>A list of TaskPropertyData objects representing the properties within the task.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef get_all_task_properties(self, *, task_id: TaskId) -&gt; list[TaskPropertyData]:\n    \"\"\"Returns all the properties for a specific task.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task to retrieve properties for.\n\n    Returns\n    -------\n    list[TaskPropertyData]\n        A list of TaskPropertyData objects representing the properties within the task.\n    \"\"\"\n    all_info = []\n    task_data_info = self.check_for_task_data(task_id=task_id)\n    for combo_info in task_data_info:\n        all_info.append(\n            self.get_task_block_properties(\n                inventory_id=combo_info.inventory_id,\n                task_id=task_id,\n                block_id=combo_info.block_id,\n                lot_id=combo_info.lot_id,\n            )\n        )\n\n    return all_info\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.get_properties_on_inventory","title":"get_properties_on_inventory","text":"<pre><code>get_properties_on_inventory(\n    *, inventory_id: InventoryId\n) -&gt; InventoryPropertyData\n</code></pre> <p>Returns all the properties of an inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory item to retrieve properties for.</p> required <p>Returns:</p> Type Description <code>InventoryPropertyData</code> <p>The properties of the inventory item.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef get_properties_on_inventory(self, *, inventory_id: InventoryId) -&gt; InventoryPropertyData:\n    \"\"\"Returns all the properties of an inventory item.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory item to retrieve properties for.\n\n    Returns\n    -------\n    InventoryPropertyData\n        The properties of the inventory item.\n    \"\"\"\n    params = {\"entity\": \"inventory\", \"id\": [inventory_id]}\n    response = self.session.get(url=self.base_path, params=params)\n    response_json = response.json()\n    return InventoryPropertyData(**response_json[0])\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.get_task_block_properties","title":"get_task_block_properties","text":"<pre><code>get_task_block_properties(\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n) -&gt; TaskPropertyData\n</code></pre> <p>Returns all the properties within a Property Task block for a specific inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory.</p> required <code>task_id</code> <code>TaskId</code> <p>The Property task ID.</p> required <code>block_id</code> <code>BlockId</code> <p>The Block ID of the block to retrieve properties for.</p> required <code>lot_id</code> <code>LotId | None</code> <p>The specific Lot of the inventory Item to retrieve lots for, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>TaskPropertyData</code> <p>The properties of the inventory item within the block.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef get_task_block_properties(\n    self,\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n) -&gt; TaskPropertyData:\n    \"\"\"Returns all the properties within a Property Task block for a specific inventory item.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory.\n    task_id : TaskId\n        The Property task ID.\n    block_id : BlockId\n        The Block ID of the block to retrieve properties for.\n    lot_id : LotId | None, optional\n        The specific Lot of the inventory Item to retrieve lots for, by default None\n\n    Returns\n    -------\n    TaskPropertyData\n        The properties of the inventory item within the block.\n    \"\"\"\n    params = {\n        \"entity\": \"task\",\n        \"blockId\": block_id,\n        \"id\": task_id,\n        \"inventoryId\": inventory_id,\n        \"lotId\": lot_id,\n    }\n    params = {k: v for k, v in params.items() if v is not None}\n\n    response = self.session.get(url=self.base_path, params=params)\n    response_json = response.json()\n    return TaskPropertyData(**response_json[0])\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.search","title":"search","text":"<pre><code>search(\n    *,\n    limit: int = 100,\n    result: str | None = None,\n    text: str | None = None,\n    order: OrderBy | None = None,\n    sort_by: str | None = None,\n    inventory_ids: list[SearchInventoryId]\n    | SearchInventoryId\n    | None = None,\n    project_ids: list[SearchProjectId]\n    | SearchProjectId\n    | None = None,\n    lot_ids: list[LotId] | LotId | None = None,\n    data_template_ids: DataTemplateId\n    | list[DataTemplateId]\n    | None = None,\n    data_column_ids: DataColumnId\n    | list[DataColumnId]\n    | None = None,\n    category: list[DataEntity] | DataEntity | None = None,\n    data_templates: list[str] | str | None = None,\n    data_columns: list[str] | str | None = None,\n    parameters: list[str] | str | None = None,\n    parameter_group: list[str] | str | None = None,\n    unit: list[str] | str | None = None,\n    created_by: list[UserId] | UserId | None = None,\n    task_created_by: list[UserId] | UserId | None = None,\n    return_fields: list[str] | str | None = None,\n    return_facets: list[str] | str | None = None,\n) -&gt; Iterator[PropertyDataSearchItem]\n</code></pre> <p>Search for property data with various filtering options.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>100</code> <code>result</code> <code>str</code> <p>Find results using search syntax. e.g. to find all results with viscosity &lt; 200 at a temperature of 25 we would do result=viscosity(&lt;200)@temperature(25)</p> <code>None</code> <code>text</code> <code>str</code> <p>Free text search across all searchable fields.</p> <code>None</code> <code>order</code> <code>OrderBy</code> <p>Sort order (ascending/descending).</p> <code>None</code> <code>sort_by</code> <code>str</code> <p>Field to sort results by.</p> <code>None</code> <code>inventory_ids</code> <code>SearchInventoryIdType or list of SearchInventoryIdType</code> <p>Filter by inventory IDs.</p> <code>None</code> <code>project_ids</code> <code>ProjectIdType or list of ProjectIdType</code> <p>Filter by project IDs.</p> <code>None</code> <code>lot_ids</code> <code>LotIdType or list of LotIdType</code> <p>Filter by lot IDs.</p> <code>None</code> <code>data_template_ids</code> <code>DataTemplateId or list of DataTemplateId</code> <p>Filter by data template IDs.</p> <code>None</code> <code>data_column_ids</code> <code>DataColumnId | list[DataColumnId] | None</code> <p>Filter by data column IDs.</p> <code>None</code> <code>category</code> <code>DataEntity or list of DataEntity</code> <p>Filter by data entity categories.</p> <code>None</code> <code>data_templates</code> <code>str or list of str (exact match)</code> <p>Filter by data template names.</p> <code>None</code> <code>data_columns</code> <code>str or list of str (exact match)</code> <p>Filter by data column names (currently non-functional).</p> <code>None</code> <code>parameters</code> <code>str or list of str (exact match)</code> <p>Filter by parameter names.</p> <code>None</code> <code>parameter_group</code> <code>str or list of str (exact match)</code> <p>Filter by parameter group names.</p> <code>None</code> <code>unit</code> <code>str or list of str (exact match)</code> <p>Filter by unit names.</p> <code>None</code> <code>created_by</code> <code>UserIdType or list of UserIdType</code> <p>Filter by creator user IDs.</p> <code>None</code> <code>task_created_by</code> <code>UserIdType or list of UserIdType</code> <p>Filter by task creator user IDs.</p> <code>None</code> <code>return_fields</code> <code>str or list of str</code> <p>Specific fields to include in results. If None, returns all fields.</p> <code>None</code> <code>return_facets</code> <code>str or list of str</code> <p>Specific facets to include in results.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Search results matching the specified criteria.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef search(\n    self,\n    *,\n    limit: int = 100,\n    result: str | None = None,\n    text: str | None = None,\n    # Sorting/pagination\n    order: OrderBy | None = None,\n    sort_by: str | None = None,\n    # Core platform identifiers\n    inventory_ids: list[SearchInventoryId] | SearchInventoryId | None = None,\n    project_ids: list[SearchProjectId] | SearchProjectId | None = None,\n    lot_ids: list[LotId] | LotId | None = None,\n    data_template_ids: DataTemplateId | list[DataTemplateId] | None = None,\n    data_column_ids: DataColumnId | list[DataColumnId] | None = None,\n    # Data structure filters\n    category: list[DataEntity] | DataEntity | None = None,\n    data_templates: list[str] | str | None = None,\n    data_columns: list[str] | str | None = None,\n    # Data content filters\n    parameters: list[str] | str | None = None,\n    parameter_group: list[str] | str | None = None,\n    unit: list[str] | str | None = None,\n    # User filters\n    created_by: list[UserId] | UserId | None = None,\n    task_created_by: list[UserId] | UserId | None = None,\n    # Response customization\n    return_fields: list[str] | str | None = None,\n    return_facets: list[str] | str | None = None,\n) -&gt; Iterator[PropertyDataSearchItem]:\n    \"\"\"Search for property data with various filtering options.\n\n    Parameters\n    ----------\n    limit : int, default=100\n        Maximum number of results to return.\n    result : str, optional\n        Find results using search syntax. e.g. to find all results with viscosity &lt; 200 at a temperature of 25 we would do\n        result=viscosity(&lt;200)@temperature(25)\n    text : str, optional\n        Free text search across all searchable fields.\n    order : OrderBy, optional\n        Sort order (ascending/descending).\n    sort_by : str, optional\n        Field to sort results by.\n    inventory_ids : SearchInventoryIdType or list of SearchInventoryIdType, optional\n        Filter by inventory IDs.\n    project_ids : ProjectIdType or list of ProjectIdType, optional\n        Filter by project IDs.\n    lot_ids : LotIdType or list of LotIdType, optional\n        Filter by lot IDs.\n    data_template_ids : DataTemplateId or list of DataTemplateId, optional\n        Filter by data template IDs.\n    data_column_ids: DataColumnId or list of DataColumnId, optional\n        Filter by data column IDs.\n    category : DataEntity or list of DataEntity, optional\n        Filter by data entity categories.\n    data_templates : str or list of str (exact match), optional\n        Filter by data template names.\n    data_columns : str or list of str (exact match), optional\n        Filter by data column names (currently non-functional).\n    parameters : str or list of str (exact match), optional\n        Filter by parameter names.\n    parameter_group : str or list of str (exact match), optional\n        Filter by parameter group names.\n    unit : str or list of str (exact match), optional\n        Filter by unit names.\n    created_by : UserIdType or list of UserIdType, optional\n        Filter by creator user IDs.\n    task_created_by : UserIdType or list of UserIdType, optional\n        Filter by task creator user IDs.\n    return_fields : str or list of str, optional\n        Specific fields to include in results. If None, returns all fields.\n    return_facets : str or list of str, optional\n        Specific facets to include in results.\n\n    Returns\n    -------\n    dict\n        Search results matching the specified criteria.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; list[PropertyDataSearchItem]:\n        return [PropertyDataSearchItem.model_validate(x) for x in items]\n\n    if isinstance(inventory_ids, str):\n        inventory_ids = [inventory_ids]\n    if isinstance(project_ids, str):\n        project_ids = [project_ids]\n    if isinstance(lot_ids, str):\n        lot_ids = [lot_ids]\n    if isinstance(data_template_ids, str):\n        data_template_ids = [data_template_ids]\n    if isinstance(data_column_ids, str):\n        data_column_ids = [data_column_ids]\n    if isinstance(category, DataEntity):\n        category = [category]\n    if isinstance(data_templates, str):\n        data_templates = [data_templates]\n    if isinstance(data_columns, str):\n        data_columns = [data_columns]\n    if isinstance(parameters, str):\n        parameters = [parameters]\n    if isinstance(parameter_group, str):\n        parameter_group = [parameter_group]\n    if isinstance(unit, str):\n        unit = [unit]\n    if isinstance(created_by, str):\n        created_by = [created_by]\n    if isinstance(task_created_by, str):\n        task_created_by = [task_created_by]\n    if isinstance(return_fields, str):\n        return_fields = [return_fields]\n    if isinstance(return_facets, str):\n        return_facets = [return_facets]\n\n    params = {\n        \"limit\": limit,\n        \"result\": result,\n        \"text\": text,\n        \"order\": order.value if order is not None else None,\n        \"sortBy\": sort_by,\n        \"inventoryIds\": inventory_ids if inventory_ids is not None else None,\n        \"projectIds\": project_ids if project_ids is not None else None,\n        \"lotIds\": lot_ids if lot_ids is not None else None,\n        \"dataTemplateId\": data_template_ids if data_template_ids is not None else None,\n        \"dataColumnId\": data_column_ids if data_column_ids is not None else None,\n        \"category\": [c.value for c in category] if category is not None else None,\n        \"dataTemplates\": data_templates,\n        \"dataColumns\": data_columns,\n        \"parameters\": parameters,\n        \"parameterGroup\": parameter_group,\n        \"unit\": unit,\n        \"createdBy\": created_by if created_by is not None else None,\n        \"taskCreatedBy\": task_created_by if task_created_by is not None else None,\n        \"returnFields\": return_fields,\n        \"returnFacets\": return_facets,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        params=params,\n        session=self.session,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.update_or_create_task_properties","title":"update_or_create_task_properties","text":"<pre><code>update_or_create_task_properties(\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n    properties: list[TaskPropertyCreate],\n) -&gt; list[TaskPropertyData]\n</code></pre> <p>Update or create task properties for a given task.</p> <p>If a trial number is provided in the TaskPropertyCreate, it must relate to an existing trial. New trials must be added with no trial number provided. Do not try to create multiple new trials in one call as this will lead to unexpected behavior. Build out new trials in a loop if many new trials are needed.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory.</p> required <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>block_id</code> <code>BlockId</code> <p>The ID of the block.</p> required <code>lot_id</code> <code>LotId</code> <p>The ID of the lot, by default None.</p> <code>None</code> <code>properties</code> <code>list[TaskPropertyCreate]</code> <p>A list of TaskPropertyCreate objects representing the properties to update or create.</p> required <p>Returns:</p> Type Description <code>list[TaskPropertyData]</code> <p>The updated or newly created task properties.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef update_or_create_task_properties(\n    self,\n    *,\n    inventory_id: InventoryId,\n    task_id: TaskId,\n    block_id: BlockId,\n    lot_id: LotId | None = None,\n    properties: list[TaskPropertyCreate],\n) -&gt; list[TaskPropertyData]:\n    \"\"\"\n    Update or create task properties for a given task.\n\n    If a trial number is provided in the TaskPropertyCreate, it must relate to an existing trial.\n    New trials must be added with no trial number provided. Do not try to create multiple new trials\n    in one call as this will lead to unexpected behavior. Build out new trials in a loop if many new\n    trials are needed.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory.\n    task_id : TaskId\n        The ID of the task.\n    block_id : BlockId\n        The ID of the block.\n    lot_id : LotId, optional\n        The ID of the lot, by default None.\n    properties : list[TaskPropertyCreate]\n        A list of TaskPropertyCreate objects representing the properties to update or create.\n\n    Returns\n    -------\n    list[TaskPropertyData]\n        The updated or newly created task properties.\n\n    \"\"\"\n    existing_data_rows = self.get_task_block_properties(\n        inventory_id=inventory_id, task_id=task_id, block_id=block_id, lot_id=lot_id\n    )\n    update_patches, new_values = self._form_existing_row_value_patches(\n        existing_data_rows=existing_data_rows, properties=properties\n    )\n\n    calculated_patches = self._form_calculated_task_property_patches(\n        existing_data_rows=existing_data_rows, properties=properties\n    )\n    all_patches = update_patches + calculated_patches\n    if len(new_values) &gt; 0:\n        self.update_property_on_task(task_id=task_id, patch_payload=all_patches)\n        return self.add_properties_to_task(\n            inventory_id=inventory_id,\n            task_id=task_id,\n            block_id=block_id,\n            lot_id=lot_id,\n            properties=new_values,\n        )\n    else:\n        return self.update_property_on_task(task_id=task_id, patch_payload=all_patches)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.update_property_on_inventory","title":"update_property_on_inventory","text":"<pre><code>update_property_on_inventory(\n    *,\n    inventory_id: InventoryId,\n    property_data: InventoryDataColumn,\n) -&gt; InventoryPropertyData\n</code></pre> <p>Update a property on an inventory item.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_id</code> <code>InventoryId</code> <p>The ID of the inventory item to update the property on.</p> required <code>property_data</code> <code>InventoryDataColumn</code> <p>The updated property data.</p> required <p>Returns:</p> Type Description <code>InventoryPropertyData</code> <p>The updated property data as returned by the server.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef update_property_on_inventory(\n    self, *, inventory_id: InventoryId, property_data: InventoryDataColumn\n) -&gt; InventoryPropertyData:\n    \"\"\"Update a property on an inventory item.\n\n    Parameters\n    ----------\n    inventory_id : InventoryId\n        The ID of the inventory item to update the property on.\n    property_data : InventoryDataColumn\n        The updated property data.\n\n    Returns\n    -------\n    InventoryPropertyData\n        The updated property data as returned by the server.\n    \"\"\"\n    existing_properties = self.get_properties_on_inventory(inventory_id=inventory_id)\n    existing_value = None\n    for p in existing_properties.custom_property_data:\n        if p.data_column.data_column_id == property_data.data_column_id:\n            existing_value = (\n                p.data_column.property_data.value\n                if p.data_column.property_data.value is not None\n                else p.data_column.property_data.string_value\n                if p.data_column.property_data.string_value is not None\n                else str(p.data_column.property_data.numeric_value)\n                if p.data_column.property_data.numeric_value is not None\n                else None\n            )\n            existing_id = p.data_column.property_data.id\n            break\n    if existing_value is not None:\n        payload = [\n            PropertyDataPatchDatum(\n                operation=PatchOperation.UPDATE,\n                id=existing_id,\n                attribute=\"value\",\n                new_value=property_data.value,\n                old_value=existing_value,\n            )\n        ]\n    else:\n        payload = [\n            PropertyDataPatchDatum(\n                operation=PatchOperation.ADD,\n                id=existing_id,\n                attribute=\"value\",\n                new_value=property_data.value,\n            )\n        ]\n\n    self.session.patch(\n        url=f\"{self.base_path}/{inventory_id}\",\n        json=[x.model_dump(exclude_none=True, by_alias=True, mode=\"json\") for x in payload],\n    )\n    return self.get_properties_on_inventory(inventory_id=inventory_id)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataCollection.update_property_on_task","title":"update_property_on_task","text":"<pre><code>update_property_on_task(\n    *,\n    task_id: TaskId,\n    patch_payload: list[PropertyDataPatchDatum],\n) -&gt; list[TaskPropertyData]\n</code></pre> <p>Updates a specific property on a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task.</p> required <code>patch_payload</code> <code>list[PropertyDataPatchDatum]</code> <p>The specific patch to make to update the property.</p> required <p>Returns:</p> Type Description <code>list[TaskPropertyData]</code> <p>A list of TaskPropertyData objects representing the properties within the task.</p> Source code in <code>src/albert/collections/property_data.py</code> <pre><code>@validate_call\ndef update_property_on_task(\n    self, *, task_id: TaskId, patch_payload: list[PropertyDataPatchDatum]\n) -&gt; list[TaskPropertyData]:\n    \"\"\"Updates a specific property on a task.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task.\n    patch_payload : list[PropertyDataPatchDatum]\n        The specific patch to make to update the property.\n\n    Returns\n    -------\n    list[TaskPropertyData]\n        A list of TaskPropertyData objects representing the properties within the task.\n    \"\"\"\n    if len(patch_payload) &gt; 0:\n        self.session.patch(\n            url=f\"{self.base_path}/{task_id}\",\n            json=[\n                x.model_dump(exclude_none=True, by_alias=True, mode=\"json\")\n                for x in patch_payload\n            ],\n        )\n    return self.get_all_task_properties(task_id=task_id)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataPatchDatum","title":"PropertyDataPatchDatum","text":"<p>               Bases: <code>PatchDatum</code></p>"},{"location":"property_data/#albert.collections.property_data.PropertyDataPatchDatum.property_column_id","title":"property_column_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>property_column_id: DataColumnId | PropertyDataId = Field(\n    alias=\"id\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem","title":"PropertyDataSearchItem","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: str\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.created_by","title":"created_by  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created_by: str = Field(..., alias='createdBy')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.data_template_id","title":"data_template_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_template_id: DataTemplateId = Field(\n    ..., alias=\"dataTemplateId\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.data_template_name","title":"data_template_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_template_name: str = Field(\n    ..., alias=\"dataTemplateName\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: PropertyDataId\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.inventory_id","title":"inventory_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_id: InventoryId = Field(..., alias='inventoryId')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: TaskId | InventoryId = Field(\n    ..., alias=\"parentId\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.project_id","title":"project_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>project_id: ProjectId = Field(..., alias='projectId')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.result","title":"result  <code>instance-attribute</code>","text":"<pre><code>result: PropertyDataResult\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.task_id","title":"task_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task_id: TaskId | None = Field(default=None, alias=\"taskId\")\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.workflow","title":"workflow  <code>instance-attribute</code>","text":"<pre><code>workflow: list[WorkflowItem]\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.workflow_id","title":"workflow_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workflow_id: WorkflowId = Field(..., alias='workflowId')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyDataSearchItem.workflow_name","title":"workflow_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>workflow_name: str | None = Field(\n    default=None, alias=\"workflowName\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyTask","title":"PropertyTask","text":"<p>               Bases: <code>BaseTask</code></p> <p>Represents a batch task.</p> <p>This class is used to create and manage batch tasks. It includes the base task attributes and additional attributes specific to batch tasks.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the batch task.</p> <code>inventory_information</code> <code>list[InventoryInformation]</code> <p>Information about the inventory associated with the batch task.</p> <code>location</code> <code>SerializeAsEntityLink[Location]</code> <p>The location where the batch task is performed.</p> <code>parent_id</code> <code>str</code> <p>The ID of the parent project.</p> <code>blocks</code> <code>list[Block]</code> <p>A list of blocks associated with the batch task.</p> <code>id</code> <code>(str, optional)</code> <p>The ID of the batch task, by default None.</p> <code>metadata</code> <code>(dict[str, MetadataItem], optional)</code> <p>Metadata associated with the batch task, by default an empty dictionary.</p> <code>due_date</code> <code>(str, optional)</code> <p>The due date of the batch task. YYY-MM-DD format, by default None.</p> <code>notes</code> <code>(str, optional)</code> <p>Notes associated with the batch task, by default None.</p> <code>priority</code> <code>(TaskPriority, optional)</code> <p>The priority of the batch task, by default None.</p> <code>assigned_to</code> <code>(SerializeAsEntityLink[User], optional)</code> <p>The user assigned to the batch task, by default None.</p> <code>state</code> <code>(TaskState, optional)</code> <p>The state of the batch task, by default None.</p> <code>sources</code> <code>(list[TaskSource], optional)</code> <p>A list of sources associated with the batch task, by default an empty list.</p> <code>security_class</code> <code>(SecurityClass, optional)</code> <p>The security class of the batch task, by default None.</p> <code>start_date</code> <code>str, read only</code> <p>The start date of the batch task, by default None.</p> <code>claimed_date</code> <code>str, read only</code> <p>The claimed date of the batch task, by default None.</p> <code>completed_date</code> <code>str, read only</code> <p>The completed date of the batch task, by default None.</p> <code>closed_date</code> <code>str, read only</code> <p>The closed date of the batch task, by default None.</p>"},{"location":"property_data/#albert.collections.property_data.PropertyTask.batch_task_id","title":"batch_task_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>batch_task_id: str | None = Field(\n    alias=\"batchTaskId\", default=None\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyTask.blocks","title":"blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocks: list[Block] | None = Field(\n    alias=\"Blocks\", default=None\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyTask.category","title":"category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category: Literal[PROPERTY] = PROPERTY\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyTask.qc_task","title":"qc_task  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qc_task: bool | None = Field(alias='qcTask', default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyTask.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>target: str | None = Field(default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyValue","title":"PropertyValue","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"property_data/#albert.collections.property_data.PropertyValue.calculation","title":"calculation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calculation: str | None = Field(default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyValue.data_column_unique_id","title":"data_column_unique_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_column_unique_id: str | None = Field(\n    default=None, alias=\"dataColumnUniqueId\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyValue.hidden","title":"hidden  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hidden: bool | None = Field(default=False)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyValue.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyValue.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = Field(default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyValue.numeric_value","title":"numeric_value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>numeric_value: float | None = Field(\n    default=None, alias=\"valueNumeric\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyValue.property_data","title":"property_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>property_data: PropertyData | None = Field(\n    default=None, alias=\"PropertyData\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyValue.sequence","title":"sequence  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sequence: str | None = Field(default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyValue.string_value","title":"string_value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>string_value: str | None = Field(\n    default=None, alias=\"valueString\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyValue.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: SerializeAsEntityLink[Unit] | dict = Field(\n    default_factory=dict, alias=\"Unit\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.PropertyValue.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str | None = Field(default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskCollection","title":"TaskCollection","text":"<pre><code>TaskCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>TaskCollection is a collection class for managing Task entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert Session information</p> required <p>Methods:</p> Name Description <code>add_block</code> <p>Add a block to a Property task.</p> <code>create</code> <p>Create a new task. Tasks can be of different types, such as PropertyTask, and are created using the provided task object.</p> <code>delete</code> <p>Delete a task.</p> <code>get_by_id</code> <p>Retrieve a task by its ID.</p> <code>get_history</code> <code>list</code> <p>Search for tasks matching the given criteria.</p> <code>remove_block</code> <p>Remove a block from a Property task.</p> <code>update</code> <p>Update a task.</p> <code>update_block_workflow</code> <p>Update the workflow of a specific block within a task.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initialize the TaskCollection.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert Session information\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{TaskCollection._api_version}/tasks\"\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/tasks'\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskCollection.add_block","title":"add_block","text":"<pre><code>add_block(\n    *,\n    task_id: TaskId,\n    data_template_id: DataTemplateId,\n    workflow_id: WorkflowId,\n) -&gt; None\n</code></pre> <p>Add a block to a Property task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task to add the block to.</p> required <code>data_template_id</code> <code>DataTemplateId</code> <p>The ID of the data template to use for the block.</p> required <code>workflow_id</code> <code>WorkflowId</code> <p>The ID of the workflow to assign to the block.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This method does not return any value.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef add_block(\n    self, *, task_id: TaskId, data_template_id: DataTemplateId, workflow_id: WorkflowId\n) -&gt; None:\n    \"\"\"Add a block to a Property task.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task to add the block to.\n    data_template_id : DataTemplateId\n        The ID of the data template to use for the block.\n    workflow_id : WorkflowId\n        The ID of the workflow to assign to the block.\n\n    Returns\n    -------\n    None\n        This method does not return any value.\n\n    \"\"\"\n    url = f\"{self.base_path}/{task_id}\"\n    payload = [\n        {\n            \"id\": task_id,\n            \"data\": [\n                {\n                    \"operation\": \"add\",\n                    \"attribute\": \"Block\",\n                    \"newValue\": [{\"datId\": data_template_id, \"Workflow\": {\"id\": workflow_id}}],\n                }\n            ],\n        }\n    ]\n    self.session.patch(url=url, json=payload)\n    return None\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskCollection.create","title":"create","text":"<pre><code>create(*, task: BaseTask) -&gt; BaseTask\n</code></pre> <p>Create a new task. Tasks can be of different types, such as PropertyTask, and are created using the provided task object.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>BaseTask</code> <p>The task object to create.</p> required <p>Returns:</p> Type Description <code>BaseTask</code> <p>The registered task object.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def create(self, *, task: BaseTask) -&gt; BaseTask:\n    \"\"\"Create a new task. Tasks can be of different types, such as PropertyTask, and are created using the provided task object.\n\n    Parameters\n    ----------\n    task : BaseTask\n        The task object to create.\n\n    Returns\n    -------\n    BaseTask\n        The registered task object.\n    \"\"\"\n    payload = [task.model_dump(mode=\"json\", by_alias=True, exclude_none=True)]\n    url = f\"{self.base_path}/multi?category={task.category.value}\"\n    if task.parent_id is not None:\n        url = f\"{url}&amp;parentId={task.parent_id}\"\n    response = self.session.post(url=url, json=payload)\n    task_data = response.json()[0]\n    return TaskAdapter.validate_python(task_data)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskCollection.delete","title":"delete","text":"<pre><code>delete(*, id: TaskId) -&gt; None\n</code></pre> <p>Delete a task.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TaskId</code> <p>The ID of the task to delete.</p> required Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef delete(self, *, id: TaskId) -&gt; None:\n    \"\"\"Delete a task.\n\n    Parameters\n    ----------\n    id : TaskId\n        The ID of the task to delete.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: TaskId) -&gt; BaseTask\n</code></pre> <p>Retrieve a task by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TaskId</code> <p>The ID of the task to retrieve.</p> required <p>Returns:</p> Type Description <code>BaseTask</code> <p>The task object with the provided ID.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef get_by_id(self, *, id: TaskId) -&gt; BaseTask:\n    \"\"\"Retrieve a task by its ID.\n\n    Parameters\n    ----------\n    id : TaskId\n        The ID of the task to retrieve.\n\n    Returns\n    -------\n    BaseTask\n        The task object with the provided ID.\n    \"\"\"\n    url = f\"{self.base_path}/multi/{id}\"\n    response = self.session.get(url)\n    return TaskAdapter.validate_python(response.json())\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskCollection.get_history","title":"get_history","text":"<pre><code>get_history(\n    *,\n    id: TaskId,\n    order: OrderBy = DESCENDING,\n    limit: int = 1000,\n    entity: HistoryEntity | None = None,\n    blockId: str | None = None,\n    startKey: str | None = None,\n) -&gt; TaskHistory\n</code></pre> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def get_history(\n    self,\n    *,\n    id: TaskId,\n    order: OrderBy = OrderBy.DESCENDING,\n    limit: int = 1000,\n    entity: HistoryEntity | None = None,\n    blockId: str | None = None,\n    startKey: str | None = None,\n) -&gt; TaskHistory:\n    params = {\n        \"limit\": limit,\n        \"orderBy\": OrderBy(order).value if order else None,\n        \"entity\": entity,\n        \"blockId\": blockId,\n        \"startKey\": startKey,\n    }\n    url = f\"{self.base_path}/{id}/history\"\n    response = self.session.get(url, params=params)\n    return TaskHistory(**response.json())\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    order: OrderBy = DESCENDING,\n    text: str | None = None,\n    sort_by: str | None = None,\n    tags: list[str] | None = None,\n    task_id: list[str] | None = None,\n    linked_task: list[str] | None = None,\n    category: TaskCategory | None = None,\n    albert_id: list[str] | None = None,\n    data_template: list[str] | None = None,\n    assigned_to: list[str] | None = None,\n    location: list[str] | None = None,\n    priority: list[str] | None = None,\n    status: list[str] | None = None,\n    parameter_group: list[str] | None = None,\n    created_by: list[str] | None = None,\n    project_id: str | None = None,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; Iterator[BaseTask]\n</code></pre> <p>Search for tasks matching the given criteria.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>OrderBy</code> <p>The order in which to return results, by default OrderBy.DESCENDING</p> <code>DESCENDING</code> <code>text</code> <code>str | None</code> <p>The text to search for, by default None</p> <code>None</code> <code>sort_by</code> <code>str | None</code> <p>The attribute to sort by, by default None</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>The tags to search for, by default None</p> <code>None</code> <code>task_id</code> <code>list[str] | None</code> <p>The related task IDs to search for, by default None</p> <code>None</code> <code>linked_task</code> <code>list[str] | None</code> <p>The Linked Task IDs to search for, by default None</p> <code>None</code> <code>category</code> <code>TaskCategory | None</code> <p>The category of the task to search for, by default None</p> <code>None</code> <code>albert_id</code> <code>list[str] | None</code> <p>The Albert IDs to search for, by default None</p> <code>None</code> <code>data_template</code> <code>list[str] | None</code> <p>The data template IDs to search for, by default None</p> <code>None</code> <code>assigned_to</code> <code>list[str] | None</code> <p>The User IDs to search for, by default None</p> <code>None</code> <code>location</code> <code>list[str] | None</code> <p>The Locations names to search for, by default None</p> <code>None</code> <code>priority</code> <code>list[str] | None</code> <p>The Priority levels to search for, by default None</p> <code>None</code> <code>status</code> <code>list[str] | None</code> <p>The Task Statuses to search for, by default None</p> <code>None</code> <code>parameter_group</code> <code>list[str] | None</code> <p>The related Parameter Group IDs to search for, by default None</p> <code>None</code> <code>created_by</code> <code>list[str] | None</code> <p>The User IDs of the task creators to search for, by default None</p> <code>None</code> <code>project_id</code> <code>str | None</code> <p>The Project ID to search for, by default None</p> <code>None</code> <p>Yields:</p> Type Description <code>Iterator[BaseTask]</code> <p>An iterator of matching Task objects.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def list(\n    self,\n    *,\n    order: OrderBy = OrderBy.DESCENDING,\n    text: str | None = None,\n    sort_by: str | None = None,\n    tags: list[str] | None = None,\n    task_id: list[str] | None = None,\n    linked_task: list[str] | None = None,\n    category: TaskCategory | None = None,\n    albert_id: list[str] | None = None,\n    data_template: list[str] | None = None,\n    assigned_to: list[str] | None = None,\n    location: list[str] | None = None,\n    priority: list[str] | None = None,\n    status: list[str] | None = None,\n    parameter_group: list[str] | None = None,\n    created_by: list[str] | None = None,\n    project_id: str | None = None,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; Iterator[BaseTask]:\n    \"\"\"Search for tasks matching the given criteria.\n\n    Parameters\n    ----------\n    order : OrderBy, optional\n        The order in which to return results, by default OrderBy.DESCENDING\n    text : str | None, optional\n        The text to search for, by default None\n    sort_by : str | None, optional\n        The attribute to sort by, by default None\n    tags : list[str] | None, optional\n        The tags to search for, by default None\n    task_id : list[str] | None, optional\n        The related task IDs to search for, by default None\n    linked_task : list[str] | None, optional\n        The Linked Task IDs to search for, by default None\n    category : TaskCategory | None, optional\n        The category of the task to search for, by default None\n    albert_id : list[str] | None, optional\n        The Albert IDs to search for, by default None\n    data_template : list[str] | None, optional\n        The data template IDs to search for, by default None\n    assigned_to : list[str] | None, optional\n        The User IDs to search for, by default None\n    location : list[str] | None, optional\n        The Locations names to search for, by default None\n    priority : list[str] | None, optional\n        The Priority levels to search for, by default None\n    status : list[str] | None, optional\n        The Task Statuses to search for, by default None\n    parameter_group : list[str] | None, optional\n        The related Parameter Group IDs to search for, by default None\n    created_by : list[str] | None, optional\n        The User IDs of the task creators to search for, by default None\n    project_id : str | None, optional\n        The Project ID to search for, by default None\n\n    Yields\n    ------\n    Iterator[BaseTask]\n        An iterator of matching Task objects.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[BaseTask]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except (\n                AlbertHTTPError,\n                RetryError,\n            ) as e:  # some legacy poorly formed Tasks raise 500s. The allowance on Retry error to also ignore these.\n                logger.warning(f\"Error fetching task '{id}': {e}\")\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"order\": OrderBy(order).value if order else None,\n        \"text\": text,\n        \"sortBy\": sort_by,\n        \"tags\": tags,\n        \"taskId\": task_id,\n        \"linkedTask\": linked_task,\n        \"category\": category,\n        \"albertId\": albert_id,\n        \"dataTemplate\": data_template,\n        \"assignedTo\": assigned_to,\n        \"location\": location,\n        \"priority\": priority,\n        \"status\": status,\n        \"parameterGroup\": parameter_group,\n        \"createdBy\": created_by,\n        \"projectId\": project_id,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        deserialize=deserialize,\n        params=params,\n    )\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskCollection.remove_block","title":"remove_block","text":"<pre><code>remove_block(*, task_id: TaskId, block_id: BlockId) -&gt; None\n</code></pre> <p>Remove a block from a Property task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>ID of the Task to remove the block from (e.g., TASFOR1234)</p> required <code>block_id</code> <code>str</code> <p>ID of the Block to remove (e.g., BLK1)</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef remove_block(self, *, task_id: TaskId, block_id: BlockId) -&gt; None:\n    \"\"\"Remove a block from a Property task.\n\n    Parameters\n    ----------\n    task_id : str\n        ID of the Task to remove the block from (e.g., TASFOR1234)\n    block_id : str\n        ID of the Block to remove (e.g., BLK1)\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{task_id}\"\n    payload = [\n        {\n            \"id\": task_id,\n            \"data\": [\n                {\n                    \"operation\": \"delete\",\n                    \"attribute\": \"Block\",\n                    \"oldValue\": [block_id],\n                }\n            ],\n        }\n    ]\n    self.session.patch(url=url, json=payload)\n    return None\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskCollection.update","title":"update","text":"<pre><code>update(*, task: BaseTask) -&gt; BaseTask\n</code></pre> <p>Update a task.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>BaseTask</code> <p>The updated Task object.</p> required <p>Returns:</p> Type Description <code>BaseTask</code> <p>The updated Task object as it exists in the Albert platform.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def update(self, *, task: BaseTask) -&gt; BaseTask:\n    \"\"\"Update a task.\n\n    Parameters\n    ----------\n    task : BaseTask\n        The updated Task object.\n\n    Returns\n    -------\n    BaseTask\n        The updated Task object as it exists in the Albert platform.\n    \"\"\"\n    patch_payload = self._generate_adv_patch_payload(updated=task)\n    if len(patch_payload[0][\"data\"]) == 0:\n        logger.info(f\"Task {task.id} is already up to date\")\n        return task\n    self.session.patch(\n        url=f\"{self.base_path}/{task.id}\",\n        json=patch_payload,\n    )\n    return self.get_by_id(id=task.id)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskCollection.update_block_workflow","title":"update_block_workflow","text":"<pre><code>update_block_workflow(\n    *,\n    task_id: TaskId,\n    block_id: BlockId,\n    workflow_id: WorkflowId,\n) -&gt; None\n</code></pre> <p>Update the workflow of a specific block within a task.</p> <p>This method updates the workflow of a specified block within a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task.</p> required <code>block_id</code> <code>str</code> <p>The ID of the block within the task.</p> required <code>workflow_id</code> <code>str</code> <p>The ID of the new workflow to be assigned to the block.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This method does not return any value.</p> Notes <ul> <li>The method asserts that the retrieved task is an instance of <code>PropertyTask</code>.</li> <li>If the block's current workflow matches the new workflow ID, no update is performed.</li> <li>The method handles the case where the block has a default workflow named \"No Parameter Group\".</li> </ul> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef update_block_workflow(\n    self, *, task_id: TaskId, block_id: BlockId, workflow_id: WorkflowId\n) -&gt; None:\n    \"\"\"\n    Update the workflow of a specific block within a task.\n\n    This method updates the workflow of a specified block within a task.\n    Parameters\n    ----------\n    task_id : str\n        The ID of the task.\n    block_id : str\n        The ID of the block within the task.\n    workflow_id : str\n        The ID of the new workflow to be assigned to the block.\n\n    Returns\n    -------\n    None\n        This method does not return any value.\n\n    Notes\n    -----\n    - The method asserts that the retrieved task is an instance of `PropertyTask`.\n    - If the block's current workflow matches the new workflow ID, no update is performed.\n    - The method handles the case where the block has a default workflow named \"No Parameter Group\".\n    \"\"\"\n    url = f\"{self.base_path}/{task_id}\"\n    task = self.get_by_id(id=task_id)\n    if not isinstance(task, PropertyTask):\n        logger.error(f\"Task {task_id} is not an instance of PropertyTask\")\n        raise TypeError(f\"Task {task_id} is not an instance of PropertyTask\")\n    for b in task.blocks:\n        if b.id != block_id:\n            continue\n        for w in b.workflow:\n            if w.name == \"No Parameter Group\" and len(b.workflow) &gt; 1:\n                # hardcoded default workflow\n                continue\n            existing_workflow_id = w.id\n    if existing_workflow_id == workflow_id:\n        logger.info(f\"Block {block_id} already has workflow {workflow_id}\")\n        return None\n    patch = [\n        {\n            \"data\": [\n                {\n                    \"operation\": \"update\",\n                    \"attribute\": \"workflow\",\n                    \"oldValue\": existing_workflow_id,\n                    \"newValue\": workflow_id,\n                    \"blockId\": block_id,\n                }\n            ],\n            \"id\": task_id,\n        }\n    ]\n    self.session.patch(url=url, json=patch)\n    return None\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskDataColumn","title":"TaskDataColumn","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"property_data/#albert.collections.property_data.TaskDataColumn.column_sequence","title":"column_sequence  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>column_sequence: str | None = Field(\n    default=None, alias=\"columnId\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskDataColumn.data_column_id","title":"data_column_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_column_id: DataColumnId = Field(alias='id')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyCreate","title":"TaskPropertyCreate","text":"<p>               Bases: <code>BaseResource</code></p> <p>Represents a task property to be created.</p> <p>This class is used to create new task properties. Users can use the <code>Workflowe.get_interval_id</code> method to find the correct interval given the names and setpoints of the parameters.</p> Notes <ul> <li>Users can use <code>Workflow.get_interval_id(parameter_values={\"name1\":\"value1\", \"name2\":\"value2\"})</code>   to find the correct interval given the names and setpoints of the parameters.</li> <li>Leave <code>trial_number</code> blank to create a new row/trial.</li> <li><code>visible_trial_number</code> can be used to set the relative row number, allowing you to pass multiple rows of data at once.</li> </ul> <p>Methods:</p> Name Description <code>set_visible_trial_number</code>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyCreate.data_column","title":"data_column  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_column: TaskDataColumn = Field(\n    ...,\n    alias=\"DataColumns\",\n    description=\"The data column associated with the task property.\",\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyCreate.data_template","title":"data_template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_template: SerializeAsEntityLink[DataTemplate] = Field(\n    ...,\n    alias=\"DataTemplate\",\n    description=\"The data template associated with the task property.\",\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyCreate.entity","title":"entity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entity: Literal[TASK] = Field(\n    default=TASK,\n    description=\"The entity type, which is always `DataEntity.TASK` for task properties.\",\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyCreate.interval_combination","title":"interval_combination  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interval_combination: str = Field(\n    alias=\"intervalCombination\",\n    examples=[\"default\", \"ROW4XROW2\", \"ROW2\"],\n    default=\"default\",\n    description=\"The interval combination, which can be found using `Workflow.get_interval_id`.\",\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyCreate.trial_number","title":"trial_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trial_number: int = Field(\n    alias=\"trialNo\",\n    default=None,\n    description=\"The trial number/ row number. Leave blank to create a new row/trial.\",\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyCreate.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str | None = Field(\n    default=None,\n    description=\"The value of the task property.\",\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyCreate.visible_trial_number","title":"visible_trial_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible_trial_number: int | None = Field(\n    alias=\"visibleTrialNo\",\n    default=None,\n    description=\"Can be used to set the relative row number, allowing you to pass multiple rows of data at once.\",\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyCreate.set_visible_trial_number","title":"set_visible_trial_number","text":"<pre><code>set_visible_trial_number() -&gt; TaskPropertyCreate\n</code></pre> Source code in <code>src/albert/resources/property_data.py</code> <pre><code>@model_validator(mode=\"after\")\ndef set_visible_trial_number(self) -&gt; \"TaskPropertyCreate\":\n    if self.visible_trial_number is None:\n        if self.trial_number is not None:\n            self.visible_trial_number = self.trial_number\n        else:\n            self.visible_trial_number = \"1\"\n    return self\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyData","title":"TaskPropertyData","text":"<p>               Bases: <code>BaseResource</code></p>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyData.block_id","title":"block_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block_id: str | None = Field(alias='blockId', default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyData.category","title":"category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category: DataEntity | None = Field(default=None)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyData.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: list[DataInterval] = Field(\n    alias=\"Data\", frozen=True, exclude=True\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyData.data_template","title":"data_template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_template: (\n    SerializeAsEntityLink[DataTemplate] | None\n) = Field(default=None, alias=\"DataTemplate\")\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyData.entity","title":"entity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entity: Literal[TASK] = TASK\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyData.finial_workflow","title":"finial_workflow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>finial_workflow: SerializeAsEntityLink[Workflow] | None = (\n    Field(default=None, alias=\"FinalWorkflow\")\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyData.initial_workflow","title":"initial_workflow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_workflow: SerializeAsEntityLink[Workflow] | None = (\n    Field(default=None, alias=\"InitialWorkflow\")\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyData.inventory","title":"inventory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory: InventoryInformation | None = Field(\n    default=None, alias=\"Inventory\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyData.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: str = Field(..., alias='parentId')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.TaskPropertyData.task_id","title":"task_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task_id: str | None = Field(default=None, alias='id')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.Trial","title":"Trial","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"property_data/#albert.collections.property_data.Trial.data_columns","title":"data_columns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data_columns: list[PropertyValue] = Field(\n    default_factory=list, alias=\"DataColumns\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.Trial.trial_number","title":"trial_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trial_number: int = Field(alias='trialNo')\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.Trial.visible_trial_number","title":"visible_trial_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>visible_trial_number: int = Field(\n    default=1, alias=\"visibleTrialNo\"\n)\n</code></pre>"},{"location":"property_data/#albert.collections.property_data.Trial.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void: bool = Field(default=False)\n</code></pre>"},{"location":"reports/","title":"Reports","text":""},{"location":"reports/#albert.collections.reports.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"reports/#albert.collections.reports.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"reports/#albert.collections.reports.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"reports/#albert.collections.reports.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"reports/#albert.collections.reports.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"reports/#albert.collections.reports.ReportCollection","title":"ReportCollection","text":"<pre><code>ReportCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>ReportCollection is a collection class for managing Report entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>get_datascience_report</code> <p>Get a datascience report by its report type ID.</p> Source code in <code>src/albert/collections/reports.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the ReportCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{ReportCollection._api_version}/reports\"\n</code></pre>"},{"location":"reports/#albert.collections.reports.ReportCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/reports'\n</code></pre>"},{"location":"reports/#albert.collections.reports.ReportCollection.get_datascience_report","title":"get_datascience_report","text":"<pre><code>get_datascience_report(\n    *,\n    report_type_id: str,\n    input_data: dict[str, Any] | None = None,\n) -&gt; ReportInfo\n</code></pre> <p>Get a datascience report by its report type ID.</p> <p>Parameters:</p> Name Type Description Default <code>report_type_id</code> <code>str</code> <p>The report type ID for the report.</p> required <code>input_data</code> <code>dict[str, Any] | None</code> <p>Additional input data for generating the report (e.g., project IDs and unique IDs).</p> <code>None</code> <p>Returns:</p> Type Description <code>ReportInfo</code> <p>The info for the report.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; report = client.reports.get_datascience_report(\n...     report_type_id=\"RET51\",\n...     input_data={\n...         \"projectId\": [\"PRO123\"],\n...         \"uniqueId\": [\"DAT123_DAC123\"]\n...     }\n... )\n</code></pre> Source code in <code>src/albert/collections/reports.py</code> <pre><code>def get_datascience_report(\n    self,\n    *,\n    report_type_id: str,\n    input_data: dict[str, Any] | None = None,\n) -&gt; ReportInfo:\n    \"\"\"Get a datascience report by its report type ID.\n\n    Parameters\n    ----------\n    report_type_id : str\n        The report type ID for the report.\n    input_data : dict[str, Any] | None\n        Additional input data for generating the report\n        (e.g., project IDs and unique IDs).\n\n    Returns\n    -------\n    ReportInfo\n        The info for the report.\n\n    Examples\n    --------\n    &gt;&gt;&gt; report = client.reports.get_datascience_report(\n    ...     report_type_id=\"RET51\",\n    ...     input_data={\n    ...         \"projectId\": [\"PRO123\"],\n    ...         \"uniqueId\": [\"DAT123_DAC123\"]\n    ...     }\n    ... )\n    \"\"\"\n    path = f\"{self.base_path}/datascience/{report_type_id}\"\n\n    params = {}\n    input_data = input_data or {}\n    for key, value in input_data.items():\n        params[f\"inputData[{key}]\"] = value\n\n    response = self.session.get(path, params=params)\n    return ReportInfo(**response.json())\n</code></pre>"},{"location":"reports/#albert.collections.reports.ReportInfo","title":"ReportInfo","text":"<p>               Bases: <code>BaseResource</code></p>"},{"location":"reports/#albert.collections.reports.ReportInfo.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: str\n</code></pre>"},{"location":"reports/#albert.collections.reports.ReportInfo.items","title":"items  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>items: list[ReportItem] = Field(..., alias='Items')\n</code></pre>"},{"location":"reports/#albert.collections.reports.ReportInfo.report_type","title":"report_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>report_type: str = Field(..., alias='reportType')\n</code></pre>"},{"location":"reports/#albert.collections.reports.ReportInfo.report_type_id","title":"report_type_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>report_type_id: str = Field(..., alias='reportTypeId')\n</code></pre>"},{"location":"roles/","title":"Roles","text":""},{"location":"roles/#albert.collections.roles.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"roles/#albert.collections.roles.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"roles/#albert.collections.roles.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"roles/#albert.collections.roles.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"roles/#albert.collections.roles.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"roles/#albert.collections.roles.Role","title":"Role","text":"<p>               Bases: <code>BaseResource</code></p> <p>A role in Albert. Note: Roles are not currently creatable via the SDK.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the role.</p> <code>id</code> <code>str</code> <p>The Albert ID of the role. Set when the role is retrieved from Albert.</p> <code>policies</code> <code>list[Any] | None</code> <p>The policies associated with the role.</p> <code>tenant</code> <code>str</code> <p>The tenant ID of the role.</p>"},{"location":"roles/#albert.collections.roles.Role.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(alias='albertId')\n</code></pre>"},{"location":"roles/#albert.collections.roles.Role.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"roles/#albert.collections.roles.Role.policies","title":"policies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>policies: list[Any] | None = Field(default=None)\n</code></pre>"},{"location":"roles/#albert.collections.roles.Role.tenant","title":"tenant  <code>instance-attribute</code>","text":"<pre><code>tenant: str\n</code></pre>"},{"location":"roles/#albert.collections.roles.RoleCollection","title":"RoleCollection","text":"<pre><code>RoleCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>RoleCollection is a collection class for managing Role entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>list</code> <p>Lists the available Roles</p> Source code in <code>src/albert/collections/roles.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the RoleCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{RoleCollection._api_version}/acl/roles\"\n</code></pre>"},{"location":"roles/#albert.collections.roles.RoleCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/acl/roles'\n</code></pre>"},{"location":"roles/#albert.collections.roles.RoleCollection.list","title":"list","text":"<pre><code>list(*, params: dict | None = None) -&gt; list[Role]\n</code></pre> <p>Lists the available Roles</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>description, by default {}</p> <code>None</code> <p>Returns:</p> Type Description <code>List</code> <p>List of available Roles</p> Source code in <code>src/albert/collections/roles.py</code> <pre><code>def list(self, *, params: dict | None = None) -&gt; list[Role]:\n    \"\"\"Lists the available Roles\n\n    Parameters\n    ----------\n    params : dict, optional\n        _description_, by default {}\n\n    Returns\n    -------\n    List\n        List of available Roles\n    \"\"\"\n    if params is None:\n        params = {}\n    response = self.session.get(self.base_path, params=params)\n    role_data = response.json().get(\"Items\", [])\n    return [Role(**r) for r in role_data]\n</code></pre>"},{"location":"sheets/","title":"Sheets","text":""},{"location":"sheets/#albert.resources.sheets.AlbertException","title":"AlbertException","text":"<pre><code>AlbertException(message: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, message: str):\n    super().__init__(message)\n    self.message = message\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.AlbertException.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.BaseResource","title":"BaseResource","text":"<p>               Bases: <code>BaseAlbertModel</code></p> <p>The base resource for all Albert resources.</p> <p>Attributes:</p> Name Type Description <code>status</code> <code>Status | None</code> <p>The status of the resource, optional.</p> <code>created</code> <code>AuditFields | None</code> <p>Audit fields for the creation of the resource, optional.</p> <code>updated</code> <code>AuditFields | None</code> <p>Audit fields for the update of the resource, optional.</p> <p>Methods:</p> Name Description <code>to_entity_link</code>"},{"location":"sheets/#albert.resources.sheets.BaseResource.created","title":"created  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created: AuditFields | None = Field(\n    default=None, alias=\"Created\", exclude=True, frozen=True\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.BaseResource.status","title":"status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status: Status | None = Field(default=None)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.BaseResource.updated","title":"updated  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>updated: AuditFields | None = Field(\n    default=None, alias=\"Updated\", exclude=True, frozen=True\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.BaseResource.to_entity_link","title":"to_entity_link","text":"<pre><code>to_entity_link() -&gt; EntityLink\n</code></pre> Source code in <code>src/albert/resources/base.py</code> <pre><code>def to_entity_link(self) -&gt; EntityLink:\n    if id := getattr(self, \"id\", None):\n        return EntityLink(id=id)\n    raise AlbertException(\n        \"A non-null 'id' is required to create an entity link. \"\n        \"Ensure the linked object is registered and has a valid 'id'.\"\n    )\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.BaseSessionResource","title":"BaseSessionResource","text":"<pre><code>BaseSessionResource(**data)\n</code></pre> <p>               Bases: <code>BaseResource</code></p> Source code in <code>src/albert/resources/base.py</code> <pre><code>def __init__(self, **data):\n    super().__init__(**data)\n    self._session = data.get(\"session\")\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.BaseSessionResource.session","title":"session  <code>property</code>","text":"<pre><code>session: AlbertSession | None\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Cell","title":"Cell","text":"<p>               Bases: <code>BaseResource</code></p> <p>A Cell in a Sheet</p> <p>Attributes:</p> Name Type Description <code>column_id</code> <code>str</code> <p>The column ID of the cell.</p> <code>row_id</code> <code>str</code> <p>The row ID of the cell.</p> <code>value</code> <code>str | dict</code> <p>The value of the cell. If the cell is an inventory item, this will be a dict.</p> <code>type</code> <code>CellType</code> <p>The type of the cell. Allowed values are <code>INV</code>, <code>APP</code>, <code>BLK</code>, <code>Formula</code>, <code>TAG</code>, <code>PRC</code>, <code>PDC</code>, <code>BAT</code>, <code>TOT</code>, <code>TAS</code>, <code>DEF</code>, <code>LKP</code>, <code>FOR</code>, and <code>EXTINV</code>.</p> <code>name</code> <code>str | None</code> <p>The name of the cell. Optional. Default is None.</p> <code>calculation</code> <code>str</code> <p>The calculation of the cell. Optional. Default is \"\".</p> <code>design_id</code> <code>str</code> <p>The design ID of the design this cell is in.</p> <code>format</code> <code>dict</code> <p>The format of the cell. Optional. Default is {}. The format is a dict with the keys <code>bgColor</code> and <code>fontColor</code>. The values are strings in the format <code>RGB(255, 255, 255)</code>.</p> <code>raw_value</code> <code>str</code> <p>The raw value of the cell. If the cell is an inventory item, this will be the value of the inventory item. Read-only.</p> <code>color</code> <code>str | None</code> <p>The color of the cell. Read only.</p>"},{"location":"sheets/#albert.resources.sheets.Cell.calculation","title":"calculation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calculation: str = ''\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Cell.color","title":"color  <code>property</code>","text":"<pre><code>color\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Cell.column_id","title":"column_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>column_id: str = Field(alias='colId')\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Cell.design_id","title":"design_id  <code>instance-attribute</code>","text":"<pre><code>design_id: str\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Cell.format","title":"format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>format: dict = Field(\n    default_factory=dict, alias=\"cellFormat\"\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Cell.inventory_id","title":"inventory_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_id: str | None = Field(default=None)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Cell.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = Field(default=None)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Cell.raw_value","title":"raw_value  <code>property</code>","text":"<pre><code>raw_value\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Cell.row_id","title":"row_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>row_id: str = Field(alias='rowId')\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Cell.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: CellType\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Cell.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str | dict = ''\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellColor","title":"CellColor","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The allowed colors for a cell</p>"},{"location":"sheets/#albert.resources.sheets.CellColor.BLUE","title":"BLUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLUE = 'RGB(214, 233, 255)'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellColor.GREEN","title":"GREEN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GREEN = 'RGB(130, 222, 198)'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellColor.ORANGE","title":"ORANGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ORANGE = 'RGB(255, 227, 210)'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellColor.PURPLE","title":"PURPLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PURPLE = 'RGB(238, 215, 255)'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellColor.RED","title":"RED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RED = 'RGB(255, 161, 161)'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellColor.WHITE","title":"WHITE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WHITE = 'RGB(255, 255, 255)'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellColor.YELLOW","title":"YELLOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>YELLOW = 'RGB(254, 240, 159)'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType","title":"CellType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of information in the Cell</p>"},{"location":"sheets/#albert.resources.sheets.CellType.APP","title":"APP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>APP = 'APP'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.BAT","title":"BAT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BAT = 'BAT'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.BLANK","title":"BLANK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLANK = 'BLK'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.BTI","title":"BTI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BTI = 'BTI'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.DEF","title":"DEF  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEF = 'DEF'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.EXTINV","title":"EXTINV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXTINV = 'EXTINV'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.FOR","title":"FOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOR = 'FOR'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.FORMULA","title":"FORMULA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FORMULA = 'Formula'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.INVENTORY","title":"INVENTORY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INVENTORY = 'INV'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.LKP","title":"LKP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LKP = 'LKP'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.PDC","title":"PDC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PDC = 'PDC'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.PRICE","title":"PRICE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRICE = 'PRC'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.TAG","title":"TAG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAG = 'TAG'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.TAS","title":"TAS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAS = 'TAS'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.CellType.TOTAL","title":"TOTAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOTAL = 'TOT'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Column","title":"Column","text":"<pre><code>Column(**data)\n</code></pre> <p>               Bases: <code>BaseSessionResource</code></p> <p>A column in a Sheet</p> <p>Attributes:</p> Name Type Description <code>column_id</code> <code>str</code> <p>The column ID of the column.</p> <code>name</code> <code>str | None</code> <p>The name of the column. Optional. Default is None.</p> <code>type</code> <code>CellType</code> <p>The type of the column. Allowed values are <code>INV</code>, <code>APP</code>, <code>BLK</code>, <code>Formula</code>, <code>TAG</code>, <code>PRC</code>, <code>PDC</code>, <code>BAT</code>, <code>TOT</code>, <code>TAS</code>, <code>DEF</code>, <code>LKP</code>, <code>FOR</code>, and <code>EXTINV</code>.</p> <code>sheet</code> <code>Sheet</code> <p>The sheet the column is in.</p> <code>cells</code> <code>list[Cell]</code> <p>The cells in the column. Read-only.</p> <code>df_name</code> <code>str</code> <p>The name of the column in the DataFrame. Read-only</p> <p>Methods:</p> Name Description <code>recolor_cells</code> <code>rename</code> Source code in <code>src/albert/resources/base.py</code> <pre><code>def __init__(self, **data):\n    super().__init__(**data)\n    self._session = data.get(\"session\")\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Column.cells","title":"cells  <code>property</code>","text":"<pre><code>cells: list[Cell]\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Column.column_id","title":"column_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>column_id: str = Field(alias='colId')\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Column.df_name","title":"df_name  <code>property</code>","text":"<pre><code>df_name\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Column.inventory_id","title":"inventory_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_id: str | None = Field(default=None, exclude=True)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Column.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = Field(default=None)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Column.sheet","title":"sheet  <code>instance-attribute</code>","text":"<pre><code>sheet: Sheet\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Column.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: CellType\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Column.recolor_cells","title":"recolor_cells","text":"<pre><code>recolor_cells(color: CellColor)\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def recolor_cells(self, color: CellColor):\n    new_cells = []\n    for c in self.cells:\n        cell_copy = c.model_copy(update={\"format\": {\"bgColor\": color.value}})\n        new_cells.append(cell_copy)\n    return self.sheet.update_cells(cells=new_cells)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Column.rename","title":"rename","text":"<pre><code>rename(new_name)\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def rename(self, new_name):\n    payload = {\n        \"data\": [\n            {\n                \"operation\": \"update\",\n                \"attribute\": \"name\",\n                \"colId\": self.column_id,\n                \"oldValue\": self.name,\n                \"newValue\": new_name,\n            }\n        ]\n    }\n\n    self.session.patch(\n        url=f\"/api/v3/worksheet/sheet/{self.sheet.id}/columns\",\n        json=payload,\n    )\n\n    if self.sheet._grid is not None:  # if I have a grid loaded into memory, adjust it.\n        self.sheet.grid = None\n        # self.sheet._grid.rename(axis=1, mapper={self.name:new_name})\n    self.name = new_name\n    return self\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Component","title":"Component","text":"<p>               Bases: <code>BaseResource</code></p> <p>Represents an amount of an inventory item in a formulation</p> <p>Attributes:</p> Name Type Description <code>inventory_item</code> <code>InventoryItem</code> <p>The inventory item in the component</p> <code>amount</code> <code>float</code> <p>The amount of the inventory item in the component</p> <code>cell</code> <code>Cell</code> <p>The cell that the component is in. Read-only.</p>"},{"location":"sheets/#albert.resources.sheets.Component.amount","title":"amount  <code>instance-attribute</code>","text":"<pre><code>amount: float\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Component.cell","title":"cell  <code>property</code>","text":"<pre><code>cell\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Component.inventory_item","title":"inventory_item  <code>instance-attribute</code>","text":"<pre><code>inventory_item: InventoryItem\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Design","title":"Design","text":"<pre><code>Design(**data)\n</code></pre> <p>               Bases: <code>BaseSessionResource</code></p> <p>A Design in a Sheet. Designs are sheet subsections that are largly abstracted away from the user.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The Albert ID of the design.</p> <code>design_type</code> <code>DesignType</code> <p>The type of the design. Allowed values are <code>apps</code>, <code>products</code>, and <code>results</code>.</p> <code>state</code> <code>DesignState | None</code> <p>The state of the design. Optional. Default is None.</p> <code>grid</code> <code>DataFrame | None</code> <p>The grid of the design. Optional. Default is None. Read-only.</p> <code>rows</code> <code>list[Row] | None</code> <p>The rows of the design. Optional. Default is None. Read-only.</p> <code>columns</code> <code>list[Column] | None</code> <p>The columns of the design. Optional. Default is None. Read-only.</p> Source code in <code>src/albert/resources/base.py</code> <pre><code>def __init__(self, **data):\n    super().__init__(**data)\n    self._session = data.get(\"session\")\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Design.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: list[Column]\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Design.design_type","title":"design_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>design_type: DesignType = Field(alias='designType')\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Design.grid","title":"grid  <code>property</code>","text":"<pre><code>grid\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Design.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(alias='albertId')\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Design.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: list[Row]\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Design.sheet","title":"sheet  <code>property</code>","text":"<pre><code>sheet\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Design.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: DesignState | None = Field({})\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.DesignState","title":"DesignState","text":"<p>               Bases: <code>BaseResource</code></p> <p>The state of a Design</p>"},{"location":"sheets/#albert.resources.sheets.DesignState.collapsed","title":"collapsed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>collapsed: bool | None = False\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.DesignType","title":"DesignType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The type of Design</p>"},{"location":"sheets/#albert.resources.sheets.DesignType.APPS","title":"APPS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>APPS = 'apps'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.DesignType.PRODUCTS","title":"PRODUCTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRODUCTS = 'products'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.DesignType.RESULTS","title":"RESULTS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESULTS = 'results'\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem","title":"InventoryItem","text":"<p>               Bases: <code>BaseTaggedEntity</code></p> <p>An InventoryItem is a Pydantic model representing an item in the inventory. Can be a raw material, consumable, equipment, or formula. Note: Formulas should be registered via the Worksheet collection / Sheet resource.</p> <p>Returns:</p> Type Description <code>InventoryItem</code> <p>An InventoryItem that can be used to represent an item in the inventory. Can be a raw material, consumable, equipment, or formula.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the InventoryItem.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the InventoryItem. Set when the InventoryItem is retrieved from Albert.</p> <code>description</code> <code>str | None</code> <p>The description of the InventoryItem.</p> <code>category</code> <code>InventoryCategory</code> <p>The category of the InventoryItem. Allowed values are <code>RawMaterials</code>, <code>Consumables</code>, <code>Equipment</code>, and <code>Formulas</code>.</p> <code>unit_category</code> <code>InventoryUnitCategory</code> <p>The unit category of the InventoryItem. Can be mass, volume, length, pressure, or units. By default, mass is used for RawMaterials and Formulas, and units is used for Equipment and Consumables.</p> <code>security_class</code> <code>SecurityClass | None</code> <p>The security class of the InventoryItem. Optional. Can be confidential, shared, or restricted.</p> <code>company</code> <code>Company | str | None</code> <p>The company associated with the InventoryItem. Can be a Company object or a string. If a String is provided, a Company object with the name of the provided string will be first-or-created.</p> <code>minimum</code> <code>list[InventoryMinimum] | None</code> <p>The minimum amount of the InventoryItem that must be kept in stock at a given Location. Optional.</p> <code>alias</code> <code>str | None</code> <p>An alias for the InventoryItem. Optional.</p> <code>cas</code> <code>list[CasAmount] | None</code> <p>The CAS numbers associated with the InventoryItem. This is how a compositional breakdown can be provided. Optional.</p> <code>metadata</code> <code>dict[str, str | list[EntityLink] | EntityLink] | None</code> <p>Metadata associated with the InventoryItem. Optional. Allowed metadata fields can be found in the CustomFields documentation.</p> <code>project_id</code> <code>str | None</code> <p>The project ID associated with the InventoryItem. Read Only. Required for Formulas.</p> <code>formula_id</code> <code>str | None</code> <p>The formula ID associated with the InventoryItem. Read Only.</p> <code>tags</code> <code>list[str | Tag] | None</code> <p>The tags associated with the InventoryItem. Optional. If a string is provided, a Tag object with the name of the provided string will be first-or-created.</p> <p>Methods:</p> Name Description <code>set_unit_category</code> <p>Set unit category from category if not defined.</p> <code>validate_company_string</code> <code>validate_formula_fields</code> <p>Ensure required fields are present for formulas.</p> <code>validate_un_number</code>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.acls","title":"acls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acls: list[ACL] = Field(default_factory=list, alias='ACL')\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.alias","title":"alias  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alias: str | None = Field(default=None)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.cas","title":"cas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cas: list[CasAmount] | None = Field(\n    default=None, alias=\"Cas\"\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: InventoryCategory\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.company","title":"company  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>company: SerializeAsEntityLink[Company] | None = Field(\n    default=None, alias=\"Company\"\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.formula_id","title":"formula_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>formula_id: str | None = Field(\n    default=None,\n    alias=\"formulaId\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(None, alias='albertId')\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] | None = Field(\n    alias=\"Metadata\", default=None\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.minimum","title":"minimum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>minimum: list[InventoryMinimum] | None = Field(default=None)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = None\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.project_id","title":"project_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>project_id: str | None = Field(\n    default=None, alias=\"parentId\"\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.recent_atachment_id","title":"recent_atachment_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>recent_atachment_id: str | None = Field(\n    default=None,\n    alias=\"recentAttachmentId\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.security_class","title":"security_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>security_class: SecurityClass | None = Field(\n    default=None, alias=\"class\"\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.symbols","title":"symbols  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbols: list[dict] | None = Field(\n    default=None, alias=\"Symbols\", exclude=True, frozen=True\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.task_config","title":"task_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task_config: list[dict] | None = Field(\n    default=None,\n    alias=\"TaskConfig\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.un_number","title":"un_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>un_number: str | None = Field(\n    default=None,\n    alias=\"unNumber\",\n    exclude=True,\n    frozen=True,\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.unit_category","title":"unit_category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit_category: InventoryUnitCategory | None = Field(\n    default=None, alias=\"unitCategory\"\n)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.set_unit_category","title":"set_unit_category","text":"<pre><code>set_unit_category() -&gt; InventoryItem\n</code></pre> <p>Set unit category from category if not defined.</p> Source code in <code>src/albert/resources/inventory.py</code> <pre><code>@model_validator(mode=\"after\")\ndef set_unit_category(self) -&gt; \"InventoryItem\":\n    \"\"\"Set unit category from category if not defined.\"\"\"\n    if self.unit_category is None:\n        if self.category in [InventoryCategory.RAW_MATERIALS, InventoryCategory.FORMULAS]:\n            object.__setattr__(self, \"unit_category\", InventoryUnitCategory.MASS)\n        elif self.category in [InventoryCategory.EQUIPMENT, InventoryCategory.CONSUMABLES]:\n            object.__setattr__(self, \"unit_category\", InventoryUnitCategory.UNITS)\n    return self\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.validate_company_string","title":"validate_company_string  <code>classmethod</code>","text":"<pre><code>validate_company_string(value: Any) -&gt; Any\n</code></pre> Source code in <code>src/albert/resources/inventory.py</code> <pre><code>@field_validator(\"company\", mode=\"before\")\n@classmethod\ndef validate_company_string(cls, value: Any) -&gt; Any:\n    if isinstance(value, str):\n        value = Company(name=value)\n    return value\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.validate_formula_fields","title":"validate_formula_fields","text":"<pre><code>validate_formula_fields() -&gt; InventoryItem\n</code></pre> <p>Ensure required fields are present for formulas.</p> Source code in <code>src/albert/resources/inventory.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_formula_fields(self) -&gt; \"InventoryItem\":\n    \"\"\"Ensure required fields are present for formulas.\"\"\"\n    if self.category == InventoryCategory.FORMULAS and not self.project_id and not self.id:\n        # Some legacy on platform formulas don't have a project_id so check if its already on platform\n        raise ValueError(\"A project_id must be supplied for all formulas.\")\n    return self\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.InventoryItem.validate_un_number","title":"validate_un_number  <code>classmethod</code>","text":"<pre><code>validate_un_number(value: Any) -&gt; Any\n</code></pre> Source code in <code>src/albert/resources/inventory.py</code> <pre><code>@field_validator(\"un_number\", mode=\"before\")\n@classmethod\ndef validate_un_number(cls, value: Any) -&gt; Any:\n    if value == \"N/A\":\n        value = None\n    return value\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Row","title":"Row","text":"<pre><code>Row(**data)\n</code></pre> <p>               Bases: <code>BaseSessionResource</code></p> <p>A row in a Sheet</p> <p>Attributes:</p> Name Type Description <code>row_id</code> <code>str</code> <p>The row ID of the row.</p> <code>type</code> <code>CellType</code> <p>The type of the row. Allowed values are <code>INV</code>, <code>APP</code>, <code>BLK</code>, <code>Formula</code>, <code>TAG</code>, <code>PRC</code>, <code>PDC</code>, <code>BAT</code>, <code>TOT</code>, <code>TAS</code>, <code>DEF</code>, <code>LKP</code>, <code>FOR</code>, and <code>EXTINV</code>.</p> <code>design</code> <code>Design</code> <p>The design the row is in.</p> <code>sheet</code> <code>Sheet</code> <p>The sheet the row is in.</p> <code>name</code> <code>str | None</code> <p>The name of the row. Optional. Default is None.</p> <code>inventory_id</code> <code>str | None</code> <p>The inventory ID of the row. Optional. Default is None.</p> <code>manufacturer</code> <code>str | None</code> <p>The manufacturer of the row. Optional. Default is None.</p> <code>row_unique_id</code> <code>str</code> <p>The unique ID of the row. Read-only.</p> <code>cells</code> <code>list[Cell]</code> <p>The cells in the row. Read-only.</p> <p>Methods:</p> Name Description <code>recolor_cells</code> Source code in <code>src/albert/resources/base.py</code> <pre><code>def __init__(self, **data):\n    super().__init__(**data)\n    self._session = data.get(\"session\")\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Row.cells","title":"cells  <code>property</code>","text":"<pre><code>cells: list[Cell]\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Row.design","title":"design  <code>instance-attribute</code>","text":"<pre><code>design: Design\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Row.inventory_id","title":"inventory_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_id: str | None = Field(default=None, alias='id')\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Row.manufacturer","title":"manufacturer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>manufacturer: str | None = Field(default=None)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Row.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = Field(default=None)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Row.row_id","title":"row_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>row_id: str = Field(alias='rowId')\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Row.row_unique_id","title":"row_unique_id  <code>property</code>","text":"<pre><code>row_unique_id\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Row.sheet","title":"sheet  <code>instance-attribute</code>","text":"<pre><code>sheet: Sheet\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Row.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: CellType\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Row.recolor_cells","title":"recolor_cells","text":"<pre><code>recolor_cells(color: CellColor)\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def recolor_cells(self, color: CellColor):\n    new_cells = []\n    for c in self.cells:\n        cell_copy = c.model_copy(update={\"format\": {\"bgColor\": color.value}})\n        cell_copy.format = {\"bgColor\": color.value}\n        new_cells.append(cell_copy)\n    return self.sheet.update_cells(cells=new_cells)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet","title":"Sheet","text":"<pre><code>Sheet(**data)\n</code></pre> <p>               Bases: <code>BaseSessionResource</code></p> <p>A Sheet in Albert</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The Albert ID of the sheet.</p> <code>name</code> <code>str</code> <p>The name of the sheet.</p> <code>hidden</code> <code>bool</code> <p>Whether the sheet is hidden.</p> <code>designs</code> <code>list[Design]</code> <p>The designs of the sheet.</p> <code>project_id</code> <code>str</code> <p>The Albert ID of the project the sheet is in.</p> <code>grid</code> <code>DataFrame | None</code> <p>The grid of the sheet. Optional. Default is None. Read-only.</p> <code>columns</code> <code>list[Column]</code> <p>The columns of the sheet. Read-only.</p> <code>rows</code> <code>list[Row]</code> <p>The rows of the sheet. Read-only.</p> <p>Methods:</p> Name Description <code>add_blank_column</code> <code>add_blank_row</code> <code>add_formulation</code> <code>add_formulation_columns</code> <code>add_inventory_row</code> <code>delete_column</code> <code>delete_row</code> <code>get_column</code> <code>rename</code> <code>set_session</code> <code>set_sheet_fields</code> <code>update_cells</code> Source code in <code>src/albert/resources/base.py</code> <pre><code>def __init__(self, **data):\n    super().__init__(**data)\n    self._session = data.get(\"session\")\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.app_design","title":"app_design  <code>property</code>","text":"<pre><code>app_design\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: list[Column]\n</code></pre> <p>The columns of a given sheet</p>"},{"location":"sheets/#albert.resources.sheets.Sheet.designs","title":"designs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>designs: list[Design] = Field(alias='Designs')\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.grid","title":"grid  <code>property</code> <code>writable</code>","text":"<pre><code>grid\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.hidden","title":"hidden  <code>instance-attribute</code>","text":"<pre><code>hidden: bool\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(alias='albertId')\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.leftmost_pinned_column","title":"leftmost_pinned_column  <code>property</code>","text":"<pre><code>leftmost_pinned_column\n</code></pre> <p>The leftmost pinned column in the sheet</p>"},{"location":"sheets/#albert.resources.sheets.Sheet.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.product_design","title":"product_design  <code>property</code>","text":"<pre><code>product_design\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.project_id","title":"project_id  <code>instance-attribute</code>","text":"<pre><code>project_id: str\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.result_design","title":"result_design  <code>property</code>","text":"<pre><code>result_design\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.rows","title":"rows  <code>property</code>","text":"<pre><code>rows: list[Row]\n</code></pre> <p>The rows of a given sheet</p>"},{"location":"sheets/#albert.resources.sheets.Sheet.add_blank_column","title":"add_blank_column","text":"<pre><code>add_blank_column(*, name: str, position: dict = None)\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def add_blank_column(self, *, name: str, position: dict = None):\n    if position is None:\n        position = {\"reference_id\": self.leftmost_pinned_column, \"position\": \"rightOf\"}\n    endpoint = f\"/api/v3/worksheet/sheet/{self.id}/columns\"\n    payload = [\n        {\n            \"type\": \"BLK\",\n            \"name\": name,\n            \"referenceId\": position[\"reference_id\"],\n            \"position\": position[\"position\"],\n        }\n    ]\n\n    response = self.session.post(endpoint, json=payload)\n\n    data = response.json()\n    data[0][\"sheet\"] = self\n    data[0][\"session\"] = self.session\n    self.grid = None  # reset the known grid. We could probably make this nicer later.\n    return Column(**data[0])\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.add_blank_row","title":"add_blank_row","text":"<pre><code>add_blank_row(\n    *,\n    row_name: str,\n    design: DesignType | str | None = PRODUCTS,\n    position: dict | None = None,\n)\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def add_blank_row(\n    self,\n    *,\n    row_name: str,\n    design: DesignType | str | None = DesignType.PRODUCTS,\n    position: dict | None = None,\n):\n    if design == DesignType.RESULTS:\n        raise AlbertException(\"You cannot add rows to the results design\")\n    if position is None:\n        position = {\"reference_id\": \"ROW1\", \"position\": \"above\"}\n    endpoint = f\"/api/v3/worksheet/design/{self._get_design_id(design=design)}/rows\"\n\n    payload = [\n        {\n            \"type\": \"BLK\",\n            \"name\": row_name,\n            \"referenceId\": position[\"reference_id\"],\n            \"position\": position[\"position\"],\n        }\n    ]\n\n    response = self.session.post(endpoint, json=payload)\n\n    self.grid = None\n    row_dict = response.json()[0]\n    return Row(\n        rowId=row_dict[\"rowId\"],\n        type=row_dict[\"type\"],\n        session=self.session,\n        design=self._get_design(design=design),\n        name=row_dict[\"name\"],\n        sheet=self,\n    )\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.add_formulation","title":"add_formulation","text":"<pre><code>add_formulation(\n    *,\n    formulation_name: str,\n    components: list[Component],\n    enforce_order: bool = False,\n) -&gt; Column\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def add_formulation(\n    self, *, formulation_name: str, components: list[Component], enforce_order: bool = False\n) -&gt; \"Column\":\n    existing_formulation_names = [x.name for x in self.columns]\n    if formulation_name not in existing_formulation_names:\n        col = self.add_formulation_columns(formulation_names=[formulation_name])[0]\n    else:\n        # get the existing column and clear it out to put the new formulation in\n        col = self.get_column(column_name=formulation_name)\n        self._clear_formulation_from_column(column=col)\n    col_id = col.column_id\n\n    all_cells = []\n    self.grid = None  # reset the grid for saftey\n\n    for component in components:\n        row_id = self._get_row_id_for_component(\n            inventory_item=component.inventory_item,\n            existing_cells=all_cells,\n            enforce_order=enforce_order,\n        )\n        if row_id is None:\n            raise AlbertException(f\"no component with id {component.inventory_item.id}\")\n        this_cell = Cell(\n            column_id=col_id,\n            row_id=row_id,\n            value=str(component.amount),\n            calculation=\"\",\n            type=CellType.INVENTORY,\n            design_id=self.product_design.id,\n            name=formulation_name,\n            inventory_id=col.inventory_id,\n        )\n        all_cells.append(this_cell)\n\n    self.update_cells(cells=all_cells)\n    return self.get_column(column_id=col_id)\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.add_formulation_columns","title":"add_formulation_columns","text":"<pre><code>add_formulation_columns(\n    *,\n    formulation_names: list[str],\n    starting_position: dict | None = None,\n) -&gt; list[Column]\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def add_formulation_columns(\n    self,\n    *,\n    formulation_names: list[str],\n    starting_position: dict | None = None,\n) -&gt; list[\"Column\"]:\n    if starting_position is None:\n        starting_position = {\n            \"reference_id\": self.leftmost_pinned_column,\n            \"position\": \"rightOf\",\n        }\n    sheet_id = self.id\n\n    endpoint = f\"/api/v3/worksheet/sheet/{sheet_id}/columns\"\n\n    # In case a user supplied a single formulation name instead of a list\n    formulation_names = (\n        formulation_names if isinstance(formulation_names, list) else [formulation_names]\n    )\n\n    payload = []\n    for formulation_name in (\n        formulation_names\n    ):  # IS there a limit to the number I can add at once? Need to check this.\n        # define payload for this item\n        payload.append(\n            {\n                \"type\": \"INV\",\n                \"name\": formulation_name,\n                \"referenceId\": starting_position[\"reference_id\"],  # initially defined column\n                \"position\": starting_position[\"position\"],\n            }\n        )\n    response = self.session.post(endpoint, json=payload)\n\n    self.grid = None\n    new_dicts = self._reformat_formulation_addition_payload(response_json=response.json())\n    return [Column(**x) for x in new_dicts]\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.add_inventory_row","title":"add_inventory_row","text":"<pre><code>add_inventory_row(\n    *, inventory_id: str, position: dict | None = None\n)\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def add_inventory_row(\n    self,\n    *,\n    inventory_id: str,\n    position: dict | None = None,\n):\n    if position is None:\n        position = {\"reference_id\": \"ROW1\", \"position\": \"above\"}\n    design_id = self.product_design.id\n    endpoint = f\"/api/v3/worksheet/design/{design_id}/rows\"\n\n    payload = {\n        \"type\": \"INV\",\n        \"id\": (\"INV\" + inventory_id if not inventory_id.startswith(\"INV\") else inventory_id),\n        \"referenceId\": position[\"reference_id\"],\n        \"position\": position[\"position\"],\n    }\n\n    response = self.session.post(endpoint, json=payload)\n\n    self.grid = None\n    row_dict = response.json()\n    return Row(\n        rowId=row_dict[\"rowId\"],\n        inventory_id=inventory_id,\n        type=row_dict[\"type\"],\n        session=self.session,\n        design=self.product_design,\n        sheet=self,\n        name=row_dict[\"name\"],\n        id=row_dict[\"id\"],\n        manufacturer=row_dict[\"manufacturer\"],\n    )\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.delete_column","title":"delete_column","text":"<pre><code>delete_column(*, column_id: str) -&gt; None\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def delete_column(self, *, column_id: str) -&gt; None:\n    endpoint = f\"/api/v3/worksheet/sheet/{self.id}/columns\"\n    payload = [{\"colId\": column_id}]\n    self.session.delete(endpoint, json=payload)\n\n    if self._grid is not None:  # if I have a grid loaded into memory, adjust it.\n        self.grid = None\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.delete_row","title":"delete_row","text":"<pre><code>delete_row(*, row_id: str, design_id: str) -&gt; None\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def delete_row(self, *, row_id: str, design_id: str) -&gt; None:\n    endpoint = f\"/api/v3/worksheet/design/{design_id}/rows\"\n    payload = [{\"rowId\": row_id}]\n    self.session.delete(endpoint, json=payload)\n\n    if self._grid is not None:  # if I have a grid loaded into memory, adjust it.\n        self.grid = None\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.get_column","title":"get_column","text":"<pre><code>get_column(\n    *,\n    column_id: None | str = None,\n    column_name: str | None = None,\n)\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def get_column(self, *, column_id: None | str = None, column_name: str | None = None):\n    if column_id is None and column_name is None:\n        raise AlbertException(\"Either a column name or id must be provided\")\n    else:\n        matching_series = self._find_column(column_id=column_id, column_name=column_name)\n        first_item = matching_series.iloc[0]\n        inv_id = first_item.inventory_id\n        if inv_id is not None and not inv_id.startswith(\"INV\"):\n            inv_id = \"INV\" + inv_id\n        return Column(\n            name=first_item.name,\n            colId=first_item.column_id,\n            type=first_item.type,\n            sheet=self,\n            session=self.session,\n            inventory_id=first_item.inventory_id,\n        )\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.rename","title":"rename","text":"<pre><code>rename(*, new_name: str)\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def rename(self, *, new_name: str):\n    endpoint = f\"/api/v3/worksheet/sheet/{self.id}\"\n\n    payload = [{\"attribute\": \"name\", \"operation\": \"update\", \"newValue\": new_name}]\n\n    self.session.patch(endpoint, json=payload)\n\n    self.name = new_name\n    return self\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.set_session","title":"set_session","text":"<pre><code>set_session()\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>@model_validator(mode=\"after\")\ndef set_session(self):\n    if self.session is not None:\n        for d in self.designs:\n            d._session = self.session\n    return self\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.set_sheet_fields","title":"set_sheet_fields","text":"<pre><code>set_sheet_fields() -&gt; Sheet\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>@model_validator(mode=\"after\")\ndef set_sheet_fields(self: \"Sheet\") -&gt; \"Sheet\":\n    for _idx, d in enumerate(self.designs):  # Instead of creating a new list\n        d._sheet = self  # Set the reference to the sheet\n        if d.design_type == DesignType.APPS:\n            self._app_design = d\n        elif d.design_type == DesignType.PRODUCTS:\n            self._product_design = d\n        elif d.design_type == DesignType.RESULTS:\n            self._result_design = d\n    return self\n</code></pre>"},{"location":"sheets/#albert.resources.sheets.Sheet.update_cells","title":"update_cells","text":"<pre><code>update_cells(*, cells: list[Cell])\n</code></pre> Source code in <code>src/albert/resources/sheets.py</code> <pre><code>def update_cells(self, *, cells: list[Cell]):\n    request_path_dict = {}\n    updated = []\n    failed = []\n    # sort by design ID\n    for c in cells:\n        if c.design_id not in request_path_dict:\n            request_path_dict[c.design_id] = [c]\n        else:\n            request_path_dict[c.design_id].append(c)\n\n    for design_id, cell_list in request_path_dict.items():\n        payload = []\n        for cell in cell_list:\n            change_dict = self._get_cell_changes(cell=cell)\n            if change_dict is not None:\n                payload.append(change_dict)\n\n        if payload == []:\n            continue\n\n        this_url = f\"/api/v3/worksheet/{design_id}/values\"\n        response = self.session.patch(\n            this_url,\n            json=payload,\n        )\n\n        if response.status_code == 204:\n            # They all updated\n            updated.extend(cell_list)\n        elif response.status_code == 206:\n            # Some updated and some did not.\n            cell_results = self._filter_cells(cells=cell_list, response_dict=response.json())\n            updated.extend(cell_results[0])\n            failed.extend(cell_results[1])\n    # reset the in-memory grid after updates\n    self.grid = None\n    return (updated, failed)\n</code></pre>"},{"location":"storage_locations/","title":"Storage Locations","text":""},{"location":"storage_locations/#albert.collections.storage_locations.AlbertHTTPError","title":"AlbertHTTPError","text":"<pre><code>AlbertHTTPError(response: Response)\n</code></pre> <p>               Bases: <code>AlbertException</code></p> <p>Base class for all erors due to HTTP responses.</p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, response: requests.Response):\n    message = self._format_message(response)\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.AlbertHTTPError.response","title":"response  <code>instance-attribute</code>","text":"<pre><code>response = response\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.EntityLink","title":"EntityLink","text":"<p>               Bases: <code>BaseAlbertModel</code></p> <p>Methods:</p> Name Description <code>to_entity_link</code>"},{"location":"storage_locations/#albert.collections.storage_locations.EntityLink.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.EntityLink.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = Field(default=None, exclude=True)\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.EntityLink.to_entity_link","title":"to_entity_link","text":"<pre><code>to_entity_link() -&gt; EntityLink\n</code></pre> Source code in <code>src/albert/resources/base.py</code> <pre><code>def to_entity_link(self) -&gt; \"EntityLink\":\n    # Convience method to return self, so you can call this method on objects that are already entity links\n    return self\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.Location","title":"Location","text":"<p>               Bases: <code>BaseResource</code></p> <p>A location in Albert.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the location.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the location. Set when the location is retrieved from Albert.</p> <code>latitude</code> <code>float</code> <p>The latitude of the location.</p> <code>longitude</code> <code>float</code> <p>The longitude of the location.</p> <code>address</code> <code>str</code> <p>The address of the location.</p> <code>country</code> <code>str | None</code> <p>The country code of the location. Must be two characters long.</p>"},{"location":"storage_locations/#albert.collections.storage_locations.Location.address","title":"address  <code>instance-attribute</code>","text":"<pre><code>address: str\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.Location.country","title":"country  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>country: str | None = Field(\n    None, max_length=2, min_length=2\n)\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.Location.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(None, alias='albertId')\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.Location.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = Field()\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.Location.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = Field()\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.Location.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.StorageLocation","title":"StorageLocation","text":"<p>               Bases: <code>BaseResource</code></p> <p>A storage location entity. For example, a specific flammables cabinet or a storage room.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the storage location.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the storage location. Set when the storage location is retrieved from Albert.</p> <code>location</code> <code>Location</code> <p>The location entity link of the storage location.</p>"},{"location":"storage_locations/#albert.collections.storage_locations.StorageLocation.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(alias='albertId', default=None)\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.StorageLocation.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: SerializeAsEntityLink[Location] = Field(\n    alias=\"Location\"\n)\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.StorageLocation.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(\n    alias=\"name\", min_length=2, max_length=255\n)\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.StorageLocationsCollection","title":"StorageLocationsCollection","text":"<pre><code>StorageLocationsCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>StorageLocationsCollection is a collection class for managing StorageLoction entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert Session information</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new storage location.</p> <code>delete</code> <p>Delete a storage location by its ID.</p> <code>get_by_id</code> <p>Get a storage location by its ID.</p> <code>list</code> <p>List storage locations with optional filtering.</p> <code>update</code> <p>Update a storage location.</p> Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initialize the StorageLocationsCollection.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert Session information\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{StorageLocationsCollection._api_version}/storagelocations\"\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.StorageLocationsCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/storagelocations'\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.StorageLocationsCollection.create","title":"create","text":"<pre><code>create(\n    *, storage_location: StorageLocation\n) -&gt; StorageLocation\n</code></pre> <p>Create a new storage location.</p> <p>Parameters:</p> Name Type Description Default <code>storage_location</code> <code>StorageLocation</code> <p>The storage location to create.</p> required <p>Returns:</p> Type Description <code>StorageLocation</code> <p>The created storage location.</p> Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def create(self, *, storage_location: StorageLocation) -&gt; StorageLocation:\n    \"\"\"Create a new storage location.\n\n    Parameters\n    ----------\n    storage_location : StorageLocation\n        The storage location to create.\n\n    Returns\n    -------\n    StorageLocation\n        The created storage location.\n    \"\"\"\n    matching = self.list(\n        name=storage_location.name, location=storage_location.location, exact_match=True\n    )\n    for m in matching:\n        if m.name.lower() == storage_location.name.lower():\n            logging.warning(\n                f\"Storage location with name {storage_location.name} already exists, returning existing.\"\n            )\n            return m\n\n    path = self.base_path\n    response = self.session.post(\n        path, json=storage_location.model_dump(by_alias=True, exclude_none=True, mode=\"json\")\n    )\n    return StorageLocation(**response.json())\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.StorageLocationsCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Delete a storage location by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the storage location to delete.</p> required Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"Delete a storage location by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the storage location to delete.\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    self.session.delete(path)\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.StorageLocationsCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; StorageLocation\n</code></pre> <p>Get a storage location by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the storage location to retrieve.</p> required <p>Returns:</p> Type Description <code>StorageLocation</code> <p>The retrieved storage location with the given ID.</p> Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; StorageLocation:\n    \"\"\"Get a storage location by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the storage location to retrieve.\n\n    Returns\n    -------\n    StorageLocation\n        The retrieved storage location with the given ID.\n    \"\"\"\n    path = f\"{self.base_path}/{id}\"\n    response = self.session.get(path)\n    return StorageLocation(**response.json())\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.StorageLocationsCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    name: str | list[str] | None = None,\n    exact_match: bool = False,\n    location: str | Location | None = None,\n    start_key: str | None = None,\n    limit: int = 50,\n) -&gt; Generator[StorageLocation, None, None]\n</code></pre> <p>List storage locations with optional filtering.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | list[str] | None</code> <p>The name or names of the storage locations to filter by, by default None</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to perform an exact match on the name, by default False</p> <code>False</code> <code>location</code> <code>str | Location | None</code> <p>The location ID or Location object to filter by, by default None</p> <code>None</code> <p>Yields:</p> Type Description <code>Generator[StorageLocation, None, None]</code> <p>description</p> Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def list(\n    self,\n    *,\n    name: str | list[str] | None = None,\n    exact_match: bool = False,\n    location: str | Location | None = None,\n    start_key: str | None = None,\n    limit: int = 50,\n) -&gt; Generator[StorageLocation, None, None]:\n    \"\"\"List storage locations with optional filtering.\n\n    Parameters\n    ----------\n    name : str | list[str] | None, optional\n        The name or names of the storage locations to filter by, by default None\n    exact_match : bool, optional\n        Whether to perform an exact match on the name, by default False\n    location : str | Location | None, optional\n        The location ID or Location object to filter by, by default None\n\n    Yields\n    ------\n    Generator[StorageLocation, None, None]\n        _description_\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[StorageLocation]:\n        for x in items:\n            id = x[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching storage location {id}: {e}\")\n\n    params = {\n        \"limit\": limit,\n        \"locationId\": location.id if isinstance(location, Location | EntityLink) else location,\n        \"startKey\": start_key,\n    }\n    if name:\n        params[\"name\"] = [name] if isinstance(name, str) else name\n        params[\"exactMatch\"] = json.dumps(exact_match)\n\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"storage_locations/#albert.collections.storage_locations.StorageLocationsCollection.update","title":"update","text":"<pre><code>update(\n    *, storage_location: StorageLocation\n) -&gt; StorageLocation\n</code></pre> <p>Update a storage location.</p> <p>Parameters:</p> Name Type Description Default <code>storage_location</code> <code>StorageLocation</code> <p>The storage location to update.</p> required <p>Returns:</p> Type Description <code>StorageLocation</code> <p>The updated storage location as returned by the server.</p> Source code in <code>src/albert/collections/storage_locations.py</code> <pre><code>def update(self, *, storage_location: StorageLocation) -&gt; StorageLocation:\n    \"\"\"Update a storage location.\n\n    Parameters\n    ----------\n    storage_location : StorageLocation\n        The storage location to update.\n\n    Returns\n    -------\n    StorageLocation\n        The updated storage location as returned by the server.\n    \"\"\"\n    path = f\"{self.base_path}/{storage_location.id}\"\n    payload = self._generate_patch_payload(\n        existing=self.get_by_id(id=storage_location.id),\n        updated=storage_location,\n    )\n    self.session.patch(path, json=payload.model_dump(mode=\"json\", by_alias=True))\n    return self.get_by_id(id=storage_location.id)\n</code></pre>"},{"location":"substances/","title":"Substances","text":""},{"location":"substances/#albert.collections.substance.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"substances/#albert.collections.substance.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"substances/#albert.collections.substance.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"substances/#albert.collections.substance.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"substances/#albert.collections.substance.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceCollection","title":"SubstanceCollection","text":"<pre><code>SubstanceCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>SubstanceCollection is a collection class for managing Substance entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>An instance of the Albert session used for API interactions.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base URL for making API requests related to substances.</p> <p>Methods:</p> Name Description <code>get_by_ids</code> <p>Retrieves a list of substances by their CAS IDs and optional region.</p> <code>get_by_id</code> <p>Retrieves a single substance by its CAS ID and optional region.</p> Source code in <code>src/albert/collections/substance.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{SubstanceCollection._api_version}/substances\"\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/substances'\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(\n    *, cas_id: str, region: str = \"US\"\n) -&gt; SubstanceInfo\n</code></pre> <p>Get a substance by its CAS ID.</p> <p>Parameters:</p> Name Type Description Default <code>cas_id</code> <code>str</code> <p>The CAS ID of the substance to retrieve.</p> required <p>Returns:</p> Type Description <code>SubstanceInfo</code> <p>The retrieved substance or raises an error if not found.</p> Source code in <code>src/albert/collections/substance.py</code> <pre><code>def get_by_id(self, *, cas_id: str, region: str = \"US\") -&gt; SubstanceInfo:\n    \"\"\"\n    Get a substance by its CAS ID.\n\n    Parameters\n    ----------\n    cas_id : str\n        The CAS ID of the substance to retrieve.\n\n    Returns\n    -------\n    SubstanceInfo\n        The retrieved substance or raises an error if not found.\n    \"\"\"\n    return self.get_by_ids(cas_ids=[cas_id], region=region)[0]\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(\n    *, cas_ids: list[str], region: str = \"US\"\n) -&gt; list[SubstanceInfo]\n</code></pre> <p>Get substances by their CAS IDs.</p> <p>Parameters:</p> Name Type Description Default <code>cas_ids</code> <code>list[str]</code> <p>A list of CAS IDs to retrieve substances for.</p> required <code>region</code> <code>str</code> <p>The region to filter the subastance by, by default \"US\"</p> <code>'US'</code> <p>Returns:</p> Type Description <code>list[SubstanceInfo]</code> <p>A list of substances with the given CAS IDs.</p> Source code in <code>src/albert/collections/substance.py</code> <pre><code>def get_by_ids(self, *, cas_ids: list[str], region: str = \"US\") -&gt; list[SubstanceInfo]:\n    \"\"\"Get substances by their CAS IDs.\n\n    Parameters\n    ----------\n    cas_ids : list[str]\n        A list of CAS IDs to retrieve substances for.\n    region : str, optional\n        The region to filter the subastance by, by default \"US\"\n\n    Returns\n    -------\n    list[SubstanceInfo]\n        A list of substances with the given CAS IDs.\n    \"\"\"\n    url = f\"{self.base_path}\"\n    response = self.session.get(url, params={\"casIDs\": \",\".join(cas_ids), \"region\": region})\n    return SubstanceResponse.model_validate(response.json()).substances\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo","title":"SubstanceInfo","text":"<p>               Bases: <code>BaseAlbertModel</code></p> <p>SubstanceInfo is a Pydantic model representing information about a chemical substance.</p> <p>Attributes:</p> Name Type Description <code>acute_dermal_tox_info</code> <code>list[ToxicityInfo] | None</code> <p>Information about acute dermal toxicity.</p> <code>acute_inhalation_tox_info</code> <code>list[ToxicityInfo] | None</code> <p>Information about acute inhalation toxicity.</p> <code>acute_oral_tox_info</code> <code>list[ToxicityInfo] | None</code> <p>Information about acute oral toxicity.</p> <code>acute_tox_info</code> <code>list[ToxicityInfo] | None</code> <p>General acute toxicity information.</p> <code>bio_accumulative_info</code> <code>list[BioAccumulativeInfo] | None</code> <p>Information about bioaccumulation.</p> <code>boiling_point_info</code> <code>list[BoilingPointInfo] | None</code> <p>Information about boiling points.</p> <code>cas_id</code> <code>str</code> <p>The CAS ID of the substance.</p> <code>classification</code> <code>str | None</code> <p>The classification of the substance.</p> <code>classification_type</code> <code>str</code> <p>The type of classification.</p> <code>degradability_info</code> <code>list[DegradabilityInfo] | None</code> <p>Information about degradability.</p> <code>dnel_info</code> <code>list[DNELInfo] | None</code> <p>Information about the Derived No Effect Level (DNEL).</p> <code>ec_list_no</code> <code>str</code> <p>The EC list number.</p> <code>exposure_controls_acgih</code> <code>list[ExposureControl] | None</code> <p>ACGIH exposure controls.</p> <code>hazards</code> <code>list[Hazard] | None</code> <p>List of hazards associated with the substance.</p> <code>iarc_carcinogen</code> <code>str | None</code> <p>IARC carcinogen classification.</p> <code>ntp_carcinogen</code> <code>str | None</code> <p>NTP carcinogen classification.</p> <code>osha_carcinogen</code> <code>bool | None</code> <p>OSHA carcinogen classification.</p> <code>health_effects</code> <code>str | None</code> <p>Information about health effects.</p> <code>name</code> <code>list[SubstanceName] | None</code> <p>Names of the substance.</p> <code>page_number</code> <code>int | None</code> <p>Page number for reference.</p> <code>aicis_notified</code> <code>bool | None</code> <p>Indicates if AICIS has been notified.</p> <code>approved_legal_entities</code> <code>Any | None</code> <p>Approved legal entities for the substance.</p> <code>aspiration_tox_info</code> <code>list[Any] | None</code> <p>Information about aspiration toxicity.</p> <code>basel_conv_list</code> <code>bool | None</code> <p>Indicates if the substance is on the Basel Convention list.</p> <code>bei_info</code> <code>list[Any] | None</code> <p>Information related to BEI.</p> <code>caa_cfr40</code> <code>bool | None</code> <p>Indicates compliance with CAA CFR 40.</p> <code>caa_hpa</code> <code>bool | None</code> <p>Indicates compliance with CAA HPA.</p> <code>canada_inventory_status</code> <code>str | None</code> <p>Status in the Canadian inventory.</p> <code>carcinogen_info</code> <code>list[Any] | None</code> <p>Information about carcinogenicity.</p> <code>chemical_category</code> <code>list[str] | None</code> <p>Categories of the chemical.</p> <code>dermal_acute_toxicity</code> <code>float | None</code> <p>Acute dermal toxicity value.</p> <code>inhalation_acute_toxicity</code> <code>float | None</code> <p>Acute inhalation toxicity value.</p> <code>oral_acute_toxicity</code> <code>float | None</code> <p>Acute oral toxicity value.</p> <code>lethal_dose_and_concentrations</code> <code>list[LethalDoseConcentration] | None</code> <p>Information about lethal doses and concentrations.</p> <code>m_factor</code> <code>int | None</code> <p>M factor for acute toxicity.</p> <code>m_factor_chronic</code> <code>int | None</code> <p>M factor for chronic toxicity.</p> <code>molecular_weight</code> <code>list[MolecularWeight] | None</code> <p>Molecular weight information.</p> <code>rsl</code> <code>RSL | None</code> <p>Risk-based screening level.</p> <code>specific_conc_eu</code> <code>list[SpecificConcentration] | None</code> <p>Specific concentration information for the EU.</p> <code>specific_conc_source</code> <code>str | None</code> <p>Source of specific concentration information.</p> <code>sustainability_status_lbc</code> <code>str | None</code> <p>Sustainability status under LBC.</p> <code>tsca_8b</code> <code>bool | None</code> <p>Indicates compliance with TSCA 8(b).</p> <code>cdsa_list</code> <code>bool | None</code> <p>Indicates if the substance is on the CDSA list.</p> <code>cn_csdc_regulations</code> <code>bool | None</code> <p>Compliance with CN CSDC regulations.</p> <code>cn_pcod_list</code> <code>bool | None</code> <p>Indicates if the substance is on the CN PCOD list.</p> <code>cn_priority_list</code> <code>bool | None</code> <p>Indicates if the substance is on the CN priority list.</p> <code>ec_notified</code> <code>str | None</code> <p>Notification status in the EC.</p> <code>eu_annex_14_substances_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU Annex 14 list.</p> <code>eu_annex_17_restrictions_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU Annex 17 restrictions list.</p> <code>eu_annex_17_substances_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU Annex 17 substances list.</p> <code>eu_candidate_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU candidate list.</p> <code>eu_dang_chem_annex_1_part_1_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU dangerous chemicals Annex 1 Part 1 list.</p> <code>eu_dang_chem_annex_1_part_2_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU dangerous chemicals Annex 1 Part 2 list.</p> <code>eu_dang_chem_annex_1_part_3_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU dangerous chemicals Annex 1 Part 3 list.</p> <code>eu_dang_chem_annex_5_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU dangerous chemicals Annex 5 list.</p> <code>eu_directive_ec_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU directive EC list.</p> <code>eu_explosive_precursors_annex_1_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU explosive precursors Annex 1 list.</p> <code>eu_explosive_precursors_annex_2_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU explosive precursors Annex 2 list.</p> <code>eu_ozone_depletion_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU ozone depletion list.</p> <code>eu_pollutant_annex_2_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU pollutant Annex 2 list.</p> <code>eu_pop_list</code> <code>bool | None</code> <p>Indicates if the substance is on the EU POP list.</p> <code>export_control_list_phrases</code> <code>bool | None</code> <p>Indicates if the substance is on the export control list.</p> <code>green_gas_list</code> <code>bool | None</code> <p>Indicates if the substance is on the green gas list.</p> <code>iecsc_notified</code> <code>bool | None</code> <p>Indicates if the substance is IECSc notified.</p> <code>index_no</code> <code>str | None</code> <p>Index number for the substance.</p> <code>jpencs_notified</code> <code>bool | None</code> <p>Indicates if the substance is JPENCS notified.</p> <code>jpishl_notified</code> <code>bool | None</code> <p>Indicates if the substance is JPISHL notified.</p> <code>koecl_notified</code> <code>bool | None</code> <p>Indicates if the substance is KOECL notified.</p> <code>kyoto_protocol</code> <code>bool | None</code> <p>Indicates compliance with the Kyoto Protocol.</p> <code>massachusetts_rtk</code> <code>bool | None</code> <p>Indicates if the substance is on the Massachusetts RTK list.</p> <code>montreal_protocol</code> <code>bool | None</code> <p>Indicates compliance with the Montreal Protocol.</p> <code>new_jersey_rtk</code> <code>bool | None</code> <p>Indicates if the substance is on the New Jersey RTK list.</p> <code>new_york_rtk</code> <code>bool | None</code> <p>Indicates if the substance is on the New York RTK list.</p> <code>nzioc_notified</code> <code>bool | None</code> <p>Indicates if the substance is NZIOC notified.</p> <code>pcr_regulated</code> <code>bool | None</code> <p>Indicates if the substance is PCR regulated.</p> <code>pennsylvania_rtk</code> <code>bool | None</code> <p>Indicates if the substance is on the Pennsylvania RTK list.</p> <code>peroxide_function_groups</code> <code>int | None</code> <p>Number of peroxide function groups.</p> <code>piccs_notified</code> <code>bool | None</code> <p>Indicates if the substance is PICCS notified.</p> <code>rhode_island_rtk</code> <code>bool | None</code> <p>Indicates if the substance is on the Rhode Island RTK list.</p> <code>rotterdam_conv_list</code> <code>bool | None</code> <p>Indicates if the substance is on the Rotterdam Convention list.</p> <code>sdwa</code> <code>bool | None</code> <p>Indicates compliance with the SDWA.</p> <code>source</code> <code>str | None</code> <p>Source of the substance information.</p> <code>specific_concentration_limit</code> <code>str | None</code> <p>Specific concentration limit for the substance.</p> <code>stockholm_conv_list</code> <code>bool | None</code> <p>Indicates if the substance is on the Stockholm Convention list.</p> <code>stot_affected_organs</code> <code>str | None</code> <p>Organs affected by STOT.</p> <code>stot_route_of_exposure</code> <code>str | None</code> <p>Route of exposure for STOT.</p> <code>tcsi_notified</code> <code>bool | None</code> <p>Indicates if the substance is TCSI notified.</p> <code>trade_secret</code> <code>str | None</code> <p>Information about trade secrets.</p> <code>tw_ghs_clas_list</code> <code>bool | None</code> <p>Indicates if the substance is on the TW GHS classification list.</p> <code>tw_handle_priority_chem</code> <code>bool | None</code> <p>Indicates if the substance is a priority chemical.</p> <code>tw_handle_toxic_chem</code> <code>bool | None</code> <p>Indicates if the substance is a toxic chemical.</p> <code>tw_ind_waste_standards</code> <code>bool | None</code> <p>Indicates compliance with TW industrial waste standards.</p> <code>vinic_notified</code> <code>bool | None</code> <p>Indicates if the substance is VINIC notified.</p> <code>exposure_controls_osha</code> <code>list[ExposureControl] | None</code> <p>OSHA exposure controls.</p> <code>exposure_controls_aiha</code> <code>list[ExposureControl] | None</code> <p>AIHA exposure controls.</p> <code>exposure_controls_niosh</code> <code>list[ExposureControl] | None</code> <p>NIOSH exposure controls.</p> <code>snur</code> <code>bool | dict | None</code> <p>Significant new use rule information.</p> <code>tsca_12b_concentration_limit</code> <code>float | None</code> <p>TSCA 12(b) concentration limit.</p> <code>cercla_rq</code> <code>float | None</code> <p>CERCLA reportable quantity.</p> <code>california_prop_65</code> <code>list[str] | None</code> <p>Information related to California Prop 65.</p> <code>sara_302</code> <code>bool | None</code> <p>Indicates compliance with SARA 302.</p> <code>sara_313_concentration_limit</code> <code>float | None</code> <p>SARA 313 concentration limit.</p> <code>cfr_marine_pollutant</code> <code>dict | None</code> <p>Information about marine pollutants under CFR.</p> <code>cfr_reportable_quantity</code> <code>dict | None</code> <p>Information about reportable quantities under CFR.</p> <code>rohs_concentration</code> <code>float | None</code> <p>ROHS concentration limit.</p> <code>skin_corrosion_info</code> <code>list[SkinCorrosionInfo] | None</code> <p>Information about skin corrosion.</p> <code>serious_eye_damage_info</code> <code>list[SeriousEyeDamageInfo] | None</code> <p>Information about serious eye damage.</p> <code>respiratory_skin_sens_info</code> <code>list[RespiratorySkinSensInfo] | None</code> <p>Information about respiratory skin sensitization.</p> <code>is_known</code> <code>bool</code> <p>Indicates if the substance is known (i.e. has known regulatory or hazard information in the database) (note this is an alias for the isCas field which behaves in a non intuitive way in the API so we have opted to use is_known for usability instead)</p>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.acute_dermal_tox_info","title":"acute_dermal_tox_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acute_dermal_tox_info: list[ToxicityInfo] | None = Field(\n    None, alias=\"acuteDermalToxInfo\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.acute_inhalation_tox_info","title":"acute_inhalation_tox_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acute_inhalation_tox_info: list[ToxicityInfo] | None = (\n    Field(None, alias=\"acuteInhalationToxInfo\")\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.acute_oral_tox_info","title":"acute_oral_tox_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acute_oral_tox_info: list[ToxicityInfo] | None = Field(\n    None, alias=\"acuteOralToxInfo\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.acute_tox_info","title":"acute_tox_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>acute_tox_info: list[ToxicityInfo] | None = Field(\n    None, alias=\"acuteToxInfo\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.aicis_notified","title":"aicis_notified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aicis_notified: bool | None = Field(\n    None, alias=\"aicisNotified\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.approved_legal_entities","title":"approved_legal_entities  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>approved_legal_entities: Any | None = Field(\n    None, alias=\"approvedLegalEntities\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.aspiration_tox_info","title":"aspiration_tox_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aspiration_tox_info: list[Any] | None = Field(\n    None, alias=\"aspirationToxInfo\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.basel_conv_list","title":"basel_conv_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>basel_conv_list: bool | None = Field(\n    None, alias=\"baselConvList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.bei_info","title":"bei_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bei_info: list[Any] | None = Field(None, alias='beiInfo')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.bio_accumulative_info","title":"bio_accumulative_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bio_accumulative_info: list[BioAccumulativeInfo] | None = (\n    Field(None, alias=\"bioAccumulativeInfo\")\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.boilingpoint_info","title":"boilingpoint_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>boilingpoint_info: list[BoilingPointInfo] | None = Field(\n    None, alias=\"boilingpointInfo\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.caa_cfr_40","title":"caa_cfr_40  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>caa_cfr_40: bool | None = Field(None, alias='caaCFR40')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.caa_hpa","title":"caa_hpa  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>caa_hpa: bool | None = Field(None, alias='caaHPA')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.california_prop_65","title":"california_prop_65  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>california_prop_65: list[str] | None = Field(\n    None, alias=\"californiaProp65\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.canada_inventory_status","title":"canada_inventory_status  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>canada_inventory_status: str | None = Field(\n    None, alias=\"canadaInventoryStatus\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.carcinogen_info","title":"carcinogen_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>carcinogen_info: list[Any] | None = Field(\n    None, alias=\"carcinogenInfo\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.cas_id","title":"cas_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cas_id: str = Field(..., alias='casID')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.cdsa_list","title":"cdsa_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cdsa_list: bool | None = Field(None, alias='cdsaList')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.cercla_rq","title":"cercla_rq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cercla_rq: float | None = Field(None, alias='cerclaRQ')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.cfr_marine_pollutant","title":"cfr_marine_pollutant  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfr_marine_pollutant: dict | None = Field(\n    None, alias=\"CFRmarinePollutant\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.cfr_reportable_quantity","title":"cfr_reportable_quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfr_reportable_quantity: dict | None = Field(\n    None, alias=\"CFRreportableQuantity\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.chemical_category","title":"chemical_category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>chemical_category: list[str] | None = Field(\n    None, alias=\"chemicalCategory\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.classification","title":"classification  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>classification: str | None = None\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.classification_type","title":"classification_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>classification_type: str | None = Field(\n    default=None, alias=\"classificationType\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.cn_csd_c_regulations","title":"cn_csd_c_regulations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cn_csd_c_regulations: bool | None = Field(\n    None, alias=\"cnCSDCRegulations\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.cn_pcod_list","title":"cn_pcod_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cn_pcod_list: bool | None = Field(None, alias='cnPCODList')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.cn_priority_list","title":"cn_priority_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cn_priority_list: bool | None = Field(\n    None, alias=\"cnPriorityList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.degradability_info","title":"degradability_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>degradability_info: list[DegradabilityInfo] | None = Field(\n    None, alias=\"degradabilityInfo\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.dermal_acute_toxicity","title":"dermal_acute_toxicity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dermal_acute_toxicity: float | None = Field(\n    None, alias=\"dermalAcuteToxicity\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.dnel_info","title":"dnel_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dnel_info: list[DNELInfo] | None = Field(\n    None, alias=\"dnelInfo\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.ec_list_no","title":"ec_list_no  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ec_list_no: str | None = Field(\n    default=None, alias=\"ecListNo\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.ec_notified","title":"ec_notified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ec_notified: str | None = Field(None, alias='ecNotified')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_annex_14_substances_list","title":"eu_annex_14_substances_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_annex_14_substances_list: bool | None = Field(\n    None, alias=\"euAnnex14SubstancesList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_annex_17_restrictions_list","title":"eu_annex_17_restrictions_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_annex_17_restrictions_list: bool | None = Field(\n    None, alias=\"euAnnex17RestrictionsList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_annex_17_substances_list","title":"eu_annex_17_substances_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_annex_17_substances_list: bool | None = Field(\n    None, alias=\"euAnnex17SubstancesList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_candidate_list","title":"eu_candidate_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_candidate_list: bool | None = Field(\n    None, alias=\"euCandidateList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_dang_chem_annex_1_part_1_list","title":"eu_dang_chem_annex_1_part_1_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_dang_chem_annex_1_part_1_list: bool | None = Field(\n    None, alias=\"euDangChemAnnex1Part1List\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_dang_chem_annex_1_part_2_list","title":"eu_dang_chem_annex_1_part_2_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_dang_chem_annex_1_part_2_list: bool | None = Field(\n    None, alias=\"euDangChemAnnex1Part2List\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_dang_chem_annex_1_part_3_list","title":"eu_dang_chem_annex_1_part_3_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_dang_chem_annex_1_part_3_list: bool | None = Field(\n    None, alias=\"euDangChemAnnex1Part3List\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_dang_chem_annex_5_list","title":"eu_dang_chem_annex_5_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_dang_chem_annex_5_list: bool | None = Field(\n    None, alias=\"euDangChemAnnex5List\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_directive_ec_list","title":"eu_directive_ec_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_directive_ec_list: bool | None = Field(\n    None, alias=\"euDirectiveEcList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_explosive_precursors_annex_1_list","title":"eu_explosive_precursors_annex_1_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_explosive_precursors_annex_1_list: bool | None = Field(\n    None, alias=\"euExplosivePrecursorsAnnex1List\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_explosive_precursors_annex_2_list","title":"eu_explosive_precursors_annex_2_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_explosive_precursors_annex_2_list: bool | None = Field(\n    None, alias=\"euExplosivePrecursorsAnnex2List\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_ozone_depletion_list","title":"eu_ozone_depletion_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_ozone_depletion_list: bool | None = Field(\n    None, alias=\"euOzoneDepletionList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_pollutant_annex_2_list","title":"eu_pollutant_annex_2_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_pollutant_annex_2_list: bool | None = Field(\n    None, alias=\"euPollutantAnnex2List\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.eu_pop_list","title":"eu_pop_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eu_pop_list: bool | None = Field(None, alias='euPopList')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.export_control_list_phrases","title":"export_control_list_phrases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>export_control_list_phrases: bool | None = Field(\n    None, alias=\"exportControlListPhrases\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.exposure_controls_acgih","title":"exposure_controls_acgih  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exposure_controls_acgih: list[ExposureControl] | None = (\n    Field(None, alias=\"exposureControlsACGIH\")\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.exposure_controls_aiha","title":"exposure_controls_aiha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exposure_controls_aiha: list[ExposureControl] | None = (\n    Field(None, alias=\"exposureControlsAIHA\")\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.exposure_controls_niosh","title":"exposure_controls_niosh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exposure_controls_niosh: list[ExposureControl] | None = (\n    Field(None, alias=\"exposureControlsNIOSH\")\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.exposure_controls_osha","title":"exposure_controls_osha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exposure_controls_osha: list[ExposureControl] | None = (\n    Field(None, alias=\"exposureControlsOSHA\")\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.green_gas_list","title":"green_gas_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>green_gas_list: bool | None = Field(\n    None, alias=\"greenGasList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.hazards","title":"hazards  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hazards: list[Hazard] | None = None\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.health_effects","title":"health_effects  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>health_effects: str | None = Field(\n    None, alias=\"healthEffects\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.iarc_carcinogen","title":"iarc_carcinogen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iarc_carcinogen: str | None = Field(\n    None, alias=\"iarcCarcinogen\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.iecsc_notified","title":"iecsc_notified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iecsc_notified: bool | None = Field(\n    None, alias=\"iecscNotified\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.index_no","title":"index_no  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index_no: str | None = Field(None, alias='indexNo')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.inhalation_acute_toxicity","title":"inhalation_acute_toxicity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inhalation_acute_toxicity: float | None = Field(\n    None, alias=\"inhalationAcuteToxicity\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.is_known","title":"is_known  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_known: bool = Field(default=True, alias='isCas')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.jpencs_notified","title":"jpencs_notified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jpencs_notified: bool | None = Field(\n    None, alias=\"jpencsNotified\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.jpishl_notified","title":"jpishl_notified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jpishl_notified: bool | None = Field(\n    None, alias=\"jpishlNotified\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.koecl_notified","title":"koecl_notified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>koecl_notified: bool | None = Field(\n    None, alias=\"koeclNotified\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.kyoto_protocol","title":"kyoto_protocol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kyoto_protocol: bool | None = Field(\n    None, alias=\"kyotoProtocol\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.lethal_dose_and_concentrations","title":"lethal_dose_and_concentrations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lethal_dose_and_concentrations: (\n    list[LethalDoseConcentration] | None\n) = Field(None, alias=\"lethalDoseAndConcentrations\")\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.m_factor","title":"m_factor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>m_factor: int | None = Field(None, alias='mFactor')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.m_factor_chronic","title":"m_factor_chronic  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>m_factor_chronic: int | None = Field(\n    None, alias=\"mFactorChronic\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.massachusetts_rtk","title":"massachusetts_rtk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>massachusetts_rtk: bool | None = Field(\n    None, alias=\"massachusettsRTK\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.molecular_weight","title":"molecular_weight  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>molecular_weight: list[MolecularWeight] | None = Field(\n    None, alias=\"molecularWeight\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.montreal_protocol","title":"montreal_protocol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>montreal_protocol: bool | None = Field(\n    None, alias=\"montrealProtocol\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: list[SubstanceName] | None = None\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.new_jersey_rtk","title":"new_jersey_rtk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>new_jersey_rtk: bool | None = Field(\n    None, alias=\"newJerseyRTK\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.new_york_rtk","title":"new_york_rtk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>new_york_rtk: bool | None = Field(None, alias='newYorkRTK')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.ntp_carcinogen","title":"ntp_carcinogen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ntp_carcinogen: str | None = Field(\n    None, alias=\"ntpCarcinogen\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.nzioc_notified","title":"nzioc_notified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nzioc_notified: bool | None = Field(\n    None, alias=\"nziocNotified\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.oral_acute_toxicity","title":"oral_acute_toxicity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>oral_acute_toxicity: float | None = Field(\n    None, alias=\"oralAcuteToxicity\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.osha_carcinogen","title":"osha_carcinogen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>osha_carcinogen: bool | None = Field(\n    None, alias=\"oshaCarcinogen\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.page_number","title":"page_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page_number: int | None = Field(None, alias='pageNumber')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.pcr_regulated","title":"pcr_regulated  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pcr_regulated: bool | None = Field(\n    None, alias=\"pcrRegulated\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.pennsylvania_rtk","title":"pennsylvania_rtk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pennsylvania_rtk: bool | None = Field(\n    None, alias=\"pennsylvaniaRTK\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.peroxide_function_groups","title":"peroxide_function_groups  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>peroxide_function_groups: int | None = Field(\n    None, alias=\"peroxideFunctionGroups\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.piccs_notified","title":"piccs_notified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>piccs_notified: bool | None = Field(\n    None, alias=\"piccsNotified\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.respiratory_skin_sens_info","title":"respiratory_skin_sens_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>respiratory_skin_sens_info: (\n    list[RespiratorySkinSensInfo] | None\n) = Field(None, alias=\"respiratorySkinSensInfo\")\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.rhode_island_rtk","title":"rhode_island_rtk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhode_island_rtk: bool | None = Field(\n    None, alias=\"rhodeIslandRTK\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.rohs_concentration","title":"rohs_concentration  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rohs_concentration: float | None = Field(\n    None, alias=\"rohsConcentration\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.rotterdam_conv_list","title":"rotterdam_conv_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rotterdam_conv_list: bool | None = Field(\n    None, alias=\"rotterdamConvList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.rsl","title":"rsl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rsl: RSL | None = Field(None, alias='rsl')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.sara_302","title":"sara_302  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sara_302: bool | None = Field(None, alias='sara302')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.sara_313_concentration_limit","title":"sara_313_concentration_limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sara_313_concentration_limit: float | None = Field(\n    None, alias=\"sara313ConcentrationLimit\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.sdwa","title":"sdwa  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sdwa: bool | None = Field(None, alias='sdwa')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.serious_eye_damage_info","title":"serious_eye_damage_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>serious_eye_damage_info: (\n    list[SeriousEyeDamageInfo] | None\n) = Field(None, alias=\"seriousEyeDamageInfo\")\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.skin_corrosion_info","title":"skin_corrosion_info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>skin_corrosion_info: list[SkinCorrosionInfo] | None = Field(\n    None, alias=\"skinCorrosionInfo\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.snur","title":"snur  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>snur: bool | dict | None = None\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.source","title":"source  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source: str | None = Field(None, alias='source')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.specific_conc_eu","title":"specific_conc_eu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specific_conc_eu: list[SpecificConcentration] | None = (\n    Field(None, alias=\"specificConcEU\")\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.specific_conc_source","title":"specific_conc_source  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specific_conc_source: str | None = Field(\n    None, alias=\"specificConcSource\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.specific_concentration_limit","title":"specific_concentration_limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>specific_concentration_limit: str | None = Field(\n    None, alias=\"specificConcentrationLimit\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.stockholm_conv_list","title":"stockholm_conv_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stockholm_conv_list: bool | None = Field(\n    None, alias=\"stockholmConvList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.stot_affected_organs","title":"stot_affected_organs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stot_affected_organs: str | None = Field(\n    None, alias=\"stotAffectedOrgans\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.stot_route_of_exposure","title":"stot_route_of_exposure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stot_route_of_exposure: str | None = Field(\n    None, alias=\"stotRouteOfExposure\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.sustainability_status_lbc","title":"sustainability_status_lbc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sustainability_status_lbc: str | None = Field(\n    None, alias=\"sustainabilityStatusLBC\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.tcsi_notified","title":"tcsi_notified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tcsi_notified: bool | None = Field(\n    None, alias=\"tcsiNotified\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.trade_secret","title":"trade_secret  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trade_secret: bool | None = Field(None, alias=\"tradeSecret\")\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.tsca_12b_concentration_limit","title":"tsca_12b_concentration_limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tsca_12b_concentration_limit: float | None = Field(\n    None, alias=\"tsca12BConcentrationLimit\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.tsca_8b","title":"tsca_8b  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tsca_8b: bool | None = Field(None, alias='tsca8B')\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.tw_ghs_clas_list","title":"tw_ghs_clas_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tw_ghs_clas_list: bool | None = Field(\n    None, alias=\"twGHSClasList\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.tw_handle_priority_chem","title":"tw_handle_priority_chem  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tw_handle_priority_chem: bool | None = Field(\n    None, alias=\"twHandlePriorityChem\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.tw_handle_toxic_chem","title":"tw_handle_toxic_chem  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tw_handle_toxic_chem: bool | None = Field(\n    None, alias=\"twHandleToxicChem\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.tw_ind_waste_standards","title":"tw_ind_waste_standards  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tw_ind_waste_standards: bool | None = Field(\n    None, alias=\"twIndWasteStandards\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: Literal['Substance'] = 'Substance'\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceInfo.vinic_notified","title":"vinic_notified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vinic_notified: bool | None = Field(\n    None, alias=\"vinicNotified\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceResponse","title":"SubstanceResponse","text":"<p>               Bases: <code>BaseAlbertModel</code></p> <p>SubstanceResponse is a Pydantic model representing the response containing substance information.</p> <p>Attributes:</p> Name Type Description <code>substances</code> <code>list[Substance]</code> <p>A list of substances.</p> <code>substance_errors</code> <code>list[Any] | None</code> <p>A list of errors related to substances, if any.</p>"},{"location":"substances/#albert.collections.substance.SubstanceResponse.substance_errors","title":"substance_errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>substance_errors: list[dict[str, Any]] | None = Field(\n    None, alias=\"substanceErrors\"\n)\n</code></pre>"},{"location":"substances/#albert.collections.substance.SubstanceResponse.substances","title":"substances  <code>instance-attribute</code>","text":"<pre><code>substances: list[SubstanceInfo]\n</code></pre>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#albert.collections.tags.AlbertException","title":"AlbertException","text":"<pre><code>AlbertException(message: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, message: str):\n    super().__init__(message)\n    self.message = message\n</code></pre>"},{"location":"tags/#albert.collections.tags.AlbertException.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"tags/#albert.collections.tags.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"tags/#albert.collections.tags.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"tags/#albert.collections.tags.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"tags/#albert.collections.tags.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"tags/#albert.collections.tags.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"tags/#albert.collections.tags.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"tags/#albert.collections.tags.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"tags/#albert.collections.tags.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"tags/#albert.collections.tags.Tag","title":"Tag","text":"<p>               Bases: <code>BaseResource</code></p> <p>Tag is a Pydantic model representing a tag entity.</p> <p>Attributes:</p> Name Type Description <code>tag</code> <code>str</code> <p>The name of the tag.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the tag. Set when the tag is retrieved from Albert.</p> <p>Methods:</p> Name Description <code>from_string</code> <p>Creates a Tag object from a string.</p>"},{"location":"tags/#albert.collections.tags.Tag.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(\n    None,\n    alias=AliasChoices(\"albertId\", \"tagId\"),\n    serialization_alias=\"albertId\",\n)\n</code></pre>"},{"location":"tags/#albert.collections.tags.Tag.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str = Field(\n    alias=AliasChoices(\"name\", \"tagName\"),\n    serialization_alias=\"name\",\n)\n</code></pre>"},{"location":"tags/#albert.collections.tags.Tag.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(tag: str) -&gt; Tag\n</code></pre> <p>Creates a Tag object from a string.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The name of the tag.</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>The Tag object created from the string.</p> Source code in <code>src/albert/resources/tags.py</code> <pre><code>@classmethod\ndef from_string(cls, tag: str) -&gt; \"Tag\":\n    \"\"\"\n    Creates a Tag object from a string.\n\n    Parameters\n    ----------\n    tag : str\n        The name of the tag.\n\n    Returns\n    -------\n    Tag\n        The Tag object created from the string.\n    \"\"\"\n    return cls(tag=tag)\n</code></pre>"},{"location":"tags/#albert.collections.tags.TagCollection","title":"TagCollection","text":"<pre><code>TagCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>TagCollection is a collection class for managing Tag entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Attributes:</p> Name Type Description <code>base_path</code> <code>str</code> <p>The base URL for tag API requests.</p> <p>Methods:</p> Name Description <code>list</code> <p>Lists tag entities with optional filters.</p> <code>tag_exists</code> <p>Checks if a tag exists by its name.</p> <code>create</code> <p>Creates a new tag entity.</p> <code>get_by_id</code> <p>Retrieves a tag by its ID.</p> <code>get_by_ids</code> <p>Retrieve a list of tags by their IDs.</p> <code>get_by_tag</code> <p>Retrieves a tag by its name.</p> <code>delete</code> <p>Deletes a tag by its ID.</p> <code>rename</code> <p>Renames an existing tag entity.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required Source code in <code>src/albert/collections/tags.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the TagCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{TagCollection._api_version}/tags\"\n</code></pre>"},{"location":"tags/#albert.collections.tags.TagCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/tags'\n</code></pre>"},{"location":"tags/#albert.collections.tags.TagCollection.create","title":"create","text":"<pre><code>create(*, tag: str | Tag) -&gt; Tag\n</code></pre> <p>Creates a new tag entity if the given tag does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Union[str, Tag]</code> <p>The tag name or Tag object to create.</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>The created Tag object or the existing Tag object of it already exists.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def create(self, *, tag: str | Tag) -&gt; Tag:\n    \"\"\"\n    Creates a new tag entity if the given tag does not exist.\n\n    Parameters\n    ----------\n    tag : Union[str, Tag]\n        The tag name or Tag object to create.\n\n    Returns\n    -------\n    Tag\n        The created Tag object or the existing Tag object of it already exists.\n    \"\"\"\n    if isinstance(tag, str):\n        tag = Tag(tag=tag)\n    hit = self.get_by_tag(tag=tag.tag, exact_match=True)\n    if hit is not None:\n        logging.warning(f\"Tag {hit.tag} already exists with id {hit.id}\")\n        return hit\n    payload = {\"name\": tag.tag}\n    response = self.session.post(self.base_path, json=payload)\n    tag = Tag(**response.json())\n    return tag\n</code></pre>"},{"location":"tags/#albert.collections.tags.TagCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a tag by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the tag to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a tag by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the tag to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"tags/#albert.collections.tags.TagCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Tag\n</code></pre> <p>Get a tag by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the tag to get.</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>The Tag object.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Tag:\n    \"\"\"\n    Get a tag by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the tag to get.\n\n    Returns\n    -------\n    Tag\n        The Tag object.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return Tag(**response.json())\n</code></pre>"},{"location":"tags/#albert.collections.tags.TagCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(*, ids: list[str]) -&gt; list[Tag]\n</code></pre> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def get_by_ids(self, *, ids: list[str]) -&gt; list[Tag]:\n    url = f\"{self.base_path}/ids\"\n    batches = [ids[i : i + 100] for i in range(0, len(ids), 100)]\n    return [\n        Tag(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()\n    ]\n</code></pre>"},{"location":"tags/#albert.collections.tags.TagCollection.get_by_tag","title":"get_by_tag","text":"<pre><code>get_by_tag(\n    *, tag: str, exact_match: bool = True\n) -&gt; Tag | None\n</code></pre> <p>Retrieves a tag by its name of None if not found.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The name of the tag to retrieve.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tag</code> <p>The Tag object if found, None otherwise.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def get_by_tag(self, *, tag: str, exact_match: bool = True) -&gt; Tag | None:\n    \"\"\"\n    Retrieves a tag by its name of None if not found.\n\n    Parameters\n    ----------\n    tag : str\n        The name of the tag to retrieve.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    Tag\n        The Tag object if found, None otherwise.\n    \"\"\"\n    found = self.list(name=tag, exact_match=exact_match)\n    return next(found, None)\n</code></pre>"},{"location":"tags/#albert.collections.tags.TagCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 50,\n    order_by: OrderBy = DESCENDING,\n    name: str | list[str] | None = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Tag]\n</code></pre> <p>Lists Tag entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of tags to return, by default 50.</p> <code>50</code> <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <code>name</code> <code>Union[str, None]</code> <p>The name of the tag to filter by, by default None.</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <code>start_key</code> <code>Optional[str]</code> <p>The starting point for the next set of results, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Tag]</code> <p>An iterator of Tag objects.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 50,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    name: str | list[str] | None = None,\n    exact_match: bool = True,\n    start_key: str | None = None,\n) -&gt; Iterator[Tag]:\n    \"\"\"\n    Lists Tag entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of tags to return, by default 50.\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING.\n    name : Union[str, None], optional\n        The name of the tag to filter by, by default None.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n    start_key : Optional[str], optional\n        The starting point for the next set of results, by default None.\n\n    Returns\n    -------\n    Iterator[Tag]\n        An iterator of Tag objects.\n    \"\"\"\n    params = {\"limit\": limit, \"orderBy\": order_by.value, \"startKey\": start_key}\n    if name:\n        params[\"name\"] = [name] if isinstance(name, str) else name\n        params[\"exactMatch\"] = json.dumps(exact_match)\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Tag(**item) for item in items],\n    )\n</code></pre>"},{"location":"tags/#albert.collections.tags.TagCollection.rename","title":"rename","text":"<pre><code>rename(*, old_name: str, new_name: str) -&gt; Tag\n</code></pre> <p>Renames an existing tag entity.</p> <p>Parameters:</p> Name Type Description Default <code>old_name</code> <code>str</code> <p>The current name of the tag.</p> required <code>new_name</code> <code>str</code> <p>The new name of the tag.</p> required <p>Returns:</p> Type Description <code>Tag</code> <p>The renamed Tag.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def rename(self, *, old_name: str, new_name: str) -&gt; Tag:\n    \"\"\"\n    Renames an existing tag entity.\n\n    Parameters\n    ----------\n    old_name : str\n        The current name of the tag.\n    new_name : str\n        The new name of the tag.\n\n    Returns\n    -------\n    Tag\n        The renamed Tag.\n    \"\"\"\n    found_tag = self.get_by_tag(tag=old_name, exact_match=True)\n    if not found_tag:\n        msg = f'Tag \"{old_name}\" not found.'\n        logger.error(msg)\n        raise AlbertException(msg)\n    tag_id = found_tag.id\n    payload = [\n        {\n            \"data\": [\n                {\n                    \"operation\": \"update\",\n                    \"attribute\": \"name\",\n                    \"oldValue\": old_name,\n                    \"newValue\": new_name,\n                }\n            ],\n            \"id\": tag_id,\n        }\n    ]\n    self.session.patch(self.base_path, json=payload)\n    return self.get_by_id(id=tag_id)\n</code></pre>"},{"location":"tags/#albert.collections.tags.TagCollection.tag_exists","title":"tag_exists","text":"<pre><code>tag_exists(*, tag: str, exact_match: bool = True) -&gt; bool\n</code></pre> <p>Checks if a tag exists by its name.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The name of the tag to check.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the tag exists, False otherwise.</p> Source code in <code>src/albert/collections/tags.py</code> <pre><code>def tag_exists(self, *, tag: str, exact_match: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if a tag exists by its name.\n\n    Parameters\n    ----------\n    tag : str\n        The name of the tag to check.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    bool\n        True if the tag exists, False otherwise.\n    \"\"\"\n\n    return self.get_by_tag(tag=tag, exact_match=exact_match) is not None\n</code></pre>"},{"location":"tasks/","title":"Tasks","text":""},{"location":"tasks/#albert.collections.tasks.BlockId","title":"BlockId  <code>module-attribute</code>","text":"<pre><code>BlockId = Annotated[str, AfterValidator(ensure_block_id)]\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.DataTemplateId","title":"DataTemplateId  <code>module-attribute</code>","text":"<pre><code>DataTemplateId = Annotated[\n    str, AfterValidator(ensure_datatemplate_id)\n]\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskAdapter","title":"TaskAdapter  <code>module-attribute</code>","text":"<pre><code>TaskAdapter = TypeAdapter(TaskUnion)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskId","title":"TaskId  <code>module-attribute</code>","text":"<pre><code>TaskId = Annotated[str, AfterValidator(ensure_task_id)]\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.WorkflowId","title":"WorkflowId  <code>module-attribute</code>","text":"<pre><code>WorkflowId = Annotated[\n    str, AfterValidator(ensure_workflow_id)\n]\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.AlbertHTTPError","title":"AlbertHTTPError","text":"<pre><code>AlbertHTTPError(response: Response)\n</code></pre> <p>               Bases: <code>AlbertException</code></p> <p>Base class for all erors due to HTTP responses.</p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, response: requests.Response):\n    message = self._format_message(response)\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.AlbertHTTPError.response","title":"response  <code>instance-attribute</code>","text":"<pre><code>response = response\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask","title":"BaseTask","text":"<p>               Bases: <code>BaseTaggedEntity</code></p> <p>Base class for all task types. Use PropertyTask, BatchTask, or GeneralTask for specific task types.</p>"},{"location":"tasks/#albert.collections.tasks.BaseTask.assigned_to","title":"assigned_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>assigned_to: SerializeAsEntityLink[User] | None = Field(\n    default=None, alias=\"AssignedTo\"\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.category","title":"category  <code>instance-attribute</code>","text":"<pre><code>category: TaskCategory\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.claimed_date","title":"claimed_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>claimed_date: str | None = Field(\n    alias=\"claimedDate\", default=None\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.closed_date","title":"closed_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>closed_date: str | None = Field(\n    alias=\"closedDate\", default=None\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.completed_date","title":"completed_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>completed_date: str | None = Field(\n    alias=\"completedDate\", default=None\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.due_date","title":"due_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>due_date: str | None = Field(alias='dueDate', default=None)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(alias='albertId', default=None)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.inventory_information","title":"inventory_information  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inventory_information: list[InventoryInformation] = Field(\n    alias=\"Inventories\", default=None\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: SerializeAsEntityLink[Location] | None = Field(\n    default=None, alias=\"Location\"\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] = Field(\n    alias=\"Metadata\", default_factory=dict\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.notes","title":"notes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>notes: str | None = Field(default=None)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.parent_id","title":"parent_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_id: str | None = Field(\n    alias=\"parentId\", default=None\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.pass_fail","title":"pass_fail  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pass_fail: bool | None = Field(\n    alias=\"passOrFail\", default=None\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority: TaskPriority | None = Field(default=None)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.project","title":"project  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>project: (\n    SerializeAsEntityLink[Project]\n    | list[SerializeAsEntityLink[Project]]\n    | None\n) = Field(default=None, alias=\"Project\")\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: str | None = Field(default=None)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.security_class","title":"security_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>security_class: SecurityClass | None = Field(\n    alias=\"class\", default=None\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.sources","title":"sources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sources: list[TaskSource] | None = Field(\n    default_factory=list, alias=\"Sources\"\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.start_date","title":"start_date  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start_date: str | None = Field(\n    alias=\"startDate\", default=None\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.BaseTask.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: TaskState | None = Field(default=None)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.HistoryEntity","title":"HistoryEntity","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"tasks/#albert.collections.tasks.HistoryEntity.WORKFLOW","title":"WORKFLOW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WORKFLOW = 'workflow'\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"tasks/#albert.collections.tasks.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.PropertyTask","title":"PropertyTask","text":"<p>               Bases: <code>BaseTask</code></p> <p>Represents a batch task.</p> <p>This class is used to create and manage batch tasks. It includes the base task attributes and additional attributes specific to batch tasks.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the batch task.</p> <code>inventory_information</code> <code>list[InventoryInformation]</code> <p>Information about the inventory associated with the batch task.</p> <code>location</code> <code>SerializeAsEntityLink[Location]</code> <p>The location where the batch task is performed.</p> <code>parent_id</code> <code>str</code> <p>The ID of the parent project.</p> <code>blocks</code> <code>list[Block]</code> <p>A list of blocks associated with the batch task.</p> <code>id</code> <code>(str, optional)</code> <p>The ID of the batch task, by default None.</p> <code>metadata</code> <code>(dict[str, MetadataItem], optional)</code> <p>Metadata associated with the batch task, by default an empty dictionary.</p> <code>due_date</code> <code>(str, optional)</code> <p>The due date of the batch task. YYY-MM-DD format, by default None.</p> <code>notes</code> <code>(str, optional)</code> <p>Notes associated with the batch task, by default None.</p> <code>priority</code> <code>(TaskPriority, optional)</code> <p>The priority of the batch task, by default None.</p> <code>assigned_to</code> <code>(SerializeAsEntityLink[User], optional)</code> <p>The user assigned to the batch task, by default None.</p> <code>state</code> <code>(TaskState, optional)</code> <p>The state of the batch task, by default None.</p> <code>sources</code> <code>(list[TaskSource], optional)</code> <p>A list of sources associated with the batch task, by default an empty list.</p> <code>security_class</code> <code>(SecurityClass, optional)</code> <p>The security class of the batch task, by default None.</p> <code>start_date</code> <code>str, read only</code> <p>The start date of the batch task, by default None.</p> <code>claimed_date</code> <code>str, read only</code> <p>The claimed date of the batch task, by default None.</p> <code>completed_date</code> <code>str, read only</code> <p>The completed date of the batch task, by default None.</p> <code>closed_date</code> <code>str, read only</code> <p>The closed date of the batch task, by default None.</p>"},{"location":"tasks/#albert.collections.tasks.PropertyTask.batch_task_id","title":"batch_task_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>batch_task_id: str | None = Field(\n    alias=\"batchTaskId\", default=None\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.PropertyTask.blocks","title":"blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocks: list[Block] | None = Field(\n    alias=\"Blocks\", default=None\n)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.PropertyTask.category","title":"category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category: Literal[PROPERTY] = PROPERTY\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.PropertyTask.qc_task","title":"qc_task  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qc_task: bool | None = Field(alias='qcTask', default=None)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.PropertyTask.target","title":"target  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>target: str | None = Field(default=None)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCategory","title":"TaskCategory","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"tasks/#albert.collections.tasks.TaskCategory.BATCH","title":"BATCH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATCH = 'Batch'\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCategory.BATCH_WITH_QC","title":"BATCH_WITH_QC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BATCH_WITH_QC = 'BatchWithQC'\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCategory.GENERAL","title":"GENERAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GENERAL = 'General'\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCategory.PROPERTY","title":"PROPERTY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPERTY = 'Property'\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCollection","title":"TaskCollection","text":"<pre><code>TaskCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>TaskCollection is a collection class for managing Task entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert Session information</p> required <p>Methods:</p> Name Description <code>add_block</code> <p>Add a block to a Property task.</p> <code>create</code> <p>Create a new task. Tasks can be of different types, such as PropertyTask, and are created using the provided task object.</p> <code>delete</code> <p>Delete a task.</p> <code>get_by_id</code> <p>Retrieve a task by its ID.</p> <code>get_history</code> <code>list</code> <p>Search for tasks matching the given criteria.</p> <code>remove_block</code> <p>Remove a block from a Property task.</p> <code>update</code> <p>Update a task.</p> <code>update_block_workflow</code> <p>Update the workflow of a specific block within a task.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initialize the TaskCollection.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert Session information\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{TaskCollection._api_version}/tasks\"\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/tasks'\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCollection.add_block","title":"add_block","text":"<pre><code>add_block(\n    *,\n    task_id: TaskId,\n    data_template_id: DataTemplateId,\n    workflow_id: WorkflowId,\n) -&gt; None\n</code></pre> <p>Add a block to a Property task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>TaskId</code> <p>The ID of the task to add the block to.</p> required <code>data_template_id</code> <code>DataTemplateId</code> <p>The ID of the data template to use for the block.</p> required <code>workflow_id</code> <code>WorkflowId</code> <p>The ID of the workflow to assign to the block.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This method does not return any value.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef add_block(\n    self, *, task_id: TaskId, data_template_id: DataTemplateId, workflow_id: WorkflowId\n) -&gt; None:\n    \"\"\"Add a block to a Property task.\n\n    Parameters\n    ----------\n    task_id : TaskId\n        The ID of the task to add the block to.\n    data_template_id : DataTemplateId\n        The ID of the data template to use for the block.\n    workflow_id : WorkflowId\n        The ID of the workflow to assign to the block.\n\n    Returns\n    -------\n    None\n        This method does not return any value.\n\n    \"\"\"\n    url = f\"{self.base_path}/{task_id}\"\n    payload = [\n        {\n            \"id\": task_id,\n            \"data\": [\n                {\n                    \"operation\": \"add\",\n                    \"attribute\": \"Block\",\n                    \"newValue\": [{\"datId\": data_template_id, \"Workflow\": {\"id\": workflow_id}}],\n                }\n            ],\n        }\n    ]\n    self.session.patch(url=url, json=payload)\n    return None\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCollection.create","title":"create","text":"<pre><code>create(*, task: BaseTask) -&gt; BaseTask\n</code></pre> <p>Create a new task. Tasks can be of different types, such as PropertyTask, and are created using the provided task object.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>BaseTask</code> <p>The task object to create.</p> required <p>Returns:</p> Type Description <code>BaseTask</code> <p>The registered task object.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def create(self, *, task: BaseTask) -&gt; BaseTask:\n    \"\"\"Create a new task. Tasks can be of different types, such as PropertyTask, and are created using the provided task object.\n\n    Parameters\n    ----------\n    task : BaseTask\n        The task object to create.\n\n    Returns\n    -------\n    BaseTask\n        The registered task object.\n    \"\"\"\n    payload = [task.model_dump(mode=\"json\", by_alias=True, exclude_none=True)]\n    url = f\"{self.base_path}/multi?category={task.category.value}\"\n    if task.parent_id is not None:\n        url = f\"{url}&amp;parentId={task.parent_id}\"\n    response = self.session.post(url=url, json=payload)\n    task_data = response.json()[0]\n    return TaskAdapter.validate_python(task_data)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCollection.delete","title":"delete","text":"<pre><code>delete(*, id: TaskId) -&gt; None\n</code></pre> <p>Delete a task.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TaskId</code> <p>The ID of the task to delete.</p> required Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef delete(self, *, id: TaskId) -&gt; None:\n    \"\"\"Delete a task.\n\n    Parameters\n    ----------\n    id : TaskId\n        The ID of the task to delete.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: TaskId) -&gt; BaseTask\n</code></pre> <p>Retrieve a task by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>TaskId</code> <p>The ID of the task to retrieve.</p> required <p>Returns:</p> Type Description <code>BaseTask</code> <p>The task object with the provided ID.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef get_by_id(self, *, id: TaskId) -&gt; BaseTask:\n    \"\"\"Retrieve a task by its ID.\n\n    Parameters\n    ----------\n    id : TaskId\n        The ID of the task to retrieve.\n\n    Returns\n    -------\n    BaseTask\n        The task object with the provided ID.\n    \"\"\"\n    url = f\"{self.base_path}/multi/{id}\"\n    response = self.session.get(url)\n    return TaskAdapter.validate_python(response.json())\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCollection.get_history","title":"get_history","text":"<pre><code>get_history(\n    *,\n    id: TaskId,\n    order: OrderBy = DESCENDING,\n    limit: int = 1000,\n    entity: HistoryEntity | None = None,\n    blockId: str | None = None,\n    startKey: str | None = None,\n) -&gt; TaskHistory\n</code></pre> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def get_history(\n    self,\n    *,\n    id: TaskId,\n    order: OrderBy = OrderBy.DESCENDING,\n    limit: int = 1000,\n    entity: HistoryEntity | None = None,\n    blockId: str | None = None,\n    startKey: str | None = None,\n) -&gt; TaskHistory:\n    params = {\n        \"limit\": limit,\n        \"orderBy\": OrderBy(order).value if order else None,\n        \"entity\": entity,\n        \"blockId\": blockId,\n        \"startKey\": startKey,\n    }\n    url = f\"{self.base_path}/{id}/history\"\n    response = self.session.get(url, params=params)\n    return TaskHistory(**response.json())\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    order: OrderBy = DESCENDING,\n    text: str | None = None,\n    sort_by: str | None = None,\n    tags: list[str] | None = None,\n    task_id: list[str] | None = None,\n    linked_task: list[str] | None = None,\n    category: TaskCategory | None = None,\n    albert_id: list[str] | None = None,\n    data_template: list[str] | None = None,\n    assigned_to: list[str] | None = None,\n    location: list[str] | None = None,\n    priority: list[str] | None = None,\n    status: list[str] | None = None,\n    parameter_group: list[str] | None = None,\n    created_by: list[str] | None = None,\n    project_id: str | None = None,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; Iterator[BaseTask]\n</code></pre> <p>Search for tasks matching the given criteria.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>OrderBy</code> <p>The order in which to return results, by default OrderBy.DESCENDING</p> <code>DESCENDING</code> <code>text</code> <code>str | None</code> <p>The text to search for, by default None</p> <code>None</code> <code>sort_by</code> <code>str | None</code> <p>The attribute to sort by, by default None</p> <code>None</code> <code>tags</code> <code>list[str] | None</code> <p>The tags to search for, by default None</p> <code>None</code> <code>task_id</code> <code>list[str] | None</code> <p>The related task IDs to search for, by default None</p> <code>None</code> <code>linked_task</code> <code>list[str] | None</code> <p>The Linked Task IDs to search for, by default None</p> <code>None</code> <code>category</code> <code>TaskCategory | None</code> <p>The category of the task to search for, by default None</p> <code>None</code> <code>albert_id</code> <code>list[str] | None</code> <p>The Albert IDs to search for, by default None</p> <code>None</code> <code>data_template</code> <code>list[str] | None</code> <p>The data template IDs to search for, by default None</p> <code>None</code> <code>assigned_to</code> <code>list[str] | None</code> <p>The User IDs to search for, by default None</p> <code>None</code> <code>location</code> <code>list[str] | None</code> <p>The Locations names to search for, by default None</p> <code>None</code> <code>priority</code> <code>list[str] | None</code> <p>The Priority levels to search for, by default None</p> <code>None</code> <code>status</code> <code>list[str] | None</code> <p>The Task Statuses to search for, by default None</p> <code>None</code> <code>parameter_group</code> <code>list[str] | None</code> <p>The related Parameter Group IDs to search for, by default None</p> <code>None</code> <code>created_by</code> <code>list[str] | None</code> <p>The User IDs of the task creators to search for, by default None</p> <code>None</code> <code>project_id</code> <code>str | None</code> <p>The Project ID to search for, by default None</p> <code>None</code> <p>Yields:</p> Type Description <code>Iterator[BaseTask]</code> <p>An iterator of matching Task objects.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def list(\n    self,\n    *,\n    order: OrderBy = OrderBy.DESCENDING,\n    text: str | None = None,\n    sort_by: str | None = None,\n    tags: list[str] | None = None,\n    task_id: list[str] | None = None,\n    linked_task: list[str] | None = None,\n    category: TaskCategory | None = None,\n    albert_id: list[str] | None = None,\n    data_template: list[str] | None = None,\n    assigned_to: list[str] | None = None,\n    location: list[str] | None = None,\n    priority: list[str] | None = None,\n    status: list[str] | None = None,\n    parameter_group: list[str] | None = None,\n    created_by: list[str] | None = None,\n    project_id: str | None = None,\n    limit: int = 100,\n    offset: int = 0,\n) -&gt; Iterator[BaseTask]:\n    \"\"\"Search for tasks matching the given criteria.\n\n    Parameters\n    ----------\n    order : OrderBy, optional\n        The order in which to return results, by default OrderBy.DESCENDING\n    text : str | None, optional\n        The text to search for, by default None\n    sort_by : str | None, optional\n        The attribute to sort by, by default None\n    tags : list[str] | None, optional\n        The tags to search for, by default None\n    task_id : list[str] | None, optional\n        The related task IDs to search for, by default None\n    linked_task : list[str] | None, optional\n        The Linked Task IDs to search for, by default None\n    category : TaskCategory | None, optional\n        The category of the task to search for, by default None\n    albert_id : list[str] | None, optional\n        The Albert IDs to search for, by default None\n    data_template : list[str] | None, optional\n        The data template IDs to search for, by default None\n    assigned_to : list[str] | None, optional\n        The User IDs to search for, by default None\n    location : list[str] | None, optional\n        The Locations names to search for, by default None\n    priority : list[str] | None, optional\n        The Priority levels to search for, by default None\n    status : list[str] | None, optional\n        The Task Statuses to search for, by default None\n    parameter_group : list[str] | None, optional\n        The related Parameter Group IDs to search for, by default None\n    created_by : list[str] | None, optional\n        The User IDs of the task creators to search for, by default None\n    project_id : str | None, optional\n        The Project ID to search for, by default None\n\n    Yields\n    ------\n    Iterator[BaseTask]\n        An iterator of matching Task objects.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[BaseTask]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except (\n                AlbertHTTPError,\n                RetryError,\n            ) as e:  # some legacy poorly formed Tasks raise 500s. The allowance on Retry error to also ignore these.\n                logger.warning(f\"Error fetching task '{id}': {e}\")\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"order\": OrderBy(order).value if order else None,\n        \"text\": text,\n        \"sortBy\": sort_by,\n        \"tags\": tags,\n        \"taskId\": task_id,\n        \"linkedTask\": linked_task,\n        \"category\": category,\n        \"albertId\": albert_id,\n        \"dataTemplate\": data_template,\n        \"assignedTo\": assigned_to,\n        \"location\": location,\n        \"priority\": priority,\n        \"status\": status,\n        \"parameterGroup\": parameter_group,\n        \"createdBy\": created_by,\n        \"projectId\": project_id,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        deserialize=deserialize,\n        params=params,\n    )\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCollection.remove_block","title":"remove_block","text":"<pre><code>remove_block(*, task_id: TaskId, block_id: BlockId) -&gt; None\n</code></pre> <p>Remove a block from a Property task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>ID of the Task to remove the block from (e.g., TASFOR1234)</p> required <code>block_id</code> <code>str</code> <p>ID of the Block to remove (e.g., BLK1)</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef remove_block(self, *, task_id: TaskId, block_id: BlockId) -&gt; None:\n    \"\"\"Remove a block from a Property task.\n\n    Parameters\n    ----------\n    task_id : str\n        ID of the Task to remove the block from (e.g., TASFOR1234)\n    block_id : str\n        ID of the Block to remove (e.g., BLK1)\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{task_id}\"\n    payload = [\n        {\n            \"id\": task_id,\n            \"data\": [\n                {\n                    \"operation\": \"delete\",\n                    \"attribute\": \"Block\",\n                    \"oldValue\": [block_id],\n                }\n            ],\n        }\n    ]\n    self.session.patch(url=url, json=payload)\n    return None\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCollection.update","title":"update","text":"<pre><code>update(*, task: BaseTask) -&gt; BaseTask\n</code></pre> <p>Update a task.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>BaseTask</code> <p>The updated Task object.</p> required <p>Returns:</p> Type Description <code>BaseTask</code> <p>The updated Task object as it exists in the Albert platform.</p> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>def update(self, *, task: BaseTask) -&gt; BaseTask:\n    \"\"\"Update a task.\n\n    Parameters\n    ----------\n    task : BaseTask\n        The updated Task object.\n\n    Returns\n    -------\n    BaseTask\n        The updated Task object as it exists in the Albert platform.\n    \"\"\"\n    patch_payload = self._generate_adv_patch_payload(updated=task)\n    if len(patch_payload[0][\"data\"]) == 0:\n        logger.info(f\"Task {task.id} is already up to date\")\n        return task\n    self.session.patch(\n        url=f\"{self.base_path}/{task.id}\",\n        json=patch_payload,\n    )\n    return self.get_by_id(id=task.id)\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskCollection.update_block_workflow","title":"update_block_workflow","text":"<pre><code>update_block_workflow(\n    *,\n    task_id: TaskId,\n    block_id: BlockId,\n    workflow_id: WorkflowId,\n) -&gt; None\n</code></pre> <p>Update the workflow of a specific block within a task.</p> <p>This method updates the workflow of a specified block within a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task.</p> required <code>block_id</code> <code>str</code> <p>The ID of the block within the task.</p> required <code>workflow_id</code> <code>str</code> <p>The ID of the new workflow to be assigned to the block.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This method does not return any value.</p> Notes <ul> <li>The method asserts that the retrieved task is an instance of <code>PropertyTask</code>.</li> <li>If the block's current workflow matches the new workflow ID, no update is performed.</li> <li>The method handles the case where the block has a default workflow named \"No Parameter Group\".</li> </ul> Source code in <code>src/albert/collections/tasks.py</code> <pre><code>@validate_call\ndef update_block_workflow(\n    self, *, task_id: TaskId, block_id: BlockId, workflow_id: WorkflowId\n) -&gt; None:\n    \"\"\"\n    Update the workflow of a specific block within a task.\n\n    This method updates the workflow of a specified block within a task.\n    Parameters\n    ----------\n    task_id : str\n        The ID of the task.\n    block_id : str\n        The ID of the block within the task.\n    workflow_id : str\n        The ID of the new workflow to be assigned to the block.\n\n    Returns\n    -------\n    None\n        This method does not return any value.\n\n    Notes\n    -----\n    - The method asserts that the retrieved task is an instance of `PropertyTask`.\n    - If the block's current workflow matches the new workflow ID, no update is performed.\n    - The method handles the case where the block has a default workflow named \"No Parameter Group\".\n    \"\"\"\n    url = f\"{self.base_path}/{task_id}\"\n    task = self.get_by_id(id=task_id)\n    if not isinstance(task, PropertyTask):\n        logger.error(f\"Task {task_id} is not an instance of PropertyTask\")\n        raise TypeError(f\"Task {task_id} is not an instance of PropertyTask\")\n    for b in task.blocks:\n        if b.id != block_id:\n            continue\n        for w in b.workflow:\n            if w.name == \"No Parameter Group\" and len(b.workflow) &gt; 1:\n                # hardcoded default workflow\n                continue\n            existing_workflow_id = w.id\n    if existing_workflow_id == workflow_id:\n        logger.info(f\"Block {block_id} already has workflow {workflow_id}\")\n        return None\n    patch = [\n        {\n            \"data\": [\n                {\n                    \"operation\": \"update\",\n                    \"attribute\": \"workflow\",\n                    \"oldValue\": existing_workflow_id,\n                    \"newValue\": workflow_id,\n                    \"blockId\": block_id,\n                }\n            ],\n            \"id\": task_id,\n        }\n    ]\n    self.session.patch(url=url, json=patch)\n    return None\n</code></pre>"},{"location":"tasks/#albert.collections.tasks.TaskHistory","title":"TaskHistory","text":"<p>               Bases: <code>BaseAlbertModel</code></p>"},{"location":"tasks/#albert.collections.tasks.TaskHistory.items","title":"items  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>items: list[TaskHistoryEvent] = Field(alias='Items')\n</code></pre>"},{"location":"un_numbers/","title":"UN Numbers","text":""},{"location":"un_numbers/#albert.collections.un_numbers.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumber","title":"UnNumber","text":"<p>               Bases: <code>BaseResource</code></p> <p>A UN number entity. UN Numbers are highly controlled within Albert.</p> <p>Attributes:</p> Name Type Description <code>un_number</code> <code>str</code> <p>The UN number.</p> <code>id</code> <code>str</code> <p>The Albert ID of the UN number. Set when the UN number is retrieved from Albert.</p> <code>storage_class_name</code> <code>str</code> <p>The name of the storage class.</p> <code>shipping_description</code> <code>str</code> <p>The shipping description.</p> <code>storage_class_number</code> <code>str</code> <p>The storage class number.</p> <code>un_classification</code> <code>str</code> <p>The UN classification.</p>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumber.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = Field(alias='albertId')\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumber.shipping_description","title":"shipping_description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>shipping_description: str = Field(\n    alias=\"shippingDescription\"\n)\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumber.storage_class_name","title":"storage_class_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>storage_class_name: str = Field(alias='storageClassName')\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumber.storage_class_number","title":"storage_class_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>storage_class_number: str = Field(\n    alias=\"storageClassNumber\"\n)\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumber.un_classification","title":"un_classification  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>un_classification: str = Field(alias='unClassification')\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumber.un_number","title":"un_number  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>un_number: str = Field(alias='unNumber')\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumberCollection","title":"UnNumberCollection","text":"<pre><code>UnNumberCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>UnNumberCollection is a collection class for managing UnNumber entities in the Albert platform.</p> Note <p>Creating UN Numbers is not supported via the SDK, as UN Numbers are highly controlled by Albert.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>This method is not implemented as UN Numbers cannot be created through the SDK.</p> <code>get_by_id</code> <p>Retrieve a UN Number by its ID.</p> <code>get_by_name</code> <p>Retrieve a UN Number by its name.</p> <code>list</code> <p>List UN Numbers matching the provided criteria.</p> Source code in <code>src/albert/collections/un_numbers.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"Initializes the UnNumberCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{UnNumberCollection._api_version}/unnumbers\"\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumberCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/unnumbers'\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumberCollection.create","title":"create","text":"<pre><code>create() -&gt; None\n</code></pre> <p>This method is not implemented as UN Numbers cannot be created through the SDK.</p> Source code in <code>src/albert/collections/un_numbers.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"\n    This method is not implemented as UN Numbers cannot be created through the SDK.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumberCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; UnNumber\n</code></pre> <p>Retrieve a UN Number by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the UN Number to retrieve.</p> required <p>Returns:</p> Type Description <code>UnNumber</code> <p>The corresponding UN Number</p> Source code in <code>src/albert/collections/un_numbers.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; UnNumber:\n    \"\"\"Retrieve a UN Number by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the UN Number to retrieve.\n\n    Returns\n    -------\n    UnNumber\n        The corresponding UN Number\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return UnNumber(**response.json())\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumberCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(*, name: str) -&gt; UnNumber | None\n</code></pre> <p>Retrieve a UN Number by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the UN Number to retrieve</p> required <p>Returns:</p> Type Description <code>UnNumber | None</code> <p>The corresponding UN Number or None if not found</p> Source code in <code>src/albert/collections/un_numbers.py</code> <pre><code>def get_by_name(self, *, name: str) -&gt; UnNumber | None:\n    \"\"\"Retrieve a UN Number by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the UN Number to retrieve\n\n    Returns\n    -------\n    UnNumber | None\n        The corresponding UN Number or None if not found\n    \"\"\"\n    found = self.list(exact_match=True, name=name)\n    return next(found, None)\n</code></pre>"},{"location":"un_numbers/#albert.collections.un_numbers.UnNumberCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    name: str | None = None,\n    exact_match: bool = False,\n    limit: int = 50,\n    start_key: str | None = None,\n) -&gt; Iterator[UnNumber]\n</code></pre> <p>List UN Numbers matching the provided criteria.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The name of the UN Number to search for, by default None</p> <code>None</code> <code>exact_match</code> <code>bool</code> <p>Weather to return exact matches only, by default False</p> <code>False</code> <p>Yields:</p> Type Description <code>Iterator[UnNumber]</code> <p>The UN Numbers matching the search criteria</p> Source code in <code>src/albert/collections/un_numbers.py</code> <pre><code>def list(\n    self,\n    *,\n    name: str | None = None,\n    exact_match: bool = False,\n    limit: int = 50,\n    start_key: str | None = None,\n) -&gt; Iterator[UnNumber]:\n    \"\"\"List UN Numbers matching the provided criteria.\n\n    Parameters\n    ----------\n    name : str | None, optional\n        The name of the UN Number to search for, by default None\n    exact_match : bool, optional\n        Weather to return exact matches only, by default False\n\n    Yields\n    ------\n    Iterator[UnNumber]\n        The UN Numbers matching the search criteria\n    \"\"\"\n    params = {\"limit\": limit, \"startKey\": start_key}\n    if name:\n        params[\"name\"] = name\n        params[\"exactMatch\"] = json.dumps(exact_match)\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [UnNumber(**item) for item in items],\n    )\n</code></pre>"},{"location":"units/","title":"Units","text":""},{"location":"units/#albert.collections.units.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"units/#albert.collections.units.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"units/#albert.collections.units.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"units/#albert.collections.units.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"units/#albert.collections.units.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"units/#albert.collections.units.OrderBy","title":"OrderBy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"units/#albert.collections.units.OrderBy.ASCENDING","title":"ASCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ASCENDING = 'asc'\n</code></pre>"},{"location":"units/#albert.collections.units.OrderBy.DESCENDING","title":"DESCENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DESCENDING = 'desc'\n</code></pre>"},{"location":"units/#albert.collections.units.Unit","title":"Unit","text":"<p>               Bases: <code>BaseResource</code></p> <p>Unit is a Pydantic model representing a unit entity.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str | None</code> <p>The Albert ID of the unit. Set when the unit is retrieved from Albert.</p> <code>name</code> <code>str</code> <p>The name of the unit.</p> <code>symbol</code> <code>str | None</code> <p>The symbol of the unit.</p> <code>synonyms</code> <code>List[str] | None</code> <p>The list of synonyms for the unit.</p> <code>category</code> <code>UnitCategory</code> <p>The category of the unit.</p> <code>verified</code> <code>bool | None</code> <p>Whether the unit is verified.</p> <code>status</code> <code>Status | None</code> <p>The status of the unit. Allowed values are <code>active</code>, and <code>inactive</code></p>"},{"location":"units/#albert.collections.units.Unit.category","title":"category  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>category: UnitCategory | None = Field(None)\n</code></pre>"},{"location":"units/#albert.collections.units.Unit.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(None, alias='albertId')\n</code></pre>"},{"location":"units/#albert.collections.units.Unit.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"units/#albert.collections.units.Unit.symbol","title":"symbol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol: str | None = Field(None)\n</code></pre>"},{"location":"units/#albert.collections.units.Unit.synonyms","title":"synonyms  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>synonyms: list[str] | None = Field(\n    default_factory=list, alias=\"Synonyms\"\n)\n</code></pre>"},{"location":"units/#albert.collections.units.Unit.verified","title":"verified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verified: bool | None = Field(\n    default=False, exclude=True, frozen=True\n)\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory","title":"UnitCategory","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>UnitCategory is an enumeration of possible unit categories.</p> <p>Attributes:</p> Name Type Description <code>LENGTH</code> <code>str</code> <p>Represents length units.</p> <code>VOLUME</code> <code>str</code> <p>Represents volume units.</p> <code>LIQUID_VOLUME</code> <code>str</code> <p>Represents liquid volume units.</p> <code>ANGLES</code> <code>str</code> <p>Represents angle units.</p> <code>TIME</code> <code>str</code> <p>Represents time units.</p> <code>FREQUENCY</code> <code>str</code> <p>Represents frequency units.</p> <code>MASS</code> <code>str</code> <p>Represents mass units.</p> <code>CURRENT</code> <code>str</code> <p>Represents electric current units.</p> <code>TEMPERATURE</code> <code>str</code> <p>Represents temperature units.</p> <code>AMOUNT</code> <code>str</code> <p>Represents amount of substance units.</p> <code>LUMINOSITY</code> <code>str</code> <p>Represents luminous intensity units.</p> <code>FORCE</code> <code>str</code> <p>Represents force units.</p> <code>ENERGY</code> <code>str</code> <p>Represents energy units.</p> <code>POWER</code> <code>str</code> <p>Represents power units.</p> <code>PRESSURE</code> <code>str</code> <p>Represents pressure units.</p> <code>ELECTRICITY_AND_MAGNETISM</code> <code>str</code> <p>Represents electricity and magnetism units.</p> <code>OTHER</code> <code>str</code> <p>Represents other units.</p> <code>WEIGHT</code> <code>str</code> <p>Represents weight units.</p>"},{"location":"units/#albert.collections.units.UnitCategory.AMOUNT","title":"AMOUNT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AMOUNT = 'Amount of substance'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.ANGLES","title":"ANGLES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ANGLES = 'Angles'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.AREA","title":"AREA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AREA = 'Area'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.BINARY","title":"BINARY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BINARY = 'Binary'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.CAPACITANCE","title":"CAPACITANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CAPACITANCE = 'Capacitance'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.CURRENT","title":"CURRENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CURRENT = 'Electric current'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.DENSITY","title":"DENSITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DENSITY = 'Density'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.ELECTRICAL_CONDUCTIVITY","title":"ELECTRICAL_CONDUCTIVITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ELECTRICAL_CONDUCTIVITY = 'Electrical conductivity'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.ELECTRICAL_PERMITTIVITY","title":"ELECTRICAL_PERMITTIVITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ELECTRICAL_PERMITTIVITY = 'Electrical permitivitty'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.ELECTRICITY_AND_MAGNETISM","title":"ELECTRICITY_AND_MAGNETISM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ELECTRICITY_AND_MAGNETISM = 'Electricity and magnetism'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.ENERGY","title":"ENERGY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENERGY = 'Energy'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.FORCE","title":"FORCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FORCE = 'Force'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.FREQUENCY","title":"FREQUENCY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FREQUENCY = 'Frequency'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.LENGTH","title":"LENGTH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LENGTH = 'Length'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.LIQUID_VOLUME","title":"LIQUID_VOLUME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIQUID_VOLUME = 'Liquid volume'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.LUMINOSITY","title":"LUMINOSITY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LUMINOSITY = 'Luminous intensity'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.MASS","title":"MASS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MASS = 'Mass'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.OTHER","title":"OTHER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OTHER = 'Other'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.POWER","title":"POWER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POWER = 'Power'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.PRESSURE","title":"PRESSURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRESSURE = 'Pressure'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.RESISTANCE","title":"RESISTANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RESISTANCE = 'Resistance'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.SPEED","title":"SPEED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SPEED = 'Speed'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.SURFACE_AREA","title":"SURFACE_AREA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SURFACE_AREA = 'Surface Area'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.TEMPERATURE","title":"TEMPERATURE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEMPERATURE = 'Temperature'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.TIME","title":"TIME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TIME = 'Time'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.VOLUME","title":"VOLUME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VOLUME = 'Volume'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCategory.WEIGHT","title":"WEIGHT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WEIGHT = 'Weight'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCollection","title":"UnitCollection","text":"<pre><code>UnitCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>UnitCollection is a collection class for managing Unit entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Creates a new unit entity.</p> <code>delete</code> <p>Deletes a unit by its ID.</p> <code>get_by_id</code> <p>Retrieves a unit by its ID.</p> <code>get_by_name</code> <p>Retrieves a unit by its name.</p> <code>list</code> <p>Lists unit entities with optional filters.</p> <code>unit_exists</code> <p>Checks if a unit exists by its name.</p> <code>update</code> <p>Updates a unit entity by its ID.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the UnitCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{UnitCollection._api_version}/units\"\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/units'\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCollection.create","title":"create","text":"<pre><code>create(*, unit: Unit) -&gt; Unit\n</code></pre> <p>Creates a new unit entity.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit</code> <p>The unit object to create.</p> required <p>Returns:</p> Type Description <code>Unit</code> <p>The created Unit object.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def create(self, *, unit: Unit) -&gt; Unit:\n    \"\"\"\n    Creates a new unit entity.\n\n    Parameters\n    ----------\n    unit : Unit\n        The unit object to create.\n\n    Returns\n    -------\n    Unit\n        The created Unit object.\n    \"\"\"\n    hit = self.get_by_name(name=unit.name, exact_match=True)\n    if hit is not None:\n        logging.warning(\n            f\"Unit with the name {hit.name} already exists. Returning the existing unit.\"\n        )\n        return hit\n    response = self.session.post(\n        self.base_path, json=unit.model_dump(by_alias=True, exclude_unset=True, mode=\"json\")\n    )\n    this_unit = Unit(**response.json())\n    return this_unit\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCollection.delete","title":"delete","text":"<pre><code>delete(*, id: str) -&gt; None\n</code></pre> <p>Deletes a unit by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the unit to delete.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>src/albert/collections/units.py</code> <pre><code>def delete(self, *, id: str) -&gt; None:\n    \"\"\"\n    Deletes a unit by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the unit to delete.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    self.session.delete(url)\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Unit\n</code></pre> <p>Retrieves a unit by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the unit to retrieve.</p> required <p>Returns:</p> Type Description <code>Unit</code> <p>The Unit object if found.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Unit:\n    \"\"\"\n    Retrieves a unit by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the unit to retrieve.\n\n    Returns\n    -------\n    Unit\n        The Unit object if found.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    this_unit = Unit(**response.json())\n    return this_unit\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCollection.get_by_name","title":"get_by_name","text":"<pre><code>get_by_name(\n    *, name: str, exact_match: bool = False\n) -&gt; Unit | None\n</code></pre> <p>Retrieves a unit by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the unit to retrieve.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[Unit]</code> <p>The Unit object if found, None otherwise.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def get_by_name(self, *, name: str, exact_match: bool = False) -&gt; Unit | None:\n    \"\"\"\n    Retrieves a unit by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the unit to retrieve.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default False.\n\n    Returns\n    -------\n    Optional[Unit]\n        The Unit object if found, None otherwise.\n    \"\"\"\n    found = self.list(name=name, exact_match=exact_match)\n    return next(found, None)\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 100,\n    name: str | list[str] | None = None,\n    category: UnitCategory | None = None,\n    order_by: OrderBy = DESCENDING,\n    exact_match: bool = False,\n    start_key: str | None = None,\n    verified: bool | None = None,\n) -&gt; Iterator[Unit]\n</code></pre> <p>Lists unit entities with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The maximum number of units to return, by default 50.</p> <code>100</code> <code>name</code> <code>Optional[str]</code> <p>The name of the unit to filter by, by default None.</p> <code>None</code> <code>category</code> <code>Optional[UnitCategory]</code> <p>The category of the unit to filter by, by default None.</p> <code>None</code> <code>order_by</code> <code>OrderBy</code> <p>The order by which to sort the results, by default OrderBy.DESCENDING.</p> <code>DESCENDING</code> <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default False.</p> <code>False</code> <code>start_key</code> <code>Optional[str]</code> <p>The starting point for the next set of results, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[Unit]</code> <p>An iterator of Unit objects.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 100,\n    name: str | list[str] | None = None,\n    category: UnitCategory | None = None,\n    order_by: OrderBy = OrderBy.DESCENDING,\n    exact_match: bool = False,\n    start_key: str | None = None,\n    verified: bool | None = None,\n) -&gt; Iterator[Unit]:\n    \"\"\"\n    Lists unit entities with optional filters.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The maximum number of units to return, by default 50.\n    name : Optional[str], optional\n        The name of the unit to filter by, by default None.\n    category : Optional[UnitCategory], optional\n        The category of the unit to filter by, by default None.\n    order_by : OrderBy, optional\n        The order by which to sort the results, by default OrderBy.DESCENDING.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default False.\n    start_key : Optional[str], optional\n        The starting point for the next set of results, by default None.\n\n    Returns\n    -------\n    Iterator[Unit]\n        An iterator of Unit objects.\n    \"\"\"\n    params = {\n        \"limit\": limit,\n        \"startKey\": start_key,\n        \"orderBy\": order_by.value,\n        \"name\": [name] if isinstance(name, str) else name,\n        \"exactMatch\": json.dumps(exact_match),\n        \"verified\": json.dumps(verified) if verified is not None else None,\n        \"category\": category.value if isinstance(category, UnitCategory) else category,\n    }\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        session=self.session,\n        params=params,\n        deserialize=lambda items: [Unit(**item) for item in items],\n    )\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCollection.unit_exists","title":"unit_exists","text":"<pre><code>unit_exists(*, name: str, exact_match: bool = True) -&gt; bool\n</code></pre> <p>Checks if a unit exists by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the unit to check.</p> required <code>exact_match</code> <code>bool</code> <p>Whether to match the name exactly, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the unit exists, False otherwise.</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def unit_exists(self, *, name: str, exact_match: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if a unit exists by its name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the unit to check.\n    exact_match : bool, optional\n        Whether to match the name exactly, by default True.\n\n    Returns\n    -------\n    bool\n        True if the unit exists, False otherwise.\n    \"\"\"\n    return self.get_by_name(name=name, exact_match=exact_match) is not None\n</code></pre>"},{"location":"units/#albert.collections.units.UnitCollection.update","title":"update","text":"<pre><code>update(*, unit: Unit) -&gt; Unit\n</code></pre> <p>Updates a unit entity by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit</code> <p>The updated Unit object.</p> required <p>Returns:</p> Type Description <code>Unit</code> <p>The updated Unit</p> Source code in <code>src/albert/collections/units.py</code> <pre><code>def update(self, *, unit: Unit) -&gt; Unit:\n    \"\"\"\n    Updates a unit entity by its ID.\n\n    Parameters\n    ----------\n    unit : Unit\n        The updated Unit object.\n\n    Returns\n    -------\n    Unit\n        The updated Unit\n    \"\"\"\n    unit_id = unit.id\n    original_unit = self.get_by_id(id=unit_id)\n    payload = self._generate_patch_payload(existing=original_unit, updated=unit)\n    url = f\"{self.base_path}/{unit_id}\"\n    self.session.patch(url, json=payload.model_dump(mode=\"json\", by_alias=True))\n    unit = self.get_by_id(id=unit_id)\n    return unit\n</code></pre>"},{"location":"users/","title":"Users","text":""},{"location":"users/#albert.collections.users.AlbertHTTPError","title":"AlbertHTTPError","text":"<pre><code>AlbertHTTPError(response: Response)\n</code></pre> <p>               Bases: <code>AlbertException</code></p> <p>Base class for all erors due to HTTP responses.</p> Source code in <code>src/albert/exceptions.py</code> <pre><code>def __init__(self, response: requests.Response):\n    message = self._format_message(response)\n    super().__init__(message)\n    self.response = response\n</code></pre>"},{"location":"users/#albert.collections.users.AlbertHTTPError.response","title":"response  <code>instance-attribute</code>","text":"<pre><code>response = response\n</code></pre>"},{"location":"users/#albert.collections.users.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"users/#albert.collections.users.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"users/#albert.collections.users.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"users/#albert.collections.users.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"users/#albert.collections.users.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"users/#albert.collections.users.Status","title":"Status","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The status of a resource</p>"},{"location":"users/#albert.collections.users.Status.ACTIVE","title":"ACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE = 'active'\n</code></pre>"},{"location":"users/#albert.collections.users.Status.INACTIVE","title":"INACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INACTIVE = 'inactive'\n</code></pre>"},{"location":"users/#albert.collections.users.User","title":"User","text":"<p>               Bases: <code>BaseResource</code></p> <p>Represents a User on the Albert Platform</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the user.</p> <code>id</code> <code>str | None</code> <p>The Albert ID of the user. Set when the user is retrieved from Albert.</p> <code>location</code> <code>Location | None</code> <p>The location of the user.</p> <code>email</code> <code>EmailStr | None</code> <p>The email of the user.</p> <code>roles</code> <code>list[Role]</code> <p>The roles of the user.</p> <code>user_class</code> <code>UserClass</code> <p>The ACL class level of the user.</p> <code>metadata</code> <code>dict[str, str | list[EntityLink] | EntityLink] | None</code> <p>Methods:</p> Name Description <code>to_note_mention</code> <p>Convert the user to a note mention string.</p>"},{"location":"users/#albert.collections.users.User.email","title":"email  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>email: EmailStr = Field(default=None, alias='email')\n</code></pre>"},{"location":"users/#albert.collections.users.User.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: UserId | None = Field(None, alias='albertId')\n</code></pre>"},{"location":"users/#albert.collections.users.User.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: SerializeAsEntityLink[Location] | None = Field(\n    default=None, alias=\"Location\"\n)\n</code></pre>"},{"location":"users/#albert.collections.users.User.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, MetadataItem] | None = Field(\n    alias=\"Metadata\", default=None\n)\n</code></pre>"},{"location":"users/#albert.collections.users.User.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"users/#albert.collections.users.User.roles","title":"roles  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>roles: list[SerializeAsEntityLink[Role]] = Field(\n    max_length=1, default_factory=list, alias=\"Roles\"\n)\n</code></pre>"},{"location":"users/#albert.collections.users.User.user_class","title":"user_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_class: UserClass = Field(\n    default=STANDARD, alias=\"userClass\"\n)\n</code></pre>"},{"location":"users/#albert.collections.users.User.to_note_mention","title":"to_note_mention","text":"<pre><code>to_note_mention() -&gt; str\n</code></pre> <p>Convert the user to a note mention string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The note mention string.</p> Source code in <code>src/albert/resources/users.py</code> <pre><code>def to_note_mention(self) -&gt; str:\n    \"\"\"Convert the user to a note mention string.\n\n    Returns\n    -------\n    str\n        The note mention string.\n    \"\"\"\n    return f\"@{self.name}#{self.id}#\"\n</code></pre>"},{"location":"users/#albert.collections.users.UserCollection","title":"UserCollection","text":"<pre><code>UserCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>UserCollection is a collection class for managing User entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create a new User</p> <code>get_by_id</code> <p>Retrieves a User by its ID.</p> <code>get_current_user</code> <p>Retrieves the current authenticated user.</p> <code>list</code> <p>Lists Users based on criteria</p> <code>update</code> <p>Update a User entity.</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the UserCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{UserCollection._api_version}/users\"\n</code></pre>"},{"location":"users/#albert.collections.users.UserCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/users'\n</code></pre>"},{"location":"users/#albert.collections.users.UserCollection.create","title":"create","text":"<pre><code>create(*, user: User) -&gt; User\n</code></pre> <p>Create a new User</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The user to create</p> required <p>Returns:</p> Type Description <code>User</code> <p>The created User</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def create(self, *, user: User) -&gt; User:  # pragma: no cover\n    \"\"\"Create a new User\n\n    Parameters\n    ----------\n    user : User\n        The user to create\n\n    Returns\n    -------\n    User\n        The created User\n    \"\"\"\n\n    hits = self.list(text=user.email)\n    for u in hits:\n        if u.email == user.email:\n            logging.warning(\n                f\"User with email {user.email} already exists. Returning existing user.\"\n            )\n            return u\n\n    response = self.session.post(\n        self.base_path,\n        json=user.model_dump(by_alias=True, exclude_none=True, mode=\"json\"),\n    )\n    return User(**response.json())\n</code></pre>"},{"location":"users/#albert.collections.users.UserCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; User\n</code></pre> <p>Retrieves a User by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the user to retrieve.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The User object.</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; User:\n    \"\"\"\n    Retrieves a User by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the user to retrieve.\n\n    Returns\n    -------\n    User\n        The User object.\n    \"\"\"\n    url = f\"{self.base_path}/{id}\"\n    response = self.session.get(url)\n    return User(**response.json())\n</code></pre>"},{"location":"users/#albert.collections.users.UserCollection.get_current_user","title":"get_current_user","text":"<pre><code>get_current_user() -&gt; User\n</code></pre> <p>Retrieves the current authenticated user.</p> <p>Returns:</p> Type Description <code>User</code> <p>The current User object.</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def get_current_user(self) -&gt; User:\n    \"\"\"\n    Retrieves the current authenticated user.\n\n    Returns\n    -------\n    User\n        The current User object.\n    \"\"\"\n    claims = jwt.decode(self.session._access_token, options={\"verify_signature\": False})\n    return self.get_by_id(id=claims[\"id\"])\n</code></pre>"},{"location":"users/#albert.collections.users.UserCollection.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int = 50,\n    offset: int | None = None,\n    text: str | None = None,\n    status: Status | None = None,\n    search_fields: str | None = None,\n) -&gt; Iterator[User]\n</code></pre> <p>Lists Users based on criteria</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Optional[str]</code> <p>text to search against, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Generator</code> <p>Generator of matching Users or None</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int = 50,\n    offset: int | None = None,\n    text: str | None = None,\n    status: Status | None = None,\n    search_fields: str | None = None,\n) -&gt; Iterator[User]:\n    \"\"\"Lists Users based on criteria\n\n    Parameters\n    ----------\n    text : Optional[str], optional\n        text to search against, by default None\n\n    Returns\n    -------\n    Generator\n        Generator of matching Users or None\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; Iterator[User]:\n        for item in items:\n            id = item[\"albertId\"]\n            try:\n                yield self.get_by_id(id=id)\n            except AlbertHTTPError as e:\n                logger.warning(f\"Error fetching user '{id}': {e}\")\n\n    params = {\n        \"limit\": limit,\n        \"offset\": offset,\n        \"status\": status,\n        \"text\": text,\n        \"searchFields\": search_fields,\n    }\n\n    return AlbertPaginator(\n        mode=PaginationMode.OFFSET,\n        path=f\"{self.base_path}/search\",\n        session=self.session,\n        params=params,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"users/#albert.collections.users.UserCollection.update","title":"update","text":"<pre><code>update(*, user: User) -&gt; User\n</code></pre> <p>Update a User entity.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>The updated User entity.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The updated User entity as returned by the server.</p> Source code in <code>src/albert/collections/users.py</code> <pre><code>def update(self, *, user: User) -&gt; User:\n    \"\"\"Update a User entity.\n\n    Parameters\n    ----------\n    user : User\n        The updated User entity.\n\n    Returns\n    -------\n    User\n        The updated User entity as returned by the server.\n    \"\"\"\n    # Fetch the current object state from the server or database\n    current_object = self.get_by_id(id=user.id)\n\n    # Generate the PATCH payload\n    payload = self._generate_patch_payload(existing=current_object, updated=user)\n\n    url = f\"{self.base_path}/{user.id}\"\n    self.session.patch(url, json=payload.model_dump(mode=\"json\", by_alias=True))\n\n    updated_user = self.get_by_id(id=user.id)\n    return updated_user\n</code></pre>"},{"location":"workflows/","title":"Workflows","text":""},{"location":"workflows/#albert.collections.workflows.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.Workflow","title":"Workflow","text":"<p>               Bases: <code>BaseResource</code></p> <p>A Pydantic Class representing a workflow in Albert.</p> <p>Workflows are combinations of Data Templates and Parameter groups and their associated setpoints.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the workflow.</p> <code>parameter_group_setpoints</code> <code>list[ParameterGroupSetpoints]</code> <p>The setpoints to apply to the parameter groups in the workflow.</p> <code>id</code> <code>str | None</code> <p>The AlbertID of the workflow. This is set when a workflow is retrived from the platform.</p> <p>Methods:</p> Name Description <code>get_interval_id</code> <p>Get the interval ID for a set of parameter values.</p> <code>model_post_init</code>"},{"location":"workflows/#albert.collections.workflows.Workflow.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str | None = Field(\n    alias=\"albertId\",\n    default=None,\n    validation_alias=AliasChoices(\n        \"albertId\", \"existingAlbertId\"\n    ),\n    exclude=True,\n)\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.Workflow.interval_combinations","title":"interval_combinations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interval_combinations: list[IntervalCombination] | None = (\n    Field(default=None, alias=\"IntervalCombinations\")\n)\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.Workflow.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.Workflow.parameter_group_setpoints","title":"parameter_group_setpoints  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parameter_group_setpoints: list[ParameterGroupSetpoints] = (\n    Field(alias=\"ParameterGroups\")\n)\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.Workflow.get_interval_id","title":"get_interval_id","text":"<pre><code>get_interval_id(parameter_values: dict[str, any]) -&gt; str\n</code></pre> <p>Get the interval ID for a set of parameter values.</p> <p>This method matches parameter values to intervals defined in the workflow and constructs a composite interval ID. For multiple parameters, the interval IDs are joined with 'X'.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_values</code> <code>dict[str, any]</code> <p>Dictionary mapping parameter names to their values. Values can be numbers or strings that match the interval values defined in the workflow.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The composite interval ID string. For a single parameter this is just the interval ID. For multiple parameters, interval IDs are joined with 'X' (e.g. \"ROW1XROW2\").</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any parameter value does not match a defined interval in the workflow.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; workflow = Workflow(...)\n&gt;&gt;&gt; # Single parameter\n&gt;&gt;&gt; workflow.get_interval_id({\"Temperature\": 25})\n'ROW1'\n&gt;&gt;&gt; # Multiple parameters\n&gt;&gt;&gt; workflow.get_interval_id({\"Temperature\": 25, \"Time\": 60})\n'ROW1XROW2'\n&gt;&gt;&gt; # Non-matching value raises error\n&gt;&gt;&gt; workflow.get_interval_id({\"Temperature\": 999})\nAlbertException: No matching interval found for parameter 'Temperature' with value '999'\n</code></pre> Source code in <code>src/albert/resources/workflows.py</code> <pre><code>def get_interval_id(self, parameter_values: dict[str, any]) -&gt; str:\n    \"\"\"Get the interval ID for a set of parameter values.\n\n    This method matches parameter values to intervals defined in the workflow and constructs\n    a composite interval ID. For multiple parameters, the interval IDs are joined with 'X'.\n\n    Parameters\n    ----------\n    parameter_values : dict[str, any]\n        Dictionary mapping parameter names to their values. Values can be numbers or strings\n        that match the interval values defined in the workflow.\n\n    Returns\n    -------\n    str\n        The composite interval ID string. For a single parameter this is just the interval ID.\n        For multiple parameters, interval IDs are joined with 'X' (e.g. \"ROW1XROW2\").\n\n    Raises\n    ------\n    ValueError\n        If any parameter value does not match a defined interval in the workflow.\n\n    Examples\n    --------\n    &gt;&gt;&gt; workflow = Workflow(...)\n    &gt;&gt;&gt; # Single parameter\n    &gt;&gt;&gt; workflow.get_interval_id({\"Temperature\": 25})\n    'ROW1'\n    &gt;&gt;&gt; # Multiple parameters\n    &gt;&gt;&gt; workflow.get_interval_id({\"Temperature\": 25, \"Time\": 60})\n    'ROW1XROW2'\n    &gt;&gt;&gt; # Non-matching value raises error\n    &gt;&gt;&gt; workflow.get_interval_id({\"Temperature\": 999})\n    AlbertException: No matching interval found for parameter 'Temperature' with value '999'\n    \"\"\"\n    interval_id = \"\"\n    for param_name, param_value in parameter_values.items():\n        matching_interval = None\n        for workflow_interval in self._interval_parameters:\n            if workflow_interval.interval_param_name.lower() == param_name.lower() and (\n                param_value == workflow_interval.interval_value\n                or str(param_value) == workflow_interval.interval_value\n            ):\n                matching_interval = workflow_interval\n                break\n\n        if matching_interval is None:\n            raise AlbertException(\n                f\"No matching interval found for parameter '{param_name}' with value '{param_value}'\"\n            )\n\n        interval_id += (\n            f\"X{matching_interval.interval_id}\"\n            if interval_id != \"\"\n            else matching_interval.interval_id\n        )\n\n    return interval_id\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.Workflow.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context) -&gt; None\n</code></pre> Source code in <code>src/albert/resources/workflows.py</code> <pre><code>def model_post_init(self, __context) -&gt; None:\n    self._populate_interval_parameters()\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.WorkflowCollection","title":"WorkflowCollection","text":"<pre><code>WorkflowCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>WorkflowCollection is a collection class for managing Workflow entities in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert session instance.</p> required <p>Methods:</p> Name Description <code>create</code> <p>Create or return matching workflows for the provided list of workflows.</p> <code>get_by_id</code> <p>Retrieve a Workflow by its ID.</p> <code>get_by_ids</code> <p>Returns a list of Workflow objects by their IDs.</p> <code>list</code> <p>List all workflows. Unlikly to be used in production.</p> Source code in <code>src/albert/collections/workflows.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    \"\"\"\n    Initializes the WorkflowCollection with the provided session.\n\n    Parameters\n    ----------\n    session : AlbertSession\n        The Albert session instance.\n    \"\"\"\n    super().__init__(session=session)\n    self.base_path = f\"/api/{WorkflowCollection._api_version}/workflows\"\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.WorkflowCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/workflows'\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.WorkflowCollection.create","title":"create","text":"<pre><code>create(*, workflows: list[Workflow]) -&gt; list[Workflow]\n</code></pre> <p>Create or return matching workflows for the provided list of workflows. This endpoint automatically tries to find an existing workflow with the same parameter setpoints, and will either return the existing workflow or create a new one.</p> <p>Parameters:</p> Name Type Description Default <code>workflows</code> <code>list[Workflow]</code> <p>A list of Workflow objects to find or create.</p> required <p>Returns:</p> Type Description <code>list[Workflow]</code> <p>A list of created or found Workflow objects.</p> Source code in <code>src/albert/collections/workflows.py</code> <pre><code>def create(self, *, workflows: list[Workflow]) -&gt; list[Workflow]:\n    \"\"\"Create or return matching workflows for the provided list of workflows.\n    This endpoint automatically tries to find an existing workflow with the same parameter setpoints, and will either return the existing workflow or create a new one.\n\n    Parameters\n    ----------\n    workflows : list[Workflow]\n        A list of Workflow objects to find or create.\n\n    Returns\n    -------\n    list[Workflow]\n        A list of created or found Workflow objects.\n    \"\"\"\n    if isinstance(workflows, Workflow):\n        # in case the user forgets this should be a list\n        workflows = [workflows]\n    response = self.session.post(\n        url=f\"{self.base_path}/bulk\",\n        json=[x.model_dump(mode=\"json\", by_alias=True, exclude_none=True) for x in workflows],\n    )\n    return [Workflow(**x) for x in response.json()]\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.WorkflowCollection.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(*, id: str) -&gt; Workflow\n</code></pre> <p>Retrieve a Workflow by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the Workflow to retrieve.</p> required <p>Returns:</p> Type Description <code>Workflow</code> <p>The Workflow object.</p> Source code in <code>src/albert/collections/workflows.py</code> <pre><code>def get_by_id(self, *, id: str) -&gt; Workflow:\n    \"\"\"Retrieve a Workflow by its ID.\n\n    Parameters\n    ----------\n    id : str\n        The ID of the Workflow to retrieve.\n\n    Returns\n    -------\n    Workflow\n        The Workflow object.\n    \"\"\"\n    response = self.session.get(f\"{self.base_path}/{id}\")\n    return Workflow(**response.json())\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.WorkflowCollection.get_by_ids","title":"get_by_ids","text":"<pre><code>get_by_ids(*, ids: list[str]) -&gt; list[Workflow]\n</code></pre> <p>Returns a list of Workflow objects by their IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>The list of Workflow IDs to retrieve.</p> required <p>Returns:</p> Type Description <code>list[Workflow]</code> <p>The list of Workflow objects matching the provided IDs.</p> Source code in <code>src/albert/collections/workflows.py</code> <pre><code>def get_by_ids(self, *, ids: list[str]) -&gt; list[Workflow]:\n    \"\"\"Returns a list of Workflow objects by their IDs.\n\n    Parameters\n    ----------\n    ids : list[str]\n        The list of Workflow IDs to retrieve.\n\n    Returns\n    -------\n    list[Workflow]\n        The list of Workflow objects matching the provided IDs.\n    \"\"\"\n    url = f\"{self.base_path}/ids\"\n    batches = [ids[i : i + 100] for i in range(0, len(ids), 100)]\n    return [\n        Workflow(**item)\n        for batch in batches\n        for item in self.session.get(url, params={\"id\": batch}).json()[\"Items\"]\n    ]\n</code></pre>"},{"location":"workflows/#albert.collections.workflows.WorkflowCollection.list","title":"list","text":"<pre><code>list(limit: int = 50) -&gt; Iterator[Workflow]\n</code></pre> <p>List all workflows. Unlikly to be used in production.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>The number of workflows to return, by default 50.</p> <code>50</code> <p>Yields:</p> Type Description <code>Iterator[Workflow]</code> <p>An iterator of Workflow objects.</p> Source code in <code>src/albert/collections/workflows.py</code> <pre><code>def list(self, limit: int = 50) -&gt; Iterator[Workflow]:\n    \"\"\"List all workflows. Unlikly to be used in production.\n\n    Parameters\n    ----------\n    limit : int, optional\n        The number of workflows to return, by default 50.\n\n    Yields\n    ------\n    Iterator[Workflow]\n        An iterator of Workflow objects.\n    \"\"\"\n\n    def deserialize(items: list[dict]) -&gt; list[Workflow]:\n        return self.get_by_ids(ids=[x[\"albertId\"] for x in items])\n\n    params = {\"limit\": limit}\n    return AlbertPaginator(\n        mode=PaginationMode.KEY,\n        path=self.base_path,\n        params=params,\n        session=self.session,\n        deserialize=deserialize,\n    )\n</code></pre>"},{"location":"worksheets/","title":"Worksheets","text":""},{"location":"worksheets/#albert.collections.worksheets.ProjectId","title":"ProjectId  <code>module-attribute</code>","text":"<pre><code>ProjectId = Annotated[\n    str, AfterValidator(ensure_project_id)\n]\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.AlbertSession","title":"AlbertSession","text":"<pre><code>AlbertSession(\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Session</code></p> <p>A session that has a base URL, which is prefixed to all request URLs.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL to prefix to all requests. (e.g., \"https://sandbox.albertinvent.com\")</p> required <code>retries</code> <code>int</code> <p>The number of retries for failed requests. Defaults to 3.</p> <code>None</code> <code>client_credentials</code> <code>ClientCredentials | None</code> <p>The client credentials for programmatic authentication. Optional if token is provided.</p> <code>None</code> <code>token</code> <code>str | None</code> <p>The JWT token for authentication. Optional if client credentials are provided.</p> <code>None</code> <p>Methods:</p> Name Description <code>request</code> Source code in <code>src/albert/session.py</code> <pre><code>def __init__(\n    self,\n    *,\n    base_url: str,\n    token: str | None = None,\n    client_credentials: ClientCredentials | None = None,\n    retries: int | None = None,\n):\n    super().__init__()\n    self.base_url = base_url\n    self.headers.update(\n        {\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"User-Agent\": f\"albert-SDK V.{albert.__version__}\",\n        }\n    )\n\n    if token is None and client_credentials is None:\n        raise ValueError(\"Either client credentials or token must be specified.\")\n\n    self._provided_token = token\n    self._token_manager = (\n        TokenManager(base_url, client_credentials) if client_credentials is not None else None\n    )\n\n    # Set up retry logic\n    retries = retries if retries is not None else 3\n    retry = Retry(\n        total=retries,\n        read=retries,\n        connect=retries,\n        backoff_factor=0.3,\n        status_forcelist=(500, 502, 503, 504, 403),\n        raise_on_status=False,\n    )\n    adapter = HTTPAdapter(max_retries=retry)\n    self.mount(\"http://\", adapter)\n    self.mount(\"https://\", adapter)\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.AlbertSession.base_url","title":"base_url  <code>instance-attribute</code>","text":"<pre><code>base_url = base_url\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.AlbertSession.request","title":"request","text":"<pre><code>request(\n    method: str, path: str, *args, **kwargs\n) -&gt; Response\n</code></pre> Source code in <code>src/albert/session.py</code> <pre><code>def request(self, method: str, path: str, *args, **kwargs) -&gt; requests.Response:\n    self.headers[\"Authorization\"] = f\"Bearer {self._access_token}\"\n    full_url = urljoin(self.base_url, path) if not path.startswith(\"http\") else path\n    with handle_http_errors():\n        response = super().request(method, full_url, *args, **kwargs)\n        response.raise_for_status()\n        return response\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.BaseCollection","title":"BaseCollection","text":"<pre><code>BaseCollection(*, session: AlbertSession)\n</code></pre> <p>BaseCollection is the base class for all collection classes.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AlbertSession</code> <p>The Albert API Session instance.</p> required Source code in <code>src/albert/collections/base.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    self.session = session\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.BaseCollection.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.Worksheet","title":"Worksheet","text":"<pre><code>Worksheet(**data)\n</code></pre> <p>               Bases: <code>BaseSessionResource</code></p> <p>A worksheet entity.</p> <p>Attributes:</p> Name Type Description <code>sheets</code> <code>List[Sheet]</code> <p>A list of sheet entities.</p> <code>project_name</code> <code>str | None</code> <p>The name of the project.</p> <code>sheets_enabled</code> <code>bool</code> <p>Whether the sheets are enabled.</p> <code>project_id</code> <code>str</code> <p>The Albert ID of the project.</p> <p>Methods:</p> Name Description <code>add_session_to_sheets</code> Source code in <code>src/albert/resources/base.py</code> <pre><code>def __init__(self, **data):\n    super().__init__(**data)\n    self._session = data.get(\"session\")\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.Worksheet.project_id","title":"project_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>project_id: str = Field(alias='projectId')\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.Worksheet.project_name","title":"project_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>project_name: str | None = Field(\n    default=None, alias=\"projectName\"\n)\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.Worksheet.sheets","title":"sheets  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sheets: list[Sheet] = Field(alias='Sheets')\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.Worksheet.sheets_enabled","title":"sheets_enabled  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sheets_enabled: bool = Field(\n    default=True, alias=\"sheetEnabled\"\n)\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.Worksheet.add_session_to_sheets","title":"add_session_to_sheets","text":"<pre><code>add_session_to_sheets()\n</code></pre> Source code in <code>src/albert/resources/worksheets.py</code> <pre><code>@model_validator(mode=\"after\")\ndef add_session_to_sheets(self):\n    if self.session is not None:\n        for s in self.sheets:\n            s._session = self.session\n            for d in s.designs:\n                d._session = self.session\n    return self\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.WorksheetCollection","title":"WorksheetCollection","text":"<pre><code>WorksheetCollection(*, session: AlbertSession)\n</code></pre> <p>               Bases: <code>BaseCollection</code></p> <p>WorksheetCollection is a collection class for managing Worksheet entities in the Albert platform.</p> <p>Methods:</p> Name Description <code>add_sheet</code> <p>Create a new blank sheet in the Worksheet with the specified name.</p> <code>get_by_project_id</code> <p>Retrieve a worksheet by its project ID. Projects and Worksheets are 1:1 in the Albert platform.</p> <code>setup_new_sheet_from_template</code> <p>Create a new sheet in the Worksheet related to the specified Project from a template.</p> <code>setup_worksheet</code> <p>Setup a new worksheet for a project.</p> Source code in <code>src/albert/collections/worksheets.py</code> <pre><code>def __init__(self, *, session: AlbertSession):\n    super().__init__(session=session)\n    self.base_path = f\"/api/{WorksheetCollection._api_version}/worksheet\"\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.WorksheetCollection.base_path","title":"base_path  <code>instance-attribute</code>","text":"<pre><code>base_path = f'/api/{_api_version}/worksheet'\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.WorksheetCollection.add_sheet","title":"add_sheet","text":"<pre><code>add_sheet(\n    *, project_id: ProjectId, sheet_name: str\n) -&gt; Worksheet\n</code></pre> <p>Create a new blank sheet in the Worksheet with the specified name.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The project ID for the Worksheet to add the sheet to.</p> required <code>sheet_name</code> <code>str</code> <p>The name of the new sheet.</p> required <p>Returns:</p> Type Description <code>Worksheet</code> <p>The Worksheet object for the project.</p> Source code in <code>src/albert/collections/worksheets.py</code> <pre><code>def add_sheet(self, *, project_id: ProjectId, sheet_name: str) -&gt; Worksheet:\n    \"\"\"Create a new blank sheet in the Worksheet with the specified name.\n\n    Parameters\n    ----------\n    project_id : str\n        The project ID for the Worksheet to add the sheet to.\n    sheet_name : str\n        The name of the new sheet.\n\n    Returns\n    -------\n    Worksheet\n        The Worksheet object for the project.\n    \"\"\"\n    payload = {\"name\": sheet_name}\n    url = f\"{self.base_path}/project/{project_id}/sheets\"\n    self.session.put(url=url, json=payload)\n    return self.get_by_project_id(project_id=project_id)\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.WorksheetCollection.get_by_project_id","title":"get_by_project_id","text":"<pre><code>get_by_project_id(*, project_id: ProjectId) -&gt; Worksheet\n</code></pre> <p>Retrieve a worksheet by its project ID. Projects and Worksheets are 1:1 in the Albert platform.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The project ID to retrieve the worksheet for.</p> required <p>Returns:</p> Type Description <code>Worksheet</code> <p>The Worksheet object for that project.</p> Source code in <code>src/albert/collections/worksheets.py</code> <pre><code>def get_by_project_id(self, *, project_id: ProjectId) -&gt; Worksheet:\n    \"\"\"Retrieve a worksheet by its project ID. Projects and Worksheets are 1:1 in the Albert platform.\n\n    Parameters\n    ----------\n    project_id : str\n        The project ID to retrieve the worksheet for.\n\n    Returns\n    -------\n    Worksheet\n        The Worksheet object for that project.\n    \"\"\"\n\n    params = {\"type\": \"project\", \"id\": project_id}\n    response = self.session.get(self.base_path, params=params)\n\n    response_json = response.json()\n\n    # Sheets are themselves collections, and therefore need access to the session\n    response_json = self._add_session_to_sheets(response_json)\n\n    return Worksheet(**response_json)\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.WorksheetCollection.setup_new_sheet_from_template","title":"setup_new_sheet_from_template","text":"<pre><code>setup_new_sheet_from_template(\n    *,\n    project_id: ProjectId,\n    sheet_template_id: str,\n    sheet_name: str,\n) -&gt; Worksheet\n</code></pre> <p>Create a new sheet in the Worksheet related to the specified Project from a template.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>description</p> required <code>sheet_template_id</code> <code>str</code> <p>description</p> required <code>sheet_name</code> <code>str</code> <p>description</p> required <p>Returns:</p> Type Description <code>Worksheet</code> <p>The Worksheet object for the project.</p> Source code in <code>src/albert/collections/worksheets.py</code> <pre><code>def setup_new_sheet_from_template(\n    self, *, project_id: ProjectId, sheet_template_id: str, sheet_name: str\n) -&gt; Worksheet:\n    \"\"\"Create a new sheet in the Worksheet related to the specified Project from a template.\n\n    Parameters\n    ----------\n    project_id : str\n        _description_\n    sheet_template_id : str\n        _description_\n    sheet_name : str\n        _description_\n\n    Returns\n    -------\n    Worksheet\n        The Worksheet object for the project.\n    \"\"\"\n    payload = {\"name\": sheet_name}\n    params = {\"templateId\": sheet_template_id}\n    path = f\"{self.base_path}/project/{project_id}/sheets\"\n    self.session.post(path, json=payload, params=params)\n    return self.get_by_project_id(project_id=project_id)\n</code></pre>"},{"location":"worksheets/#albert.collections.worksheets.WorksheetCollection.setup_worksheet","title":"setup_worksheet","text":"<pre><code>setup_worksheet(\n    *, project_id: ProjectId, add_sheet=False\n) -&gt; Worksheet\n</code></pre> <p>Setup a new worksheet for a project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The project ID to setup the worksheet for.</p> required <code>add_sheet</code> <code>bool</code> <p>Whether to add a blank sheet to the worksheet, by default False</p> <code>False</code> <p>Returns:</p> Type Description <code>Worksheet</code> <p>The Worksheet object for the project.</p> Source code in <code>src/albert/collections/worksheets.py</code> <pre><code>def setup_worksheet(self, *, project_id: ProjectId, add_sheet=False) -&gt; Worksheet:\n    \"\"\"Setup a new worksheet for a project.\n\n    Parameters\n    ----------\n    project_id : str\n        The project ID to setup the worksheet for.\n    add_sheet : bool, optional\n        Whether to add a blank sheet to the worksheet, by default False\n\n    Returns\n    -------\n    Worksheet\n        The Worksheet object for the project.\n    \"\"\"\n\n    params = {\"sheets\": str(add_sheet).lower()}\n    path = f\"{self.base_path}/{project_id}/setup\"\n    self.session.post(path, json=params)\n    return self.get_by_project_id(project_id=project_id)\n</code></pre>"}]}